<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ============================================
         META & EXTERNAL RESOURCES
         ============================================ -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mickey's Learning Hub - Enhanced with Emotion & Eye Tracking</title>
    
    <!-- External CSS Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Fredoka+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@open-dyslexic/open-dyslexic@1.0.3/css/open-dyslexic.css">

    <!-- ============================================
         CSS STYLES
         Organized by component and functionality
         ============================================ -->
    <style>
        /* ------------------------------------------------------------
           ROOT VARIABLES & GLOBAL STYLES
           ------------------------------------------------------------ */
        :root {
            /* Mickey Mouse Theme Colors */
            --mickey-red: #d84a54;
            --mickey-yellow: #e9a946;
            --mickey-black: #25221a;
            --mickey-white: #e9e7db;
            --mickey-blue: #8ac6d1;
            --mickey-pink: #ffb8c6;
            --mickey-green: #95e1d3;
            --mickey-purple: #b8b8ff;
            --mickey-bg: #fff5f5;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: 'Fredoka One', cursive;
            background: linear-gradient(135deg, var(--mickey-bg) 0%, #ffe6e6 100%);
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.8) 2px, transparent 2px),
                radial-gradient(circle at 90% 80%, rgba(255, 255, 255, 0.8) 2px, transparent 2px);
            background-size: 40px 40px;
            padding-top: 120px;
        }

        /* Form input focus styles */
        input:focus, select:focus {
            outline: none;
            border-color: var(--mickey-red);
            box-shadow: 0 0 10px rgba(255, 107, 139, 0.3);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }

        /* Dyslexia-friendly mode */
        body.dyslexia-mode {
            font-family: 'OpenDyslexic', 'Comic Sans MS', sans-serif !important;
            letter-spacing: 0.1em;
            line-height: 1.8;
            background: linear-gradient(135deg, #ffffcc 0%, #fff5cc 100%) !important;
        }

        /* DYSLEXIA-SPECIFIC STYLES */
        .dyslexia-text {
            font-family: 'OpenDyslexic', 'Comic Sans MS', sans-serif !important;
            letter-spacing: 0.15em;
            line-height: 2;
            word-spacing: 0.2em;
            font-size: 1.1em;
        }

        /* Content fade-in animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ------------------------------------------------------------
           HEADER & NAVIGATION COMPONENTS
           ------------------------------------------------------------ */
        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(145deg, var(--mickey-pink), var(--mickey-red));
            border-bottom: 5px solid var(--mickey-black);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 9999;
            padding: 15px 20px;
        }

        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header-logo {
            display: flex;
            align-items: center;
            gap: 15px;
            color: var(--mickey-white);
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .header-logo:hover {
            transform: scale(1.05);
        }

        .logo-icon {
            width: 50px;
            height: 50px;
            background: var(--mickey-yellow);
            border-radius: 50%;
            border: 3px solid var(--mickey-black);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--mickey-red);
        }

        .header-nav {
            display: flex;
            gap: 10px;
        }

        .nav-tab {
            padding: 12px 20px;
            background: var(--mickey-yellow);
            color: var(--mickey-black);
            border: 3px solid var(--mickey-black);
            border-radius: 15px;
            font-family: 'Fredoka One', cursive;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .nav-tab:hover {
            background: var(--mickey-white);
            transform: translateY(-3px);
            box-shadow: 0 5px 0 var(--mickey-black);
        }

        .nav-tab.active {
            background: var(--mickey-blue);
            color: var(--mickey-white);
        }

        /* ------------------------------------------------------------
           MAIN CONTENT AREAS
           ------------------------------------------------------------ */
        .content-area {
            display: none;
            max-width: 1400px;
            margin: 0 auto;
        }

        .content-area.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .profile-content, .settings-content, .about-content {
            padding: 30px;
            background: var(--mickey-white);
            border-radius: 25px;
            border: 5px solid var(--mickey-black);
            box-shadow: 0 10px 0 var(--mickey-black);
            margin-top: 20px;
        }

        /* Demo credentials box */
        .demo-credentials {
            background: var(--mickey-yellow);
            padding: 15px;
            border-radius: 10px;
            border: 3px solid var(--mickey-black);
            margin-top: 15px;
            font-family: 'Comic Neue', cursive;
        }

        .demo-credentials code {
            background: var(--mickey-white);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--mickey-black);
            font-family: monospace;
            color: var(--mickey-red);
            margin: 2px;
        }

        /* ------------------------------------------------------------
           LEARNING HUB & GAME MODULES
           ------------------------------------------------------------ */
        .learning-hub {
            position: relative;
        }

        .mickey-header {
            text-align: center;
            position: relative;
            margin-bottom: 40px;
        }

        h1 {
            color: var(--mickey-black);
            font-size: 3rem;
            margin: 0 20px;
            text-align: center;
            letter-spacing: 2px;
            position: relative;
            z-index: 2;
        }

        /* LEARNING CONTENT GRID - MICKEY STYLE */
        .modules-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
            margin-top: 40px;
        }

        .module-card {
            background: linear-gradient(145deg, var(--mickey-white), #f5f0e6);
            border-radius: 25px;
            padding: 25px;
            box-shadow: 
                0 10px 0 var(--mickey-black),
                0 15px 20px rgba(0,0,0,0.1);
            border: 5px solid var(--mickey-black);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            min-height: 300px;
            display: flex;
            flex-direction: column;
        }

        .module-card:hover {
            transform: translateY(-10px) rotate(1deg);
            box-shadow: 
                0 15px 0 var(--mickey-black),
                0 25px 30px rgba(0,0,0,0.2);
            border-color: var(--mickey-pink);
        }

        .module-title {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--mickey-red);
            text-shadow: 2px 2px 0 var(--mickey-yellow);
            font-family: 'Fredoka One', cursive;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .module-title i {
            color: var(--mickey-black);
            background: var(--mickey-yellow);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid var(--mickey-black);
        }

        .module-desc {
            color: var(--mickey-blue);
            font-size: 1.1rem;
            line-height: 1.6;
            font-family: 'Comic Neue', cursive;
            padding-left: 10px;
            border-left: 4px solid var(--mickey-yellow);
            flex-grow: 1;
            margin-bottom: 20px;
        }

        /* MODULE CONTROLS */
        .module-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .module-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 20px;
            font-family: 'Fredoka One', cursive;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-grow: 1;
            justify-content: center;
        }

        .start-btn {
            background: linear-gradient(145deg, var(--mickey-pink), var(--mickey-red));
            color: var(--mickey-white);
            border: 3px solid var(--mickey-black);
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 107, 139, 0.4);
        }

        .view-btn {
            background: linear-gradient(145deg, var(--mickey-blue), #6aa8b5);
            color: var(--mickey-white);
            border: 3px solid var(--mickey-black);
        }

        .view-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(138, 198, 209, 0.4);
        }

        /* MODULE CONTENT AREA */
        .module-content-area {
            grid-column: 1 / -1;
            background: var(--mickey-white);
            border-radius: 25px;
            padding: 30px;
            margin-top: 40px;
            border: 5px solid var(--mickey-black);
            box-shadow: 0 10px 0 var(--mickey-black);
            display: none;
        }

        .module-content-area.active {
            display: block;
            animation: slideIn 0.5s ease;
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 4px solid var(--mickey-yellow);
        }

        .close-module {
            background: var(--mickey-red);
            color: var(--mickey-white);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            border: 3px solid var(--mickey-black);
        }

        .close-module:hover {
            transform: rotate(90deg);
        }

        .content-body {
            min-height: 400px;
        }

        /* ------------------------------------------------------------
           GAME/ACTIVITY STYLES
           ------------------------------------------------------------ */
        .game-container {
            background: var(--mickey-yellow);
            padding: 25px;
            border-radius: 20px;
            border: 4px solid var(--mickey-black);
            margin-bottom: 30px;
        }

        .game-question {
            font-size: 1.4rem;
            color: var(--mickey-black);
            margin-bottom: 20px;
            font-family: 'Fredoka One', cursive;
        }

        .game-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .game-option {
            padding: 15px;
            background: var(--mickey-white);
            border: 3px solid var(--mickey-black);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Comic Neue', cursive;
            font-weight: 700;
            text-align: center;
        }

        .game-option:hover {
            transform: translateY(-5px);
            background: var(--mickey-red);
            color: var(--mickey-white);
        }

        .game-option.correct {
            background: var(--mickey-green);
            color: white;
            border-color: var(--mickey-green);
        }

        .game-option.wrong {
            background: var(--mickey-red);
            color: white;
            border-color: var(--mickey-red);
        }

        .game-feedback {
            padding: 15px;
            background: var(--mickey-blue);
            color: var(--mickey-white);
            border-radius: 15px;
            display: none;
            margin-bottom: 20px;
            border: 3px solid var(--mickey-black);
        }

        .game-feedback.show {
            display: block;
            animation: bounceIn 0.5s;
        }

        .game-progress {
            background: var(--mickey-white);
            padding: 20px;
            border-radius: 15px;
            border: 4px solid var(--mickey-black);
            margin-top: 30px;
        }

        .progress-bar {
            height: 30px;
            background: linear-gradient(90deg, var(--mickey-yellow), var(--mickey-pink));
            border-radius: 15px;
            width: 0%;
            transition: width 0.5s ease;
            border: 3px solid var(--mickey-black);
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-family: 'Comic Neue', cursive;
            font-weight: 700;
            color: var(--mickey-blue);
        }

        /* GAME NAVIGATION */
        .game-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 3px dashed var(--mickey-red);
        }

        .game-counter {
            font-family: 'Fredoka One', cursive;
            color: var(--mickey-red);
            font-size: 1.2rem;
            background: var(--mickey-white);
            padding: 10px 20px;
            border-radius: 20px;
            border: 3px solid var(--mickey-black);
        }

        .nav-btn {
            padding: 12px 25px;
            background: var(--mickey-blue);
            color: var(--mickey-white);
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            border: 3px solid var(--mickey-black);
        }

        .nav-btn:hover {
            background: var(--mickey-red);
            transform: scale(1.05);
        }

        .nav-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        /* ------------------------------------------------------------
           SIDE CONTROLS & BUBBLES SYSTEM
           ------------------------------------------------------------ */
        .side-collapsible {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 9997;
        }

        .side-toggle {
            width: 60px;
            height: 60px;
            background: var(--mickey-red);
            border-radius: 50%;
            border: 4px solid var(--mickey-black);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 107, 139, 0.4);
            transition: all 0.3s;
            animation: pulse 2s infinite;
        }

        .side-toggle:hover {
            transform: scale(1.1);
        }

        .side-toggle i {
            color: var(--mickey-white);
            font-size: 1.5rem;
        }

        /* Enhanced Side Toggle System */
        .side-bubbles {
            position: absolute;
            bottom: 70px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 15px;
            animation: slideUp 0.3s ease;
            z-index: 9998;
        }
        
        .side-bubbles.show {
            display: flex;
        }
        
        .side-bubble {
            width: 60px;
            height: 60px;
            background: var(--mickey-yellow);
            border-radius: 50%;
            border: 4px solid var(--mickey-black);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
            position: relative;
        }
        
        .side-bubble:hover {
            transform: scale(1.1) rotate(10deg);
            background: var(--mickey-white);
        }
        
        .side-bubble i {
            color: var(--mickey-red);
            font-size: 1.5rem;
        }
        
        /* Bubble variants */
        .side-bubble.emotion-camera {
            background: var(--mickey-pink);
        }
        
        .side-bubble.emotion-camera i {
            color: var(--mickey-white);
        }
        
        .side-bubble.eye-camera {
            background: var(--mickey-blue);
        }
        
        .side-bubble.eye-camera i {
            color: var(--mickey-white);
        }
        
        .side-bubble.speaking-bot {
            background: var(--mickey-pink);
            animation: pulse 2s infinite;
        }

        .side-bubble.speaking-bot i {
            color: var(--mickey-white);
        }
        
        .side-bubble.active {
            background: var(--mickey-green);
            transform: scale(1.1);
            box-shadow: 0 0 20px var(--mickey-green);
            animation: pulse 2s infinite;
        }
        
        .side-bubble.active i {
            color: var(--mickey-white);
        }

        /* Speaking bot message indicator */
        .bot-message-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: var(--mickey-red);
            border-radius: 50%;
            border: 2px solid var(--mickey-white);
            display: none;
            animation: bounce 1s infinite;
        }

        .side-bubble.speaking-bot.has-message .bot-message-indicator {
            display: block;
        }

        /* Camera status indicators */
        .camera-status-dot {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid var(--mickey-white);
            display: none;
        }
        
        .camera-status-dot.active {
            background: var(--mickey-green);
            box-shadow: 0 0 10px var(--mickey-green);
            display: block;
            animation: pulse-green 2s infinite;
        }
        
        .camera-status-dot.inactive {
            background: var(--mickey-red);
            display: block;
        }

        /* Camera status indicators in header */
        .camera-status-indicators {
            position: fixed;
            bottom: 30px;
            right: 100px;
            display: flex;
            gap: 10px;
            z-index: 9995;
        }
        
        .camera-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--mickey-black);
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            display: none;
        }
        
        .emotion-indicator {
            background: var(--mickey-pink);
        }
        
        .eye-indicator {
            background: var(--mickey-blue);
        }
        
        .indicator-active {
            display: block;
            animation: pulse-indicator 2s infinite;
        }

        /* ------------------------------------------------------------
           DUAL CAMERA DETECTION INTERFACE
           ------------------------------------------------------------ */
        .collapsible-controls {
            position: fixed;
            top: 120px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 9999;
        }

        .collapsible-content {
            display: none;
            position: absolute;
            top: 60px;
            right: 0;
            background: var(--mickey-white);
            border-radius: 20px;
            border: 4px solid var(--mickey-black);
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            z-index: 9997;
            width: 300px;
        }

        .collapsible-content.active {
            display: block;
            animation: slideInRight 0.3s ease;
        }

        .collapsible-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: var(--mickey-red);
            color: var(--mickey-white);
            border: 3px solid var(--mickey-black);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            z-index: 9998;
            transition: all 0.3s;
        }

        .collapsible-close-btn:hover {
            background: var(--mickey-blue);
            transform: rotate(90deg) scale(1.1);
        }

        /* Enhanced detection interface */
        .dual-screen-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }
        
        .detection-screen {
            background: var(--mickey-white);
            border-radius: 15px;
            border: 4px solid var(--mickey-black);
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .screen-title {
            color: var(--mickey-red);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .screen-status {
            background: var(--mickey-yellow);
            padding: 5px 10px;
            border-radius: 15px;
            border: 2px solid var(--mickey-black);
            font-size: 0.8rem;
            color: var(--mickey-black);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .screen-status.active {
            background: var(--mickey-green);
            color: white;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 180px;
            background: black;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .detection-video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }
        
        .detection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .eye-canvas {
            width: 100%;
            height: 180px;
            background: #0a0a1a;
            border-radius: 10px;
            display: block;
        }
        
        .detection-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .stat-item {
            background: var(--mickey-yellow);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid var(--mickey-black);
            text-align: center;
        }
        
        .stat-value {
            font-size: 1rem;
            font-weight: bold;
            color: var(--mickey-red);
            line-height: 1.2;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: var(--mickey-black);
        }

        /* Focus and emotion indicators */
        .focus-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }
        
        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        
        .status-focusing {
            background: #4CAF50;
            box-shadow: 0 0 5px #4CAF50;
        }
        
        .status-distracted {
            background: #f44336;
            box-shadow: 0 0 5px #f44336;
        }
        
        .status-unknown {
            background: #FFA500;
            box-shadow: 0 0 5px #FFA500;
        }
        
        .iris-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 6px;
            border-radius: 6px;
            color: white;
            font-size: 9px;
            z-index: 10;
            line-height: 1.2;
        }
        
        .emotion-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 6px;
            border-radius: 6px;
            color: white;
            font-size: 9px;
            z-index: 10;
            line-height: 1.2;
        }

        /* Combined controls */
        .combined-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-btn {
            padding: 10px 15px;
            border: 3px solid var(--mickey-black);
            border-radius: 10px;
            font-family: 'Fredoka One', cursive;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .start-all-btn {
            background: var(--mickey-green);
            color: white;
        }
        
        .stop-all-btn {
            background: var(--mickey-red);
            color: white;
        }
        
        .separate-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .separate-btn {
            padding: 8px 12px;
            border: 2px solid var(--mickey-black);
            border-radius: 8px;
            font-family: 'Fredoka One', cursive;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.3s;
            font-size: 0.8rem;
        }
        
        .start-emotion-btn {
            background: var(--mickey-pink);
            color: white;
        }
        
        .stop-emotion-btn {
            background: var(--mickey-pink);
            color: white;
            opacity: 0.7;
        }
        
        .start-eye-btn {
            background: var(--mickey-blue);
            color: white;
        }
        
        .stop-eye-btn {
            background: var(--mickey-blue);
            color: white;
            opacity: 0.7;
        }
        
        .btn-active {
            opacity: 1 !important;
            transform: scale(1.05);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        }
        
        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Detection status panel */
        .detection-status-panel {
            margin-top: 15px;
            padding: 15px;
            background: var(--mickey-yellow);
            border-radius: 10px;
            border: 3px solid var(--mickey-black);
        }
        
        .status-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .status-icon {
            font-size: 1.5rem;
            color: var(--mickey-red);
        }
        
        .status-title {
            color: var(--mickey-black);
            font-weight: bold;
            font-size: 1rem;
        }
        
        .status-message {
            color: var(--mickey-black);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* ------------------------------------------------------------
           TRACING GAME STYLES
           ------------------------------------------------------------ */
        .tracing-game-container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--mickey-white);
            border-radius: 25px;
            border: 5px solid var(--mickey-black);
            padding: 30px;
            box-shadow: 0 10px 0 var(--mickey-black);
        }
        
        .tracing-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .tracing-instructions {
            background: var(--mickey-yellow);
            padding: 15px;
            border-radius: 15px;
            border: 3px solid var(--mickey-black);
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-family: 'Comic Neue', cursive;
            margin-top: 10px;
        }
        
        .tracing-area {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
        }
        
        .letter-display {
            background: var(--mickey-pink);
            border-radius: 20px;
            border: 4px solid var(--mickey-black);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .target-letter {
            font-size: 10rem;
            color: var(--mickey-white);
            text-shadow: 5px 5px 0 var(--mickey-black);
            font-family: 'Fredoka One', cursive;
            margin-bottom: 20px;
        }
        
        .letter-sound {
            width: 100%;
        }
        
        .canvas-container {
            position: relative;
            background: var(--mickey-white);
            border-radius: 20px;
            border: 4px solid var(--mickey-black);
            overflow: hidden;
            height: 400px;
        }
        
        #tracing-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
        }
        
        .tracing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .start-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            background: var(--mickey-green);
            border-radius: 50%;
            border: 3px solid var(--mickey-white);
            box-shadow: 0 0 10px var(--mickey-green);
            transform: translate(-50%, -50%);
            animation: pulse 1.5s infinite;
        }
        
        .trace-guide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle at center, transparent 0%, transparent 100%);
            pointer-events: none;
        }
        
        .tracing-controls {
            grid-column: 1 / -1;
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .tracing-btn {
            padding: 12px 20px;
            border: 3px solid var(--mickey-black);
            border-radius: 15px;
            font-family: 'Fredoka One', cursive;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s;
            background: var(--mickey-yellow);
            color: var(--mickey-black);
        }
        
        .tracing-btn:hover {
            transform: translateY(-3px);
        }
        
        .tracing-btn.success {
            background: var(--mickey-green);
            color: white;
        }
        
        .tracing-btn.hint {
            background: var(--mickey-blue);
            color: white;
        }
        
        .tracing-btn.demo {
            background: var(--mickey-pink);
            color: white;
        }
        
        .tracing-feedback {
            grid-column: 1 / -1;
            background: var(--mickey-white);
            padding: 15px;
            border-radius: 15px;
            border: 3px solid var(--mickey-black);
            margin-top: 20px;
            display: none;
            font-family: 'Comic Neue', cursive;
        }
        
        .tracing-feedback.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        .tracing-feedback.success {
            background: var(--mickey-green);
            color: white;
            border-color: var(--mickey-green);
        }
        
        .tracing-feedback.needs-improvement {
            background: var(--mickey-yellow);
            color: var(--mickey-black);
        }
        
        .tracing-progress {
            grid-column: 1 / -1;
            margin-top: 20px;
        }
        
        .tracing-progress-bar {
            height: 25px;
            background: var(--mickey-white);
            border-radius: 15px;
            border: 3px solid var(--mickey-black);
            overflow: hidden;
        }
        
        .tracing-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mickey-yellow), var(--mickey-pink));
            width: 0%;
            transition: width 0.5s ease;
        }

        /* ------------------------------------------------------------
           WELCOME SCREEN STYLES
           ------------------------------------------------------------ */
        body.welcome-active {
            overflow: hidden;
            padding: 0 !important;
            background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), 
                        url('images/the road in mickey mouse wallpaper.jpg') center/cover no-repeat !important;
        }

        body.welcome-active .fixed-header,
        body.welcome-active .content-area,
        body.welcome-active .side-collapsible,
        body.welcome-active .camera-status-indicators,
        body.welcome-active .collapsible-controls,
        body.welcome-active .polka-dot,
        body.welcome-active .mickey-dot {
            display: none !important;
        }

        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), 
                    url('images/the road in mickey mouse wallpaper.jpg') center/cover no-repeat;
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.5s ease;
        }

        .welcome-content {
            background: rgba(255, 249, 240, 0.95);
            border-radius: 30px;
            border: 8px solid var(--mickey-black);
            box-shadow: 0 15px 0 var(--mickey-black), 0 30px 50px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            animation: bounceIn 0.8s ease;
            display: flex;
            flex-direction: column;
        }

        .welcome-header {
            padding: 30px 20px;
            text-align: center;
            position: relative;
            flex-shrink: 0;
        }

        .mickey-welcome-logo {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 20px;
        }

        .mickey-welcome-logo img {
            height: 150px;
            margin-bottom: 20px;
            object-fit: cover;
        }

        .welcome-body {
            text-align: center;
            flex: 1;
            overflow-y: auto;
            max-height: calc(90vh - 200px);
            padding: 0 20px 20px 20px;
        }

        .welcome-message {
            margin-bottom: 20px;
        }

        .welcome-message p {
            color: #25221a;
            font-size: 1.4rem;
            font-family: 'Comic Neue', cursive;
            margin: 15px 0;
        }

        .welcome-features {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .feature {
            background: var(--mickey-yellow);
            padding: 12px 20px;
            border-radius: 15px;
            border: 3px solid var(--mickey-black);
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'Fredoka One', cursive;
            color: var(--mickey-black);
            font-size: 1rem;
        }

        .feature i {
            color: var(--mickey-red);
            font-size: 1.3rem;
        }

        /* Forms Container */
        .forms-container {
            margin-top: 20px;
            padding-right: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .form-container {
            background: var(--mickey-white);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid var(--mickey-black);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin: 20px 0;
            display: none;
        }

        .form-title {
            color: var(--mickey-red);
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Fredoka One', cursive;
        }

        /* Form Fields */
        .form-field {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            color: var(--mickey-black);
            font-family: 'Fredoka One', cursive;
        }

        .form-input {
            width: 95%;
            padding: 12px 15px;
            border-radius: 10px;
            border: 3px solid var(--mickey-black);
            font-family: 'Comic Neue', cursive;
            font-size: 1rem;
            background: var(--mickey-white);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--mickey-red);
            box-shadow: 0 0 10px rgba(255, 107, 139, 0.3);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }

        .form-select {
            width: 100%;
            padding: 12px 15px;
            border-radius: 10px;
            border: 3px solid var(--mickey-black);
            font-family: 'Comic Neue', cursive;
            font-size: 1rem;
            background: var(--mickey-white);
            cursor: pointer;
        }

        /* Remember Me Checkbox */
        .remember-me {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .remember-me input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .remember-me label {
            color: var(--mickey-black);
            font-family: 'Comic Neue', cursive;
            cursor: pointer;
        }

        /* Form Buttons */
        .form-submit-btn {
            width: 100%;
            margin-bottom: 15px;
        }

        /* Password Hint */
        .password-hint {
            margin-top: 5px;
            font-size: 0.8rem;
            color: var(--mickey-blue);
            font-family: 'Comic Neue', cursive;
        }

        /* Demo Credentials */
        .demo-title {
            padding: 2px;
            color: var(--mickey-black);
            font-size: 0.9rem;
            margin: 0 0 10px 0;
        }

        .credentials-list {
            margin: 8px 0;
        }

        .credential-item {
            align-items: center;
            gap: 5px;
            margin-bottom: 6px;
        }

        .credential-item:last-child {
            margin-bottom: 0;
            margin-top: 6px;
        }

        .credential-icon {
            font-size: 0.8rem;
        }

        .student-cred .credential-icon {
            color: var(--mickey-blue);
        }

        .teacher-cred .credential-icon {
            color: var(--mickey-red);
        }

        .credential-label {
            font-weight: bold;
            color: var(--mickey-black);
        }

        .credential-username,
        .credential-password {
            background: var(--mickey-white);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--mickey-black);
            font-family: monospace;
            color: var(--mickey-red);
        }

        .credential-separator {
            margin: 0 5px;
            color: var(--mickey-black);
        }

        /* Form Footer */
        .form-footer {
            text-align: center;
            margin-top: 15px;
        }

        .form-footer p {
            color: var(--mickey-blue);
            font-family: 'Comic Neue', cursive;
            margin: 0;
        }

        .form-link {
            color: var(--mickey-red);
            text-decoration: underline;
            cursor: pointer;
            font-weight: bold;
        }

        .form-link:hover {
            color: var(--mickey-pink);
        }

        /* Welcome Actions */
        .welcome-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .start-learning-btn, .explore-btn {
            padding: 15px 30px;
            border: 4px solid var(--mickey-black);
            border-radius: 20px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .start-learning-btn {
            background: var(--mickey-red);
            color: var(--mickey-white);
        }

        .explore-btn {
            background: var(--mickey-blue);
            color: var(--mickey-white);
        }

        .start-learning-btn:hover, .explore-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 0 var(--mickey-black);
        }

        .start-learning-btn:hover {
            background: var(--mickey-pink);
        }

        .explore-btn:hover {
            background: #6aa8b5;
        }

        /* ------------------------------------------------------------
           INDEPENDENT SPEAKING BOT SYSTEM
           ------------------------------------------------------------ */
        .speaking-bot-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            z-index: 10005;
            animation: fadeIn 0.3s ease;
        }

        .speaking-bot-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            animation: slideUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Bot speaker avatar */
        .bot-speaker-avatar {
            position: relative;
            width: 180px;
            height: 180px;
        }

        .bot-speaker-circle {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 2;
            transition: all 0.3s;
            background: transparent !important;
            box-shadow: none !important;
        }

        .speaking .bot-speaker-circle {
            animation: speakingPulse 1.5s infinite alternate;
        }

        .bot-speaker-img {
            width: 295%;
            height: 100%;
            object-fit: cover;
            transform: translate(0px, 450px);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        /* Speaker waves */
        .speaker-waves {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 40%);
            width: 600px;
            height: 600px;
            display: none;
        }

        .speaking .speaker-waves {
            display: block;
        }

        .speaker-wave {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid rgba(149, 225, 211, 0.3);
            animation: waveExpand 1.5s infinite linear;
        }

        .speaker-wave:nth-child(1) {
            animation-delay: 0s;
        }

        .speaker-wave:nth-child(2) {
            animation-delay: 0.5s;
        }

        .speaker-wave:nth-child(3) {
            animation-delay: 1s;
        }

        /* Bot speaker status */
        .bot-speaker-status {
            text-align: center;
            color: white;
            width: 100%;
        }

        .status-text {
            font-size: 1.3rem;
            margin-bottom: 15px;
            font-family: 'Comic Neue', cursive;
            color: #95e1d3;
            min-height: 30px;
            transition: all 0.3s;
        }

        .speaking .status-text {
            animation: textGlow 1s infinite alternate;
        }

        /* VOICE WAVE VISUALIZATION */
        .voice-wave-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 30px;
            margin-top: 15px;
            width: 100%;
        }

        .voice-wave-bar {
            width: 6px;
            height: 10px;
            background: linear-gradient(to top, #ff6b8b, #ffd166);
            border-radius: 3px;
            transition: all 0.3s ease;
            animation: wavePulse 1.5s infinite ease-in-out;
        }

        .voice-wave-bar:nth-child(1) { animation-delay: 0s; }
        .voice-wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .voice-wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .voice-wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .voice-wave-bar:nth-child(5) { animation-delay: 0.4s; }

        /* Speaking state adjustments */
        .speaking .voice-wave-bar {
            animation-play-state: running;
        }

        /* Non-speaking state */
        :not(.speaking) .voice-wave-bar {
            animation-play-state: paused;
            height: 8px;
            opacity: 0.3;
        }

        /* Continue button */
        .bot-speaker-continue {
            padding: 12px 25px;
            background: rgba(255, 107, 139, 0.8);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            font-family: 'Fredoka One', cursive;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
            transform: translate(350px, 100px);
        }

        .bot-speaker-continue.show {
            opacity: 1;
            pointer-events: all;
        }

        .bot-speaker-continue:hover {
            background: rgba(255, 107, 139, 1);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 107, 139, 0.4);
        }

        /* Eye tracking video styling */
        #eye-display-video {
            width: 100% !important;
            height: 100% !important;
            object-fit: cover !important;
            transform: scaleX(-1) !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            z-index: 1 !important;
            background: black !important;
        }

        #eye-tracking-canvas {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 2 !important;
            pointer-events: none !important;
        }

        /* Hide the processing-only video */
        #eye-video {
            display: none !important;
        }

        /* ------------------------------------------------------------
           DECORATIVE ELEMENTS
           ------------------------------------------------------------ */
        /* MICKEY DECORATIONS */
        .mickey-dot {
            position: fixed;
            width: 20px;
            height: 20px;
            background: var(--mickey-red);
            border-radius: 50%;
            border: 3px solid var(--mickey-black);
            z-index: -1;
            animation: float 20s infinite linear;
        }

        .polka-dot {
            position: fixed;
            width: 40px;
            height: 40px;
            background: var(--mickey-yellow);
            border-radius: 50%;
            border: 4px solid var(--mickey-white);
            z-index: -1;
            opacity: 0.3;
        }

        /* ------------------------------------------------------------
           ANIMATIONS
           ------------------------------------------------------------ */
        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-100vh) rotate(360deg); }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideUp {
            0% { 
                transform: translate(-50%, -40%); 
                opacity: 0; 
            }
            100% { 
                transform: translate(-50%, -50%); 
                opacity: 1; 
            }
        }

        @keyframes speakingPulse {
            0% { 
                transform: scale(1);
                box-shadow: 
                    0 0 30px rgba(255, 107, 139, 0.7),
                    0 0 60px rgba(255, 107, 139, 0.4);
            }
            100% { 
                transform: scale(1.05);
                box-shadow: 
                    0 0 40px rgba(255, 107, 139, 0.9),
                    0 0 80px rgba(255, 107, 139, 0.6);
            }
        }

        @keyframes waveExpand {
            0% {
                transform: scale(0.8);
                opacity: 1;
                border-width: 2px;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
                border-width: 1px;
            }
        }

        @keyframes textGlow {
            0% { text-shadow: 0 0 5px rgba(149, 225, 211, 0.5); }
            100% { text-shadow: 0 0 10px rgba(149, 225, 211, 0.8); }
        }

        @keyframes wavePulse {
            0%, 100% { 
                height: 10px;
                opacity: 0.5;
                transform: scaleY(1);
            }
            50% { 
                height: 25px;
                opacity: 1;
                transform: scaleY(1.3);
            }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(149, 225, 211, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(149, 225, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(149, 225, 211, 0); }
        }

        @keyframes pulse-indicator {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 139, 0.7); }
            70% { box-shadow: 0 0 0 8px rgba(255, 107, 139, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 107, 139, 0); }
        }
        
        @keyframes pulse-indicator-blue {
            0% { box-shadow: 0 0 0 0 rgba(138, 198, 209, 0.7); }
            70% { box-shadow: 0 0 0 8px rgba(138, 198, 209, 0); }
            100% { box-shadow: 0 0 0 0 rgba(138, 198, 209, 0); }
        }

        /* ------------------------------------------------------------
           RESPONSIVE DESIGN
           ------------------------------------------------------------ */
        @media (max-width: 1200px) {
            .modules-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            body {
                padding-top: 160px;
            }
            
            .fixed-header {
                padding: 10px;
            }
            
            .header-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .header-nav {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-tab {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .side-collapsible {
                bottom: 20px;
                right: 20px;
            }
            
            .collapsible-controls {
                top: 160px;
                right: 20px;
            }
            
            .modules-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .game-options {
                grid-template-columns: 1fr;
            }
            
            .module-content-area {
                margin: 20px 10px;
                padding: 20px;
            }
            
            .tracing-area {
                grid-template-columns: 1fr;
            }
            
            .tracing-controls {
                flex-wrap: wrap;
            }
            
            .tracing-btn {
                min-width: calc(50% - 10px);
            }
            
            .welcome-content {
                width: 95%;
                margin: 20px;
                max-height: 95vh;
            }
            
            .welcome-header {
                padding: 20px 10px;
            }
            
            .welcome-header h1 {
                font-size: 1.8rem;
            }
            
            .welcome-message p {
                font-size: 1.1rem;
            }
            
            .welcome-features {
                flex-direction: column;
                gap: 15px;
            }
            
            .welcome-actions {
                flex-direction: column;
            }
            
            .welcome-body {
                padding: 20px;
                max-height: calc(95vh - 150px);
            }
            
            .forms-container {
                max-height: 300px;
            }
            
            .start-learning-btn, .explore-btn {
                padding: 12px 20px;
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <!-- ============================================
         HTML STRUCTURE
         Organized by component hierarchy
         ============================================ -->
    
    <!-- SPEAKING BOT OVERLAY (Full Screen) -->
    <div class="speaking-bot-overlay" id="speaking-bot-overlay">
        <div class="speaking-bot-container" id="speaking-bot-container">
            <!-- Bot speaker avatar -->
            <div class="bot-speaker-avatar">
                <div class="bot-speaker-circle" id="bot-speaker-circle">
                    <img src="images/toodles.png" alt="Speaking Bot" class="bot-speaker-img">
                </div>
                <!-- Speaker waves animation -->
                <div class="speaker-waves" id="speaker-waves">
                    <div class="speaker-wave"></div>
                    <div class="speaker-wave"></div>
                    <div class="speaker-wave"></div>
                </div>
            </div>
            
            <!-- Bot status -->
            <div class="bot-speaker-status" id="bot-speaker-status">
                <div class="status-text" id="bot-speaker-status-text">Ready to help!</div>
                <!-- Voice wave visualization -->
                <div class="voice-wave-container" id="voice-wave-container">
                    <div class="voice-wave-bar"></div>
                    <div class="voice-wave-bar"></div>
                    <div class="voice-wave-bar"></div>
                    <div class="voice-wave-bar"></div>
                    <div class="voice-wave-bar"></div>
                </div>
            </div>
            
            <!-- Continue button -->
            <button class="bot-speaker-continue" id="bot-speaker-continue">
                <i class="fas fa-check"></i> Continue
            </button>
        </div>
    </div>

    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcome-screen">
        <div class="welcome-content">
            <div class="welcome-header">
                <div class="mickey-welcome-logo">
                    <img src="images/Mickey_Mouse_Clubhouse_logo.png" alt="Mickey Mouse Clubhouse" class="user-photo-img">
                    <h1>Welcome to Mickey's Learning Hub!</h1>
                </div>
            </div>
            <div class="welcome-body">
                
                <!-- FORMS CONTAINER -->
                <div class="forms-container" id="forms-container">
                    <!-- BUTTONS ONLY - NO FORMS INITIALLY -->
                    <div class="welcome-actions" id="welcome-buttons">
                        <button class="start-learning-btn" id="show-login-btn">
                            <i class="fas fa-sign-in-alt"></i> Login Now
                        </button>
                        <button class="explore-btn" id="show-register-btn">
                            <i class="fas fa-user-plus"></i> Register Now
                        </button>
                    </div>
                    
                    <!-- LOGIN FORM (HIDDEN BY DEFAULT) -->
                    <div id="login-form-container" class="form-container">
                        <h3 class="form-title">
                            <i class="fas fa-sign-in-alt"></i> Login
                        </h3>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-user"></i> Username
                            </label>
                            <input type="text" id="login-username" 
                                placeholder="Enter your username" 
                                class="form-input">
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-key"></i> Password
                            </label>
                            <input type="password" id="login-password" 
                                placeholder="Enter your password" 
                                class="form-input">
                        </div>
                        
                        <div class="remember-me">
                            <input type="checkbox" id="remember-me">
                            <label for="remember-me">Remember me</label>
                        </div>
                        
                        <button class="start-learning-btn form-submit-btn" onclick="submitLogin()">
                            <i class="fas fa-sign-in-alt"></i> Login Now
                        </button>
                        
                        <!-- Demo credentials -->
                        <div class="demo-credentials">
                            <p class="demo-title">
                                <strong><i class="fas fa-lightbulb"></i> Demo Credentials:</strong>
                            </p>
                            <div class="credentials-list">
                                <div class="credential-item student-cred">
                                    <i class="fas fa-user-graduate credential-icon"></i>
                                    <span class="credential-label">Student:</span>
                                    <code class="credential-username">student123</code>
                                    <span class="credential-separator">/</span>
                                    <code class="credential-password">student123</code>
                                </div>
                                <div class="credential-item teacher-cred">
                                    <i class="fas fa-chalkboard-teacher credential-icon"></i>
                                    <span class="credential-label">Teacher:</span>
                                    <code class="credential-username">teacher123</code>
                                    <span class="credential-separator">/</span>
                                    <code class="credential-password">teacher123</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-footer">
                            <p>
                                Don't have an account? 
                                <a href="#" onclick="showRegisterForm()" class="form-link">
                                    Register here
                                </a>
                            </p>
                        </div>
                    </div>
                    
                    <!-- REGISTER FORM (HIDDEN BY DEFAULT) -->
                    <div id="register-form-container" class="form-container">
                        <h3 class="form-title">
                            <i class="fas fa-user-plus"></i> Register
                        </h3>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-user"></i> Full Name
                            </label>
                            <input type="text" id="register-name" 
                                placeholder="Enter your full name" 
                                class="form-input">
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-at"></i> Username
                            </label>
                            <input type="text" id="register-username" 
                                placeholder="Choose a username" 
                                class="form-input">
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-key"></i> Password
                            </label>
                            <input type="password" id="register-password" 
                                placeholder="Create a password" 
                                class="form-input">
                            <div class="password-hint">
                                <i class="fas fa-info-circle"></i> Must be at least 6 characters
                            </div>
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-user-tag"></i> I am a...
                            </label>
                            <select id="register-role" class="form-select">
                                <option value="student">Student</option>
                                <option value="teacher">Teacher</option>
                                <option value="parent">Parent</option>
                            </select>
                        </div>
                        
                        <button class="explore-btn form-submit-btn" onclick="submitRegistration()">
                            <i class="fas fa-check"></i> Create Account
                        </button>
                        
                        <div class="form-footer">
                            <p>
                                Already have an account? 
                                <a href="#" onclick="showLoginForm()" class="form-link">
                                    Login here
                                </a>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- FIXED HEADER -->
    <header class="fixed-header">
        <div class="header-container">
            <div class="header-logo">
                <div class="logo-icon">
                    <i class="fas fa-graduation-cap"></i>
                </div>
                <span>Mickey's Learning Hub</span>
            </div>
            
            <nav class="header-nav">
                <a href="#" class="nav-tab active" id="game-tab">
                    <i class="fas fa-gamepad"></i> Game Center
                </a>
                <a href="#" class="nav-tab" id="profile-tab">
                    <i class="fas fa-user"></i> Profile
                </a>
                <a href="#" class="nav-tab" id="about-tab">
                    <i class="fas fa-info-circle"></i> About Us
                </a>
                <a href="#" class="nav-tab" id="settings-tab">
                    <i class="fas fa-cog"></i> Settings
                </a>
            </nav>
        </div>
    </header>
    
    <!-- SIDE BUBBLES -->
    <div class="side-collapsible" id="side-collapsible">
        <div class="side-toggle" id="side-toggle">
            <i class="fas fa-plus"></i>
        </div>
        <div class="side-bubbles" id="side-bubbles">
            <!-- Emotion Camera Bubble -->
            <div class="side-bubble emotion-camera" id="side-emotion-camera" title="Emotion Detection">
                <i class="fas fa-smile"></i>
                <div class="camera-status-dot" id="emotion-status-dot"></div>
            </div>
            
            <!-- Eye Tracking Camera Bubble -->
            <div class="side-bubble eye-camera" id="side-eye-camera" title="Eye Tracking">
                <i class="fas fa-eye"></i>
                <div class="camera-status-dot" id="eye-status-dot"></div>
            </div>
            
            <!-- Speaking Bot Bubble -->
            <div class="side-bubble speaking-bot" id="side-speaking-bot" title="Click to talk">
                <i class="fas fa-microphone"></i>
                <div class="bot-message-indicator" id="bot-message-indicator"></div>
            </div>
        </div>
    </div>

    <!-- Camera Status Indicators -->
    <div class="camera-status-indicators" id="camera-status-indicators">
        <div class="camera-indicator emotion-indicator" id="emotion-indicator" title="Emotion Detection Active"></div>
        <div class="camera-indicator eye-indicator" id="eye-indicator" title="Eye Tracking Active"></div>
    </div>

    <!-- CAMERA COLLAPSIBLE CONTENT -->
    <div class="collapsible-controls" id="collapsible-controls">
        <div class="collapsible-content" id="camera-content">
            <button class="collapsible-close-btn" id="close-camera-content" title="Close camera panel">
                <i class="fas fa-times"></i>
            </button>
            <div class="camera-container">
                <!-- Dual Detection Screens -->
                <div class="dual-screen-container">
                    <!-- Emotion Detection Screen -->
                    <div class="detection-screen" id="emotion-screen">
                        <div class="screen-header">
                            <div class="screen-title">
                                <i class="fas fa-smile"></i> Emotion Detection
                            </div>
                            <div class="screen-status" id="emotion-status">
                                <i class="fas fa-circle"></i> INACTIVE
                            </div>
                        </div>
                        
                        <div class="video-container">
                            <video id="emotion-video" class="detection-video" playsinline muted></video>
                            <canvas id="emotion-overlay" class="detection-overlay"></canvas>
                            <div class="emotion-info" id="emotion-info">
                                Emotion: -
                            </div>
                        </div>
                        
                        <div class="detection-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="face-count">0</div>
                                <div class="stat-label">Faces</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="emotion-fps">0</div>
                                <div class="stat-label">FPS</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="dominant-emotion">-</div>
                                <div class="stat-label">Emotion</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="emotion-confidence">0%</div>
                                <div class="stat-label">Confidence</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Eye Tracking Screen -->
                    <div class="detection-screen" id="eye-screen">
                        <div class="screen-header">
                            <div class="screen-title">
                                <i class="fas fa-eye"></i> Eye Tracking
                            </div>
                            <div class="screen-status" id="eye-status">
                                <i class="fas fa-circle"></i> INACTIVE
                            </div>
                        </div>
                        
                        <div class="video-container">
                            <canvas id="eye-tracking-canvas" class="eye-canvas"></canvas>
                            <div class="focus-status" id="focus-status">
                                <div class="status-dot status-unknown"></div>
                                <span>Focus: -</span>
                            </div>
                            <div class="iris-info" id="iris-info">
                                Iris: Waiting...
                            </div>
                        </div>
                        
                        <div class="detection-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="iris-confidence">0%</div>
                                <div class="stat-label">Iris Conf</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="focus-direction">-</div>
                                <div class="stat-label">Direction</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="focus-score">0%</div>
                                <div class="stat-label">Focus</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="alignment-score">0%</div>
                                <div class="stat-label">Alignment</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Combined Controls -->
                <div class="combined-controls">
                    <button class="control-btn start-all-btn" id="start-all-detection">
                        <i class="fas fa-play-circle"></i> Start Both
                    </button>
                    <button class="control-btn stop-all-btn" id="stop-all-detection" disabled>
                        <i class="fas fa-stop-circle"></i> Stop Both
                    </button>
                </div>
                
                <!-- Separate Controls -->
                <div class="separate-controls">
                    <button class="separate-btn start-emotion-btn" id="start-emotion-detection">
                        <i class="fas fa-smile"></i> Emotion Only
                    </button>
                    <button class="separate-btn start-eye-btn" id="start-eye-detection">
                        <i class="fas fa-eye"></i> Eye Only
                    </button>
                </div>
                
                <!-- Detection Status Panel -->
                <div class="detection-status-panel" id="detection-status">
                    <div class="status-header">
                        <div class="status-icon">
                            <i class="fas fa-magic"></i>
                        </div>
                        <div class="status-title">
                            ENHANCED EMOTION & EYE TRACKING
                        </div>
                    </div>
                    <div class="status-message">
                        Click "Start Both" to begin enhanced emotion detection and eye focus analysis!
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- GAME CENTER CONTENT AREA (DEFAULT ACTIVE) -->
    <div class="content-area active" id="game-center-content-area">
        <!-- LEARNING HUB -->
        <main class="learning-hub">
            <!-- MICKEY MOUSE DECORATIONS -->
            <div class="polka-dot" style="top: 10%; left: 5%;"></div>
            <div class="polka-dot" style="top: 20%; right: 10%;"></div>
            <div class="polka-dot" style="bottom: 30%; left: 15%;"></div>
            <div class="mickey-dot" style="top: 15%; right: 20%; animation-delay: -5s;"></div>
            <div class="mickey-dot" style="top: 40%; left: 8%; animation-delay: -10s;"></div>
            
            <!-- MICKEY MOUSE HEADER -->
            <div class="mickey-header">
                <h1>MICKEY'S EMPATHIC LEARNING HUB</h1>
            </div>
            
            <!-- LEARNING CONTENT GRID -->
            <div class="modules-grid">
                <!-- GAME 1: LETTER INTRODUCTION -->
                <div class="module-card" data-module="letters">
                    <div class="module-title">
                        <i class="fas fa-font"></i>
                        Letter Explorer
                    </div>
                    <div class="module-desc">
                        <strong>Multisensory Letter Learning:</strong> Introducing lowercase a-z letters with tactile feel. 
                        Learn to recognize letters by touch, color differentiation, and sound feedback when placed correctly. 
                        Special dyslexia-friendly font prevents mirror confusion.
                    </div>
                    <div class="module-controls">
                        <button class="module-btn start-btn" onclick="startGame('letters')">
                            <i class="fas fa-gamepad"></i> Play Letter Game
                        </button>
                        <button class="module-btn view-btn" onclick="viewModule('letters')">
                            <i class="fas fa-info-circle"></i> Learn More
                        </button>
                    </div>
                </div>
                
                <!-- GAME 2: VOWEL/CONSONANT DIFFERENTIATION -->
                <div class="module-card" data-module="vowels">
                    <div class="module-title">
                        <i class="fas fa-volume-up"></i>
                        Vowel & Consonant Fun
                    </div>
                    <div class="module-desc">
                        <strong>Letter Classification:</strong> Learn to differentiate vowels (a, e, i, o, u) from consonants. 
                        Tactile letter blocks with click sound feedback when correctly sorted.
                    </div>
                    <div class="module-controls">
                        <button class="module-btn start-btn" onclick="startGame('vowels')">
                            <i class="fas fa-gamepad"></i> Play Vowel Game
                        </button>
                        <button class="module-btn view-btn" onclick="viewModule('vowels')">
                            <i class="fas fa-info-circle"></i> Learn More
                        </button>
                    </div>
                </div>
                
                <!-- GAME 3: WORD SPELLING & READING -->
                <div class="module-card" data-module="spelling">
                    <div class="module-title">
                        <i class="fas fa-spell-check"></i>
                        Word Builder
                    </div>
                    <div class="module-desc">
                        <strong>Spelling & Reading:</strong> Spell English words using letter blocks on provided slots. 
                        Read words using phonics or syllable methods.
                    </div>
                    <div class="module-controls">
                        <button class="module-btn start-btn" onclick="startGame('spelling')">
                            <i class="fas fa-gamepad"></i> Play Spelling Game
                        </button>
                        <button class="module-btn view-btn" onclick="viewModule('spelling')">
                            <i class="fas fa-info-circle"></i> Learn More
                        </button>
                    </div>
                </div>
                
                <!-- NEW: TRACING MODULE -->
                <div class="module-card" data-module="tracing">
                    <div class="module-title">
                        <i class="fas fa-pen-nib"></i>
                        Letter Tracer
                    </div>
                    <div class="module-desc">
                        <strong>Kinesthetic Learning:</strong> Trace letters with mouse or finger to build muscle memory. 
                        Visual guides, audio feedback, and progressive difficulty levels.
                    </div>
                    <div class="module-controls">
                        <button class="module-btn start-btn" onclick="startGame('tracing')">
                            <i class="fas fa-pen-fancy"></i> Start Tracing
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- ENHANCED PROFILE CONTENT AREA -->
    <div class="content-area" id="profile-content-area">
        <div class="profile-content">
            <h2 style="color: var(--mickey-red); text-align: center; margin-bottom: 30px;">
                <i class="fas fa-user-graduate"></i> Student Profile & Analysis
            </h2>
            
            <div class="student-profile">
                <div class="profile-header">
                    <div class="avatar" style="width: 80px; height: 80px; background: var(--mickey-yellow); 
                                             border-radius: 50%; border: 4px solid var(--mickey-black);
                                             display: flex; align-items: center; justify-content: center;
                                             font-size: 2rem; color: var(--mickey-red);">
                        <i class="fas fa-user"></i>
                    </div>
                    <div>
                        <h3 style="margin: 0; color: var(--mickey-red);">Student Progress Dashboard</h3>
                        <p style="margin: 5px 0; color: var(--mickey-blue); font-family: 'Comic Neue', cursive;">
                            <i class="fas fa-star"></i> 
                            <span id="student-points">150</span> Mickey Points
                        </p>
                    </div>
                </div>
                
                <!-- PROGRESS OVERVIEW -->
                <div class="progress-overview" style="margin: 30px 0; background: var(--mickey-white); 
                                                     padding: 20px; border-radius: 15px; border: 4px solid var(--mickey-black);">
                    <h4 style="color: var(--mickey-blue); margin-bottom: 15px;">
                        <i class="fas fa-chart-line"></i> Overall Progress
                    </h4>
                    <div class="game-progress">
                        <div class="progress-bar" id="overall-progress" style="width: 40%"></div>
                        <div class="progress-text">40% Complete</div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
                                gap: 15px; margin-top: 20px;">
                        <div class="stat-card" style="background: var(--mickey-pink); padding: 15px; 
                                                    border-radius: 10px; border: 3px solid var(--mickey-black);">
                            <div style="font-size: 2rem; color: var(--mickey-red);">
                                <i class="fas fa-clock"></i>
                            </div>
                            <div style="font-weight: bold; color: var(--mickey-black);">Time Spent</div>
                            <div style="font-size: 1.5rem; color: var(--mickey-blue);">45 min</div>
                        </div>
                        
                        <div class="stat-card" style="background: var(--mickey-green); padding: 15px; 
                                                    border-radius: 10px; border: 3px solid var(--mickey-black);">
                            <div style="font-size: 2rem; color: var(--mickey-red);">
                                <i class="fas fa-trophy"></i>
                            </div>
                            <div style="font-weight: bold; color: var(--mickey-black);">Games Completed</div>
                            <div style="font-size: 1.5rem; color: var(--mickey-blue);" id="games-completed">2/4</div>
                        </div>
                        
                        <div class="stat-card" style="background: var(--mickey-purple); padding: 15px; 
                                                    border-radius: 10px; border: 3px solid var(--mickey-black);">
                            <div style="font-size: 2rem; color: var(--mickey-red);">
                                <i class="fas fa-bolt"></i>
                            </div>
                            <div style="font-weight: bold; color: var(--mickey-black);">Focus Level</div>
                            <div style="font-size: 1.5rem; color: var(--mickey-blue);" id="focus-level">75%</div>
                        </div>
                    </div>
                </div>
                
                <!-- Progress Dashboard -->
                <div id="progress-dashboard" style="margin-top: 30px;"></div>
            </div>
        </div>
    </div>
    
    <!-- ABOUT US CONTENT AREA -->
    <div class="content-area" id="about-content-area">
        <div class="about-content">
            <h2 style="color: var(--mickey-red); text-align: center; margin-bottom: 30px;">
                <i class="fas fa-info-circle"></i> About Mickey's Learning Hub
            </h2>
            
            <div style="text-align: center; max-width: 800px; margin: 0 auto;">
                <div style="font-size: 4rem; color: var(--mickey-red); margin-bottom: 20px;">
                    <i class="fas fa-heart"></i>
                </div>
                <h3 style="color: var(--mickey-blue); margin-bottom: 20px;">Our Mission</h3>
                <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.2rem; line-height: 1.6; margin-bottom: 30px;">
                    Welcome to Mickey's Enhanced Empathic Learning Hub! We're dedicated to creating a fun, engaging, and supportive learning environment for children of all abilities, with special focus on dyslexia support.
                </p>
            </div>
        </div>
    </div>
    
    <!-- SETTINGS CONTENT AREA -->
    <div class="content-area" id="settings-content-area">
        <div class="settings-content">
            <h2 style="color: var(--mickey-red); text-align: center; margin-bottom: 30px;">
                <i class="fas fa-cog"></i> Settings & Preferences
            </h2>
            
            <div style="max-width: 800px; margin: 0 auto;">
                <div style="background: var(--mickey-white); padding: 30px; border-radius: 20px; border: 4px solid var(--mickey-black); margin-bottom: 30px;">
                    <h3 style="color: var(--mickey-red); margin-bottom: 20px;">Accessibility Settings</h3>
                    
                    <div style="background: var(--mickey-yellow); padding: 20px; border-radius: 15px; border: 3px solid var(--mickey-black); margin-bottom: 20px;">
                        <h4 style="color: var(--mickey-black); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-book-reader"></i> Dyslexia Mode
                        </h4>
                        <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; margin-bottom: 15px;">
                            Toggle dyslexia-friendly font and spacing
                        </p>
                        <button class="module-btn" id="toggle-dyslexia" style="width: 100%;">
                            <i class="fas fa-toggle-on"></i> Toggle Dyslexia Mode
                        </button>
                    </div>
                    
                    <h3 style="color: var(--mickey-red); margin-bottom: 20px;">Face Detection Settings</h3>
                    <div style="background: var(--mickey-yellow); padding: 20px; border-radius: 15px; border: 3px solid var(--mickey-black);">
                        <h4 style="color: var(--mickey-black); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-camera"></i> ENHANCED Emotion & Eye Tracking
                        </h4>
                        <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; margin-bottom: 15px;">
                            Status: <span id="detection-status-text" style="color: var(--mickey-red); font-weight: bold;">INACTIVE</span>
                        </p>
                        <button class="module-btn start-btn" id="settings-start-camera" style="width: 100%;">
                            <i class="fas fa-camera"></i> Start Detection
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- MODULE CONTENT AREA -->
    <div class="module-content-area" id="module-content">
        <div class="content-header">
            <h2 id="module-content-title" style="color: var(--mickey-red); margin: 0;"></h2>
            <button class="close-module" id="close-module">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="content-body" id="module-content-body">
            <!-- Dynamic content will be loaded here -->
        </div>
    </div>

    <!-- TRACING GAME CONTAINER -->
    <div class="tracing-game-container" id="tracing-game-container" style="display: none;">
        <div class="tracing-header">
            <h3 style="color: var(--mickey-red);">Trace the Letter</h3>
            <div class="tracing-instructions">
                <i class="fas fa-hand-point-up"></i>
                Follow the dotted line with your mouse or finger
            </div>
        </div>
        
        <div class="tracing-area">
            <!-- Letter display -->
            <div class="letter-display">
                <div class="target-letter" id="target-letter">A</div>
                <div class="letter-sound">
                    <button id="play-sound-btn" class="tracing-btn">
                        <i class="fas fa-volume-up"></i> Listen to sound
                    </button>
                </div>
            </div>
            
            <!-- Tracing canvas -->
            <div class="canvas-container">
                <canvas id="tracing-canvas"></canvas>
                <div class="tracing-overlay">
                    <div class="start-dot"></div>
                    <div class="trace-guide"></div>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="tracing-controls">
                <button id="clear-trace" class="tracing-btn">
                    <i class="fas fa-eraser"></i> Clear
                </button>
                <button id="check-trace" class="tracing-btn success">
                    <i class="fas fa-check"></i> Check
                </button>
                <button id="hint-trace" class="tracing-btn hint">
                    <i class="fas fa-lightbulb"></i> Show Hint
                </button>
                <button id="auto-trace" class="tracing-btn demo">
                    <i class="fas fa-magic"></i> Show Me How
                </button>
            </div>
            
            <!-- Feedback -->
            <div class="tracing-feedback" id="tracing-feedback"></div>
            
            <!-- Progress -->
            <div class="tracing-progress">
                <div class="tracing-progress-bar">
                    <div class="tracing-progress-fill" id="trace-progress"></div>
                </div>
                <div class="progress-text">
                    Accuracy: <span id="trace-accuracy">0%</span>
                </div>
            </div>
            
            <!-- Navigation -->
            <div class="game-navigation" style="margin-top: 30px;">
                <button class="nav-btn" id="prev-tracing" onclick="prevTracingActivity()">
                    <i class="fas fa-arrow-left"></i> Previous
                </button>
                <div class="game-counter" id="tracing-counter">Activity 1 of 5</div>
                <button class="nav-btn" id="next-tracing" onclick="nextTracingActivity()">
                    Next <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- ============================================
         EXTERNAL LIBRARIES
         ============================================ -->
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/human.js"></script>

    <!-- ============================================
         JAVASCRIPT CODE
         Organized by functionality and component
         ============================================ -->
    <script>

        // ============================================
        // GLOBAL STATE MANAGEMENT
        // ============================================

        // Enhanced Learning Modules Data
        const learningGames = {
            letters: {
                title: "Letter Explorer Game",
                description: "Learn lowercase letters a-z with multisensory support!",
                activities: [
                    {
                        type: "letter_recognition",
                        question: "Touch and identify this letter:",
                        letter: "a",
                        options: ["a", "b", "c", "d"],
                        correct: 0,
                        explanation: "Great! This is lowercase 'a'. Feel its round shape!",
                        points: 10,
                        tactile_feature: "Round shape with a tail"
                    },
                    {
                        type: "letter_recognition",
                        question: "Which letter is different? (No mirror letters)",
                        letters: ["b", "d", "p", "a"],
                        options: ["b", "d", "p", "a"],
                        correct: 3,
                        explanation: "Correct! 'a' is not a mirror letter like b-d or p-q!",
                        points: 10,
                        tactile_feature: "Unique shape prevents confusion"
                    },
                    {
                        type: "letter_sequence",
                        question: "What comes after 'c'?",
                        sequence: ["a", "b", "c", "?"],
                        options: ["d", "e", "f", "g"],
                        correct: 0,
                        explanation: "Correct! c  d. Feel the different shapes!",
                        points: 10,
                        tactile_feature: "Different shapes for each letter"
                    }
                ],
                dyslexia_tips: [
                    "Touch and feel each letter shape",
                    "Use color coding for similar letters",
                    "Listen to the click sound when correct"
                ],
                currentActivity: 0,
                completed: false
            },
            
            vowels: {
                title: "Vowel & Consonant Fun",
                description: "Learn to differentiate vowels and consonants!",
                activities: [
                    {
                        type: "vowel_identification",
                        question: "Which of these is a vowel?",
                        letters: ["b", "a", "c", "d"],
                        options: ["b", "a", "c", "d"],
                        correct: 1,
                        explanation: "Correct! 'a' is a vowel (a, e, i, o, u)!",
                        points: 10
                    },
                    {
                        type: "consonant_identification",
                        question: "Find the consonant:",
                        letters: ["e", "i", "m", "o"],
                        options: ["e", "i", "m", "o"],
                        correct: 2,
                        explanation: "Great! 'm' is a consonant!",
                        points: 10
                    }
                ],
                dyslexia_tips: [
                    "Color code vowels and consonants differently",
                    "Use tactile feedback for differentiation",
                    "Practice with phonics sounds"
                ],
                currentActivity: 0,
                completed: false
            },
            
            spelling: {
                title: "Word Builder Game",
                description: "Spell and read words using phonics!",
                activities: [
                    {
                        type: "word_spelling",
                        question: "Spell 'cat' using letter blocks",
                        word: "cat",
                        letters: ["c", "a", "t", "b", "d", "e"],
                        correct: ["c", "a", "t"],
                        explanation: "Excellent! c-a-t spells 'cat'!",
                        points: 10,
                        phonics: "/k/ // /t/"
                    },
                    {
                        type: "malay_word",
                        question: "Spell 'buku' (book in Malay)",
                        word: "buku",
                        letters: ["b", "u", "k", "a", "e", "i"],
                        correct: ["b", "u", "k", "u"],
                        explanation: "Perfect! b-u-k-u = buku!",
                        points: 10,
                        syllable_breakdown: "bu-ku (2 syllables)"
                    }
                ],
                dyslexia_tips: [
                    "Break words into syllables",
                    "Use phonics sounds for each letter",
                    "Listen to the click sound feedback"
                ],
                currentActivity: 0,
                completed: false
            },
            
            tracing: {
                title: "Letter Tracer",
                description: "Trace letters with mouse or finger to build muscle memory",
                activities: [
                    {
                        type: "uppercase_tracing",
                        letter: "A",
                        strokeOrder: [
                            {x: 50, y: 150},
                            {x: 100, y: 50},
                            {x: 150, y: 150},
                            {x: 70, y: 100},
                            {x: 130, y: 100}
                        ],
                        difficulty: "easy",
                        points: 15,
                        hint: "Start at the green dot, go up to the point, then down to the other side"
                    },
                    {
                        type: "lowercase_tracing",
                        letter: "a",
                        strokeOrder: [
                            {x: 100, y: 100, type: "circle"},
                            {x: 100, y: 150, type: "line"}
                        ],
                        difficulty: "easy",
                        points: 15,
                        hint: "Make a circle first, then add the tail"
                    }
                ],
                dyslexia_tips: [
                    "Trace slowly and follow the guide",
                    "Say the letter sound as you trace",
                    "Start from the correct starting point",
                    "Use the starting dot as reference"
                ],
                currentActivity: 0,
                completed: false
            }
        };

        // Game State
        let currentGame = null;
        let currentActivityIndex = 0;
        let studentScore = 150;
        let isEasyMode = false;

        // Mickey Agent State
        let mickeyAgentVisible = false;
        let breakTimerActive = false;
        let breakTimeLeft = 30;
        let breakInterval = null;
        let breathingInterval = null;
        let studentEmotion = 'neutral';
        let frustrationLevel = 0;
        const FRUSTRATION_THRESHOLD = 5;

        // Voice Settings
        let voiceEnabled = true;

        // Emotion Detection Timer
        let emotionDetectionInterval;
        let secondsCounter = 0;
        let detectionCycle = 0;

        // ============================================
        // ENHANCED DUAL CAMERA DETECTION SYSTEM
        // ============================================

        class DualCameraDetection {
            constructor() {
                // State management
                this.isEmotionRunning = false;
                this.isEyeTracking = false;
                this.emotionFrameCount = 0;
                this.emotionLastTimestamp = 0;
                this.emotionFPS = 0;
                
                // Elements - Emotion detection
                this.emotionVideo = document.getElementById('emotion-video');
                this.emotionCanvas = document.getElementById('emotion-overlay');
                this.emotionCtx = this.emotionCanvas.getContext('2d');

                this.emotionInterventionData = {
                    lastInterventionTime: 0,
                    interventionCooldown: 15000, // 15 seconds between interventions
                    negativeEmotionCount: 0,
                    NEGATIVE_THRESHOLD: 3, // Number of negative detections before intervention
                    emotionHistory: []
                };
                
                // Elements - Eye tracking
                this.eyeCanvas = document.getElementById('eye-tracking-canvas');
                this.eyeCtx = this.eyeCanvas.getContext('2d');
                
                // Create separate video element for eye tracking (hidden, for processing only)
                this.irisVideo = document.createElement('video');
                this.irisVideo.id = 'eye-video';
                this.irisVideo.autoplay = true;
                this.irisVideo.playsinline = true;
                this.irisVideo.muted = true;
                this.irisVideo.style.display = 'none'; // Hide it, we only need it for processing
                
                // Display video will be created when eye tracking starts
                this.eyeDisplayVideo = null;

                // Human.js instances
                this.emotionHuman = null;
                this.eyeHuman = null;
                
                // Eye tracking data
                this.irisData = {
                    left: { x: 0, y: 0, confidence: 0 },
                    right: { x: 0, y: 0, confidence: 0 },
                    center: { x: 0, y: 0, confidence: 0 },
                    confidence: 0
                };
                
                // Emotion tracking
                this.studentEmotion = 'neutral';
                this.frustrationLevel = 0;
                this.FRUSTRATION_THRESHOLD = 5;
                this.emotionHistory = [];
                this.MAX_HISTORY = 10;

                this.focusData = {
                    overallFocus: 'unknown', // 'high', 'medium', 'low', 'unknown'
                    focusScore: 0,
                    interventionCooldown: 15000, // 15 seconds between interventions
                    lastFocusCheck: 0,
                    eyeDistanceFromCenter: 0,
                    cursorActivity: false,
                    lastCursorMove: 0,
                    cursorPosition: {x: 0, y: 0},
                    checkInterval: null
                };
                
                // Initialize focus tracking
                this.initFocusTracking();
                
                // Streams
                this.emotionStream = null;
                this.eyeStream = null;
                
                // Initialize
                this.init();
            }
            
            async init() {
                try {
                    // Initialize Human.js for emotion detection
                    this.emotionHuman = new Human.default({
                        modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human/models/',
                        backend: 'webgl',
                        face: { 
                            enabled: true,
                            detector: { 
                                maxDetected: 1,
                                rotation: true,
                                return: true,
                                modelPath: 'blazeface-back.json'
                            },
                            mesh: { 
                                enabled: true,
                                modelPath: 'facemesh.json'
                            },
                            iris: { enabled: false },
                            emotion: { 
                                enabled: true,
                                modelPath: 'emotion.json'
                            },
                            description: { enabled: false },
                            liveness: { enabled: false },
                            antispoof: { enabled: false }
                        },
                        body: { enabled: false },
                        hand: { enabled: false },
                        object: { enabled: false },
                        segmentation: { enabled: false },
                        cacheSensitivity: 0,
                        skipFrames: 0
                    });
                    
                    // Initialize Human.js for eye tracking
                    this.eyeHuman = new Human.default({
                        modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human/models/',
                        backend: 'webgl',
                        face: { 
                            enabled: true,
                            detector: { 
                                maxDetected: 1,
                                rotation: true,
                                return: true,
                                modelPath: 'blazeface-back.json'
                            },
                            mesh: { 
                                enabled: true,
                                modelPath: 'facemesh.json'
                            },
                            iris: { 
                                enabled: true,
                                maxDetected: 2,
                                minConfidence: 0.1
                            },
                            emotion: { enabled: false },
                            description: { enabled: false },
                            liveness: { enabled: false },
                            antispoof: { enabled: false }
                        },
                        body: { enabled: false },
                        hand: { enabled: false },
                        object: { enabled: false },
                        segmentation: { enabled: false },
                        cacheSensitivity: 0,
                        skipFrames: 0
                    });
                    
                    await Promise.all([
                        this.emotionHuman.load(),
                        this.eyeHuman.load()
                    ]);
                    
                    console.log(' Dual camera detection models loaded');
                    
                    // Set up canvas sizes
                    this.resizeCanvases();
                    window.addEventListener('resize', () => this.resizeCanvases());
                    
                    // Initialize UI
                    this.initUI();
                    
                } catch (error) {
                    console.error('Failed to initialize dual camera detection:', error);
                    this.showError('Failed to load detection models. Please refresh the page.');
                }
            }

            resizeCanvases() {
                const containerWidth = 300;
                const containerHeight = 180;
                
                this.emotionCanvas.width = containerWidth;
                this.emotionCanvas.height = containerHeight;
                
                this.eyeCanvas.width = containerWidth;
                this.eyeCanvas.height = containerHeight;
            }
            
            initUI() {
                // Start Both button
                document.getElementById('start-all-detection').addEventListener('click', () => this.startBothDetections());
                
                // Stop Both button
                document.getElementById('stop-all-detection').addEventListener('click', () => this.stopBothDetections());
                
                // Emotion Only button
                document.getElementById('start-emotion-detection').addEventListener('click', () => this.toggleEmotionDetection());
                
                // Eye Only button
                document.getElementById('start-eye-detection').addEventListener('click', () => this.toggleEyeDetection());
                
                // Close camera content
                document.getElementById('close-camera-content').addEventListener('click', () => this.closeCameraPanel());
                
                // Update button states
                this.updateButtonStates();
            }
            
            initFocusTracking() {
                console.log(' Initializing enhanced focus tracking...');
                
                // Track cursor movement
                document.addEventListener('mousemove', (e) => this.updateCursorActivity(e));
                document.addEventListener('touchmove', (e) => this.updateCursorActivity(e));
                
                // Start checking focus
                this.startFocusChecking();
            }
            
            updateCursorActivity(e) {
                const now = Date.now();
                let x, y;
                
                if (e.type === 'touchmove') {
                    if (e.touches.length > 0) {
                        x = e.touches[0].clientX;
                        y = e.touches[0].clientY;
                    } else return;
                } else {
                    x = e.clientX;
                    y = e.clientY;
                }
                
                // Check if significant movement
                const distance = Math.sqrt(
                    Math.pow(x - this.focusData.cursorPosition.x, 2) +
                    Math.pow(y - this.focusData.cursorPosition.y, 2)
                );
                
                if (distance > 5) { // More than 5px movement
                    this.focusData.cursorPosition = {x, y};
                    this.focusData.lastCursorMove = now;
                    this.focusData.cursorActivity = true;
                }
            }

            updateButtonStates() {
                const startAllBtn = document.getElementById('start-all-detection');
                const stopAllBtn = document.getElementById('stop-all-detection');
                const emotionBtn = document.getElementById('start-emotion-detection');
                const eyeBtn = document.getElementById('start-eye-detection');
                
                // Update Start/Stop Both buttons
                if (this.isEmotionRunning && this.isEyeTracking) {
                    startAllBtn.disabled = true;
                    stopAllBtn.disabled = false;
                } else {
                    startAllBtn.disabled = false;
                    stopAllBtn.disabled = true;
                }
                
                // Update Emotion button
                emotionBtn.innerHTML = this.isEmotionRunning ? 
                    '<i class="fas fa-stop"></i> Stop Emotion' : 
                    '<i class="fas fa-smile"></i> Emotion Only';
                emotionBtn.className = this.isEmotionRunning ? 
                    'separate-btn stop-emotion-btn btn-active' : 
                    'separate-btn start-emotion-btn';
                
                // Update Eye button
                eyeBtn.innerHTML = this.isEyeTracking ? 
                    '<i class="fas fa-stop"></i> Stop Eye' : 
                    '<i class="fas fa-eye"></i> Eye Only';
                eyeBtn.className = this.isEyeTracking ? 
                    'separate-btn stop-eye-btn btn-active' : 
                    'separate-btn start-eye-btn';
                
                // Update status indicators
                this.updateStatusIndicators();
                this.updateCameraBubbles();
            }
            
            updateStatusIndicators() {
                const emotionStatus = document.getElementById('emotion-status');
                const eyeStatus = document.getElementById('eye-status');
                
                if (emotionStatus) {
                    emotionStatus.innerHTML = this.isEmotionRunning ? 
                        '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE' : 
                        '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE';
                    emotionStatus.className = this.isEmotionRunning ? 
                        'screen-status active' : 'screen-status';
                }
                
                if (eyeStatus) {
                    eyeStatus.innerHTML = this.isEyeTracking ? 
                        '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE' : 
                        '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE';
                    eyeStatus.className = this.isEyeTracking ? 
                        'screen-status active' : 'screen-status';
                }
                
                // Update status indicators in header
                const emotionIndicator = document.getElementById('emotion-indicator');
                const eyeIndicator = document.getElementById('eye-indicator');
                
                if (emotionIndicator) {
                    if (this.isEmotionRunning) {
                        emotionIndicator.classList.add('indicator-active');
                    } else {
                        emotionIndicator.classList.remove('indicator-active');
                    }
                }
                
                if (eyeIndicator) {
                    if (this.isEyeTracking) {
                        eyeIndicator.classList.add('indicator-active');
                    } else {
                        eyeIndicator.classList.remove('indicator-active');
                    }
                }
            }
            
            updateCameraBubbles() {
                const emotionBubble = document.getElementById('side-emotion-camera');
                const eyeBubble = document.getElementById('side-eye-camera');
                const emotionDot = document.getElementById('emotion-status-dot');
                const eyeDot = document.getElementById('eye-status-dot');
                
                if (emotionBubble) {
                    if (this.isEmotionRunning) {
                        emotionBubble.classList.add('active');
                        emotionDot.className = 'camera-status-dot active';
                        emotionBubble.title = 'Emotion Detection (Active)';
                    } else {
                        emotionBubble.classList.remove('active');
                        emotionDot.className = 'camera-status-dot inactive';
                        emotionBubble.title = 'Emotion Detection';
                    }
                }
                
                if (eyeBubble) {
                    if (this.isEyeTracking) {
                        eyeBubble.classList.add('active');
                        eyeDot.className = 'camera-status-dot active';
                        eyeBubble.title = 'Eye Tracking (Active)';
                    } else {
                        eyeBubble.classList.remove('active');
                        eyeDot.className = 'camera-status-dot inactive';
                        eyeBubble.title = 'Eye Tracking';
                    }
                }
            }
            
            createEyeDisplayVideo() {
                const eyeScreen = document.getElementById('eye-screen');
                if (eyeScreen) {
                    const videoContainer = eyeScreen.querySelector('.video-container');
                    if (videoContainer) {
                        // Remove existing video if present
                        const existingVideo = videoContainer.querySelector('#eye-display-video');
                        if (existingVideo) {
                            existingVideo.remove();
                        }
                        
                        // Create a new video element for display
                        this.eyeDisplayVideo = document.createElement('video');
                        this.eyeDisplayVideo.id = 'eye-display-video';
                        this.eyeDisplayVideo.className = 'detection-video';
                        this.eyeDisplayVideo.autoplay = true;
                        this.eyeDisplayVideo.playsinline = true;
                        this.eyeDisplayVideo.muted = true;
                        this.eyeDisplayVideo.style.width = '100%';
                        this.eyeDisplayVideo.style.height = '100%';
                        this.eyeDisplayVideo.style.objectFit = 'cover';
                        this.eyeDisplayVideo.style.transform = 'scaleX(-1)';
                        this.eyeDisplayVideo.style.position = 'absolute';
                        this.eyeDisplayVideo.style.top = '0';
                        this.eyeDisplayVideo.style.left = '0';
                        this.eyeDisplayVideo.style.zIndex = '1';
                        
                        videoContainer.appendChild(this.eyeDisplayVideo);
                        
                        // Ensure canvas is on top
                        const canvas = videoContainer.querySelector('.eye-canvas');
                        if (canvas) {
                            canvas.style.position = 'absolute';
                            canvas.style.top = '0';
                            canvas.style.left = '0';
                            canvas.style.zIndex = '2';
                            canvas.style.pointerEvents = 'none';
                        }
                    }
                }
            }

            async startBothDetections() {
                try {
                    await this.startEmotionDetection();
                    await this.startEyeDetection();
                    
                    this.showSuccess('Both detection systems started successfully!');
                    
                } catch (error) {
                    console.error('Failed to start both detections:', error);
                    this.showError('Failed to start detection systems. Please check camera permissions.');
                }
            }
            
            async startEmotionDetection() {
                if (this.isEmotionRunning) return;
                
                try {
                    // Get camera
                    this.emotionStream = await navigator.mediaDevices.getUserMedia({
                        video: true,  // SIMPLEST
                        audio: false
                    });
                    
                    // Connect stream to video element
                    this.emotionVideo.srcObject = this.emotionStream;
                    
                    // Wait for video to load
                    await new Promise(resolve => {
                        this.emotionVideo.onloadedmetadata = resolve;
                    });
                    
                    // Play video
                    await this.emotionVideo.play();
                    
                    this.isEmotionRunning = true;
                    this.updateButtonStates();
                    this.detectEmotionFrame();
                    
                } catch (error) {
                    console.error('Camera error:', error);
                }
            }
            
            async startEyeDetection() {
                if (this.isEyeTracking) return;
                
                try {
                    // Create display video element if it doesn't exist
                    this.createEyeDisplayVideo();
                    
                    // Request SEPARATE camera stream for eye tracking
                    this.eyeStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user',
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    });
                    
                    // Connect to BOTH video elements
                    this.irisVideo.srcObject = this.eyeStream;
                    
                    if (this.eyeDisplayVideo) {
                        this.eyeDisplayVideo.srcObject = this.eyeStream;
                    }
                    
                    // Wait for videos to be ready
                    await Promise.all([
                        new Promise(resolve => {
                            this.irisVideo.onloadedmetadata = resolve;
                            if (this.irisVideo.readyState >= 3) resolve();
                        }),
                        new Promise(resolve => {
                            if (this.eyeDisplayVideo) {
                                this.eyeDisplayVideo.onloadedmetadata = resolve;
                                if (this.eyeDisplayVideo.readyState >= 3) resolve();
                            } else {
                                resolve();
                            }
                        })
                    ]);
                    
                    // Start playing videos
                    await this.irisVideo.play();
                    if (this.eyeDisplayVideo) {
                        await this.eyeDisplayVideo.play();
                    }
                    
                    this.isEyeTracking = true;
                    
                    // Update UI
                    this.updateButtonStates();
                    
                    // Start detection loop
                    this.detectEyeFrame();
                    
                    console.log(' Eye tracking started with separate video stream');
                    
                } catch (error) {
                    console.error('Failed to start eye tracking:', error);
                    this.showError('Cannot access camera for eye tracking. Please allow camera permissions.');
                    throw error;
                }
            }

            startFocusChecking() {
                // Check focus every 2 seconds
                this.focusData.checkInterval = setInterval(() => {
                    this.calculateFocus();
                }, 2000);
            }
            
            calculateFocus() {
                // Get eye focus level
                const eyeFocus = this.getEyeFocusLevel();
                
                // Get cursor focus level
                const cursorFocus = this.getCursorFocusLevel();
                
                // Combine them
                const combinedScore = this.combineFocusScores(eyeFocus, cursorFocus);
                
                // Update overall focus
                this.focusData.focusScore = combinedScore.score;
                this.focusData.overallFocus = combinedScore.level;
                
                // Update UI
                this.updateFocusDisplay();
                
                // Check for interventions
                this.checkFocusIntervention();
            }
            
            getEyeFocusLevel() {
                if (!this.irisData || this.irisData.confidence < 0.3) {
                    return { level: 'unknown', score: 0 };
                }
                
                // Calculate distance from center
                const centerX = 0.5;
                const centerY = 0.5;
                const distance = Math.sqrt(
                    Math.pow(this.irisData.center.x - centerX, 2) +
                    Math.pow(this.irisData.center.y - centerY, 2)
                );
                
                this.focusData.eyeDistanceFromCenter = distance;
                
                // Determine level based on distance
                // Normal reading involves moving eyes 20-40% from center!
                if (distance < 0.3) return { level: 'high', score: 90 }; // Eyes must stay within 30% of screen center
                if (distance < 0.4 && distance >= 0.3) return { level: 'medium', score: 60 }; // Eyes within 40% of center
                if (distance >= 0.4) return { level: 'low', score: 30 }; // Eyes beyond 40% from center
            }
            
            getCursorFocusLevel() {
                const now = Date.now();
                const timeSinceMove = now - this.focusData.lastCursorMove;
                
                if (timeSinceMove < 1000) return { level: 'high', score: 90 };
                if (timeSinceMove < 5000) return { level: 'medium', score: 60 };
                if (timeSinceMove < 30000) return { level: 'low', score: 30 };
                return { level: 'unknown', score: 0 };
            }
            
            getFocusByFixation() {
                if (!this.irisData) return { level: 'unknown', score: 0 };
                
                // Track how long eyes stay in same general area
                const now = Date.now();
                const gazeChanged = Math.abs(this.irisData.center.x - this.lastGazePosition.x) > 0.1 ||
                                    Math.abs(this.irisData.center.y - this.lastGazePosition.y) > 0.1;
                
                if (gazeChanged) {
                    this.lastGazeChangeTime = now;
                    this.lastGazePosition = this.irisData.center;
                }
                
                const fixationTime = now - this.lastGazeChangeTime;
                
                if (fixationTime > 3000) return { level: 'high', score: 90 };    // 3+ seconds
                if (fixationTime > 1000) return { level: 'medium', score: 70 };  // 1-3 seconds
                return { level: 'low', score: 40 };                              // <1 second
            }

            combineFocusScores(eyeFocus, cursorFocus) {
                let totalScore = 0;
                let totalWeight = 0;
                
                // Eye focus weight: 60%
                if (eyeFocus.level !== 'unknown') {
                    totalScore += eyeFocus.score * 0.6;
                    totalWeight += 0.6;
                }
                
                // Cursor focus weight: 40%
                if (cursorFocus.level !== 'unknown') {
                    totalScore += cursorFocus.score * 0.4;
                    totalWeight += 0.4;
                }
                
                // Calculate average
                let finalScore = totalWeight > 0 ? Math.round(totalScore / totalWeight) : 0;
                
                // Determine level
                let finalLevel = 'unknown';
                if (finalScore >= 65) finalLevel = 'high';
                else if (finalScore >= 40) finalLevel = 'medium';
                else if (finalScore >= 5) finalLevel = 'low';
                
                return { score: finalScore, level: finalLevel };
            }

            stopBothDetections() {
                this.stopEmotionDetection();
                this.stopEyeDetection();
                this.showInfo('Both detection systems stopped.');

                // Clear focus checking interval
                if (this.focusData.checkInterval) {
                    clearInterval(this.focusData.checkInterval);
                    this.focusData.checkInterval = null;
                }
            }
            
            stopEmotionDetection() {
                if (this.emotionStream) {
                    this.emotionStream.getTracks().forEach(track => track.stop());
                    this.emotionStream = null;
                }
                
                this.emotionVideo.srcObject = null;
                this.isEmotionRunning = false;
                
                // Clear canvas
                this.emotionCtx.clearRect(0, 0, this.emotionCanvas.width, this.emotionCanvas.height);
                
                // Reset displays
                document.getElementById('face-count').textContent = '0';
                document.getElementById('dominant-emotion').textContent = '-';
                document.getElementById('emotion-confidence').textContent = '0%';
                document.getElementById('emotion-info').textContent = 'Emotion: -';
                
                this.updateButtonStates();
                
                console.log(' Emotion detection stopped');
            }
            
            stopEyeDetection() {
                if (this.eyeStream) {
                    this.eyeStream.getTracks().forEach(track => track.stop());
                    this.eyeStream = null;
                }
                
                this.irisVideo.srcObject = null;
                if (this.eyeDisplayVideo) {
                    this.eyeDisplayVideo.srcObject = null;
                }
                
                this.isEyeTracking = false;
                
                // Clear canvas
                this.eyeCtx.clearRect(0, 0, this.eyeCanvas.width, this.eyeCanvas.height);
                
                // Reset displays
                document.getElementById('iris-confidence').textContent = '0%';
                document.getElementById('focus-direction').textContent = '-';
                document.getElementById('focus-score').textContent = '0%';
                document.getElementById('alignment-score').textContent = '0%';
                document.getElementById('iris-info').textContent = 'Iris: Waiting...';
                
                const focusStatus = document.getElementById('focus-status');
                if (focusStatus) {
                    focusStatus.innerHTML = `
                        <div class="status-dot status-unknown"></div>
                        <span>Focus: -</span>
                    `;
                }
                
                this.updateButtonStates();
                
                console.log(' Eye tracking stopped');
            }

            toggleEmotionDetection() {
                if (this.isEmotionRunning) {
                    this.stopEmotionDetection();
                } else {
                    this.startEmotionDetection();
                }
            }
            
            toggleEyeDetection() {
                if (this.isEyeTracking) {
                    this.stopEyeDetection();
                } else {
                    this.startEyeDetection();
                }
            }
            
            closeCameraPanel() {
                const cameraContent = document.getElementById('camera-content');
                if (cameraContent) {
                    cameraContent.classList.remove('active');
                }
                
                this.showInfo('Camera panel closed. Detection continues in background.');
            }
            
            async detectEmotionFrame() {
                if (!this.isEmotionRunning) return;
                
                try {
                    // Update FPS
                    this.updateEmotionFPS();
                    
                    // Run detection
                    const result = await this.emotionHuman.detect(this.emotionVideo);
                    
                    // Clear and draw
                    this.emotionCtx.clearRect(0, 0, this.emotionCanvas.width, this.emotionCanvas.height);
                    
                    // Draw video frame
                    this.emotionCtx.drawImage(this.emotionVideo, 0, 0, 
                        this.emotionCanvas.width, this.emotionCanvas.height);
                    
                    // Check for faces
                    if (result.face && result.face.length > 0) {
                        const face = result.face[0];
                        
                        // Update face count
                        document.getElementById('face-count').textContent = result.face.length;
                        
                        // Draw face detection
                        this.drawEmotionFace(face);
                        
                        // Update Mickey agent
                        this.updateMickeyAgent(face);
                        
                    } else {
                        // No faces found
                        document.getElementById('face-count').textContent = '0';
                        document.getElementById('dominant-emotion').textContent = '-';
                        document.getElementById('emotion-confidence').textContent = '0%';
                        document.getElementById('emotion-info').textContent = 'Emotion: No face';
                        
                        // Show "no face" message
                        this.drawNoFaceMessage();
                    }
                    
                } catch (error) {
                    console.log('Detection error:', error);
                }
                
                // Loop
                if (this.isEmotionRunning) {
                    requestAnimationFrame(() => this.detectEmotionFrame());
                }
            }

            drawEmotionFace(face) {
                const ctx = this.emotionCtx;
                const canvasWidth = this.emotionCanvas.width;
                const canvasHeight = this.emotionCanvas.height;
                const videoWidth = this.emotionVideo.videoWidth;
                const videoHeight = this.emotionVideo.videoHeight;
                
                // CLEAR FIRST
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // DRAW VIDEO FRAME FIRST
                ctx.drawImage(this.emotionVideo, 0, 0, canvasWidth, canvasHeight);
                
                if (!face.box) return;
                
                // Calculate scaling
                const scaleX = canvasWidth / videoWidth;
                const scaleY = canvasHeight / videoHeight;
                
                const [x, y, width, height] = face.box;
                
                // SCALE THE BOX
                const scaledX = x * scaleX;
                const scaledY = y * scaleY;
                const scaledWidth = width * scaleX;
                const scaledHeight = height * scaleY;
                
                // Get dominant emotion
                const dominantEmotion = this.getDominantEmotion(face);
                const color = this.getEmotionColor(dominantEmotion.name);
                
                // Draw face box
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                
                // Draw emotion label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(scaledX + scaledWidth - 120, scaledY - 20, 115, 18);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(
                    `${dominantEmotion.name} ${Math.round(dominantEmotion.confidence * 100)}%`,
                    scaledX + scaledWidth - 5,
                    scaledY - 5
                );
                ctx.textAlign = 'left';
                
                // Update emotion display stats
                this.updateEmotionDisplay(face);
                
                // Draw landmarks - SCALE THEM TOO
                if (face.mesh && face.mesh.length > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
                    
                    // Draw SOME landmarks (not all for performance)
                    const step = 10; // Draw every 10th point
                    for (let i = 0; i < Math.min(100, face.mesh.length); i += step) {
                        const point = face.mesh[i];
                        if (point && point.length >= 2) {
                            const px = point[0] * scaleX;
                            const py = point[1] * scaleY;
                            ctx.beginPath();
                            ctx.arc(px, py, 1, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            drawNoFaceMessage() {
                const ctx = this.emotionCtx;
                const width = this.emotionCanvas.width;
                const height = this.emotionCanvas.height;
                
                // Draw semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, width, height);
                
                // Draw "no face" message
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No face detected', width / 2, height / 2);
                ctx.font = '12px Arial';
                ctx.fillText('Make sure your face is visible', width / 2, height / 2 + 20);
                ctx.textAlign = 'left';
            }

            getDominantEmotion(face) {
                if (!face.emotion || !Array.isArray(face.emotion) || face.emotion.length === 0) {
                    return { name: 'neutral', confidence: 0.5 };
                }
                
                const topEmotion = face.emotion[0];
                return {
                    name: topEmotion.emotion || 'neutral',
                    confidence: topEmotion.score || 0.5
                };
            }
            
            getEmotionColor(emotion) {
                const colors = {
                    'angry': '#FF0000',
                    'happy': '#00FF00',
                    'neutral': '#FFFF00',
                    'sad': '#0000FF'
                };
                return colors[emotion] || '#00FF00';
            }

            getFocusReport() {
                return {
                    score: this.focusData.focusScore,
                    level: this.focusData.overallFocus,
                    eyeDistance: this.focusData.eyeDistanceFromCenter,
                    cursorActive: this.focusData.cursorActivity,
                    lastCursorMove: this.focusData.lastCursorMove
                };
            }

            updateEmotionDisplay(face) {
                const dominantEmotion = this.getDominantEmotion(face);
                const confidence = Math.round(dominantEmotion.confidence * 100);
                
                // Update main displays
                document.getElementById('dominant-emotion').textContent = dominantEmotion.name;
                document.getElementById('dominant-emotion').style.color = this.getEmotionColor(dominantEmotion.name);
                document.getElementById('emotion-confidence').textContent = `${confidence}%`;
                
                // Update small info display
                document.getElementById('emotion-info').textContent = 
                    `Emotion: ${dominantEmotion.name} (${confidence}%)`;
            }

            updateEmotionFPS() {
                const now = performance.now();
                this.emotionFrameCount++;
                
                if (now >= this.emotionLastTimestamp + 1000) {
                    this.emotionFPS = Math.round((this.emotionFrameCount * 1000) / (now - this.emotionLastTimestamp));
                    this.emotionLastTimestamp = now;
                    this.emotionFrameCount = 0;
                    
                    document.getElementById('emotion-fps').textContent = this.emotionFPS;
                }
            }
            
            async detectEyeFrame() {
                if (!this.isEyeTracking || !this.eyeHuman) {
                    return;
                }
                
                try {
                    if (this.irisVideo.readyState >= 2) {
                        // Use the irisVideo for detection (separate stream)
                        const result = await this.eyeHuman.detect(this.irisVideo);
                        
                        if (result.face && result.face.length > 0) {
                            const face = result.face[0];
                            const irisData = this.extractIrisData(face);
                            this.updateIrisData(irisData.left, irisData.right, irisData.confidence);
                            this.drawEyeTracking(irisData, result.face[0]);
                        } else {
                            // No face detected
                            this.updateIrisData([0, 0], [0, 0], 0);
                            this.drawNoFace();
                        }
                    }
                } catch (error) {
                    console.error('Eye detection error:', error);
                }
                
                // Continue loop
                if (this.isEyeTracking) {
                    requestAnimationFrame(() => this.detectEyeFrame());
                }
            }
                
            extractIrisData(face) {
                let leftIris = [0, 0];
                let rightIris = [0, 0];
                let confidence = 0.1;
                
                if (face.iris && Array.isArray(face.iris) && face.iris.length >= 2) {
                    leftIris = face.iris[0];
                    rightIris = face.iris[1];
                    confidence = face.score || 0.7;
                } 
                else if (face.annotations && face.annotations.iris) {
                    leftIris = face.annotations.iris.left || [0, 0];
                    rightIris = face.annotations.iris.right || [0, 0];
                    confidence = face.score || 0.7;
                }
                else if (face.mesh && face.mesh.length >= 478) {
                    leftIris = face.mesh[468] || [0, 0, 0];
                    rightIris = face.mesh[473] || [0, 0, 0];
                    confidence = face.score || 0.5;
                }
                
                if (Array.isArray(leftIris) && leftIris.length >= 2) {
                    leftIris = [leftIris[0], leftIris[1]];
                }
                
                if (Array.isArray(rightIris) && rightIris.length >= 2) {
                    rightIris = [rightIris[0], rightIris[1]];
                }
                
                return { left: leftIris, right: rightIris, confidence };
            }
            
            updateIrisData(leftIris, rightIris, confidence) {
                this.irisData.left = { 
                    x: leftIris[0], 
                    y: leftIris[1], 
                    confidence: confidence 
                };
                
                this.irisData.right = { 
                    x: rightIris[0], 
                    y: rightIris[1], 
                    confidence: confidence 
                };
                
                this.irisData.center = {
                    x: (leftIris[0] + rightIris[0]) / 2,
                    y: (leftIris[1] + rightIris[1]) / 2,
                    confidence: confidence
                };
                
                this.irisData.confidence = confidence;
                
                // Update displays
                this.updateIrisDisplay();
                this.calculateFocusMetrics();
            }
            
            updateIrisDisplay() {
                const confidence = Math.round(this.irisData.confidence * 100);
                const left = this.irisData.left;
                const right = this.irisData.right;
                
                // Update main display
                document.getElementById('iris-confidence').textContent = `${confidence}%`;
                
                // Update small info display
                document.getElementById('iris-info').textContent = 
                    `Iris: ${confidence}% L:${Math.round(left.x)},${Math.round(left.y)}`;
            }
            
            calculateFocusMetrics() {
                if (this.irisData.confidence < 0.3) {
                    this.updateFocusStatus(0, 'unknown');
                    document.getElementById('focus-score').textContent = '0%';
                    document.getElementById('alignment-score').textContent = '0%';
                    document.getElementById('focus-direction').textContent = '-';
                    return;
                }
                
                // Calculate focus metrics
                const focusScore = Math.round(this.irisData.confidence * 100);
                const alignment = Math.round((1.5 - this.irisData.confidence) * 100);
                
                // Update displays
                document.getElementById('focus-score').textContent = `${focusScore}%`;
                document.getElementById('alignment-score').textContent = `${Math.max(0, Math.min(100, alignment))}%`;
                
                // Determine focus direction
                const centerX = this.irisData.center.x;
                let direction = 'Center';
                
                if (centerX < 0.4) direction = 'Left';
                else if (centerX > 0.6) direction = 'Right';
                
                document.getElementById('focus-direction').textContent = direction;
                
                // Update focus status
                this.updateFocusStatus(focusScore);
            }
            
            updateFocusStatus(score) {
                const focusStatus = document.getElementById('focus-status');
                if (!focusStatus) return;
                
                let statusClass = 'status-unknown';
                let statusText = 'Focus: -';
                let statusColor = '#FFA500';
                
                if (score > 80) {
                    statusClass = 'status-focusing';
                    statusText = 'Focus: HIGH';
                    statusColor = '#4CAF50';
                } else if (score > 50) {
                    statusClass = 'status-unknown';
                    statusText = 'Focus: MEDIUM';
                    statusColor = '#FFA500';
                } else {
                    statusClass = 'status-distracted';
                    statusText = 'Focus: LOW';
                    statusColor = '#f44336';
                }
                
                focusStatus.innerHTML = `
                    <div class="status-dot ${statusClass}"></div>
                    <span>${statusText}</span>
                `;
                focusStatus.style.color = statusColor;
            }
            
            drawEyeTracking(irisData, face = null) {
                const ctx = this.eyeCtx;
                const width = this.eyeCanvas.width;
                const height = this.eyeCanvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw the eye display video frame if available
                if (this.eyeDisplayVideo && this.eyeDisplayVideo.videoWidth > 0) {
                    // Calculate aspect ratio fit
                    const videoWidth = this.eyeDisplayVideo.videoWidth;
                    const videoHeight = this.eyeDisplayVideo.videoHeight;
                    const videoRatio = videoWidth / videoHeight;
                    const canvasRatio = width / height;
                    
                    let renderWidth, renderHeight, offsetX, offsetY;
                    
                    if (videoRatio > canvasRatio) {
                        // Video is wider
                        renderHeight = height;
                        renderWidth = height * videoRatio;
                        offsetX = (width - renderWidth) / 2;
                        offsetY = 0;
                    } else {
                        // Video is taller
                        renderWidth = width;
                        renderHeight = width / videoRatio;
                        offsetX = 0;
                        offsetY = (height - renderHeight) / 2;
                    }
                    
                    // Draw video
                    ctx.drawImage(this.eyeDisplayVideo, offsetX, offsetY, renderWidth, renderHeight);
                    
                    // Calculate scaling factors
                    const scaleX = renderWidth / videoWidth;
                    const scaleY = renderHeight / videoHeight;
                    
                    // Draw face mesh if available (WITH PROPER SCALING)
                    if (face && face.mesh) {
                        this.drawFaceMesh(ctx, face.mesh, offsetX, offsetY, scaleX, scaleY);
                    }
                }
                
                if (irisData.confidence > 0.3) {
                    // Draw iris overlays (need to update this too for proper scaling)
                    this.drawIrisOverlay(irisData);
                }
                
                // Draw screen center target (moved to front layer)
                this.drawScreenCenterTarget(ctx, width, height);
            }

            drawIrisOverlay(irisData) {
                const ctx = this.eyeCtx;
                const width = this.eyeCanvas.width;
                const height = this.eyeCanvas.height;
                
                if (this.eyeDisplayVideo && this.eyeDisplayVideo.videoWidth > 0) {
                    const videoWidth = this.eyeDisplayVideo.videoWidth;
                    const videoHeight = this.eyeDisplayVideo.videoHeight;
                    
                    // Calculate scaling
                    const videoRatio = videoWidth / videoHeight;
                    const canvasRatio = width / height;
                    
                    let renderWidth, renderHeight, offsetX, offsetY;
                    
                    if (videoRatio > canvasRatio) {
                        renderHeight = height;
                        renderWidth = height * videoRatio;
                        offsetX = (width - renderWidth) / 2;
                        offsetY = 0;
                    } else {
                        renderWidth = width;
                        renderHeight = width / videoRatio;
                        offsetX = 0;
                        offsetY = (height - renderHeight) / 2;
                    }
                    
                    const scaleX = renderWidth / videoWidth;
                    const scaleY = renderHeight / videoHeight;
                    
                    // Calculate iris positions WITH SCALING
                    const leftX = offsetX + (irisData.left[0] || 0) * scaleX;
                    const leftY = offsetY + (irisData.left[1] || 0) * scaleY;
                    const rightX = offsetX + (irisData.right[0] || 0) * scaleX;
                    const rightY = offsetY + (irisData.right[1] || 0) * scaleY;
                    
                    // Draw iris circles
                    ctx.fillStyle = 'rgba(255, 100, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(leftX, leftY, 6 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(100, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(rightX, rightY, 6 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw arrows to screen center
                    const centerX = width / 2;
                    const centerY = height / 2;
                    this.drawArrow(ctx, leftX, leftY, centerX, centerY, '#ff6b8b');
                    this.drawArrow(ctx, rightX, rightY, centerX, centerY, '#8ac6d1');
                    
                    // Draw center arrow
                    const irisCenterX = (leftX + rightX) / 2;
                    const irisCenterY = (leftY + rightY) / 2;
                    this.drawArrow(ctx, irisCenterX, irisCenterY, centerX, centerY, '#ffd166');
                    
                    // Label irises
                    ctx.fillStyle = 'lime';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText('L', leftX, leftY - 10);
                    ctx.fillText('R', rightX, rightY - 10);
                }
            }

            updateFocusDisplay() {
                // Update the existing focus status
                const focusStatus = document.getElementById('focus-status');
                if (!focusStatus) return;
                
                let statusClass = 'status-unknown';
                let statusText = 'Focus: -';
                let statusColor = '#999';
                
                switch(this.focusData.overallFocus) {
                    case 'high':
                        statusClass = 'status-focusing';
                        statusText = `Focus: HIGH (${this.focusData.focusScore}%)`;
                        statusColor = '#4CAF50';
                        break;
                    case 'medium':
                        statusClass = 'status-unknown';
                        statusText = `Focus: MEDIUM (${this.focusData.focusScore}%)`;
                        statusColor = '#FFA500';
                        break;
                    case 'low':
                        statusClass = 'status-distracted';
                        statusText = `Focus: LOW (${this.focusData.focusScore}%)`;
                        statusColor = '#f44336';
                        break;
                    default:
                        statusClass = 'status-unknown';
                        statusText = 'Focus: -';
                        statusColor = '#999';
                }
                
                focusStatus.innerHTML = `
                    <div class="status-dot ${statusClass}"></div>
                    <span>${statusText}</span>
                `;
                focusStatus.style.color = statusColor;
                
                // Update focus score display
                const focusScoreElement = document.getElementById('focus-score');
                if (focusScoreElement) {
                    focusScoreElement.textContent = `${this.focusData.focusScore}%`;
                    focusScoreElement.style.color = statusColor;
                }
            }
            
            checkFocusIntervention() {
                if (!currentGame) return;
                
                // Check both focus and emotion
                const needsIntervention = (
                    this.focusData.overallFocus === 'low' || 
                    this.emotionInterventionData.negativeEmotionCount >= this.emotionInterventionData.NEGATIVE_THRESHOLD
                );
                
                if (needsIntervention && !mickeyAgentVisible) {
                    frustrationLevel++;
                    
                    if (frustrationLevel >= 3) {
                        console.log(' Low focus/negative emotion detected, triggering intervention');
                        
                        // Choose which type of intervention based on what's worse
                        if (this.emotionInterventionData.negativeEmotionCount >= this.emotionInterventionData.NEGATIVE_THRESHOLD) {
                            // Emotion is worse - trigger emotion intervention
                            const recentEmotions = this.emotionInterventionData.emotionHistory.slice(-3);
                            const mostCommonEmotion = this.getMostCommonEmotion(recentEmotions);
                            this.triggerEmotionIntervention(mostCommonEmotion || 'frustrated');
                        } else {
                            // Focus is worse - trigger focus intervention
                            this.triggerFocusIntervention();
                        }
                        
                        frustrationLevel = 0;
                    }
                } else {
                    // Reset frustration counter when things improve
                    frustrationLevel = Math.max(0, frustrationLevel - 1);
                }
            }
            
            getMostCommonEmotion(emotionArray) {
                if (!emotionArray || emotionArray.length === 0) return 'neutral';
                
                const counts = {};
                emotionArray.forEach(entry => {
                    counts[entry.emotion] = (counts[entry.emotion] || 0) + 1;
                });
                
                let maxCount = 0;
                let mostCommon = 'neutral';
                
                Object.entries(counts).forEach(([emotion, count]) => {
                    if (count > maxCount) {
                        maxCount = count;
                        mostCommon = emotion;
                    }
                });
                
                return mostCommon;
            }

            triggerFocusIntervention() {
                const interventionData = botPhrases.intervention.distracted;
                
                // Show the bot with message AND buttons immediately
                showSpeakingBot(interventionData.message, {
                    type: 'intervention',
                    autoClose: false,
                    showOptions: true,
                    options: interventionData.options,
                    emotion: 'distracted'
                });
            }

            triggerCombinedIntervention(helpData) {
                const now = Date.now();
                const timeSinceLast = now - this.emotionInterventionData.lastInterventionTime;
                
                // Don't intervene too often (15-second cooldown)
                if (timeSinceLast < 15000) return;
                
                this.emotionInterventionData.lastInterventionTime = now;
                
                // Choose message based on combination
                let message = "";
                let emotionType = "frustrated";
                
                if (helpData.emotion === "angry" && helpData.focus === "low") {
                    message = "I notice you're frustrated AND distracted. How can I help?";
                    emotionType = "angry_distracted";
                } else if (helpData.emotion === "sad" && helpData.focus === "low") {
                    message = "You seem down and having trouble focusing. What would help?";
                    emotionType = "sad_distracted";
                } else if (helpData.focus === "low") {
                    message = "Your attention seems to be drifting. What would help you refocus?";
                    emotionType = "distracted";
                } else {
                    message = "I notice you're feeling " + helpData.emotion + ". How can I help?";
                    emotionType = helpData.emotion;
                }
                
                // Show the bot with COMBINED options
                showSpeakingBot(message, {
                    type: 'intervention',
                    autoClose: false,
                    showOptions: true,
                    options: this.getCombinedOptions(helpData),
                    emotion: emotionType
                });
                
                // Reset counters
                this.emotionInterventionData.negativeEmotionCount = 0;
                frustrationLevel = 0;
            }

            getCombinedOptions(helpData) {
                // Base options
                let options = [
                    { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                    { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                ];
                
                // Add emotion-specific options
                if (helpData.emotion === "angry") {
                    options.unshift(
                        { text: "Make it easier", icon: "fa-thumbs-up", action: "easier", color: "var(--mickey-green)" }
                    );
                }
                
                if (helpData.emotion === "sad") {
                    options.unshift(
                        { text: "Tell me a joke", icon: "fa-grin-squint", action: "joke", color: "var(--mickey-blue)" }
                    );
                }
                
                // Add focus-specific options
                if (helpData.focus === "low") {
                    options.unshift(
                        { text: "Quick stretch", icon: "fa-running", action: "stretch", color: "var(--mickey-purple)" }
                    );
                }
                
                // Limit to 4 options
                return options.slice(0, 4);
            }

            drawFaceMesh(ctx, mesh, offsetX, offsetY, scaleX, scaleY) {
                if (!mesh || mesh.length === 0) return;
                
                // Draw facial landmarks
                ctx.fillStyle = 'rgba(255, 100, 255, 0.6)';
                mesh.forEach(point => {
                    if (point && point.length >= 2) {
                        const x = offsetX + point[0] * scaleX;
                        const y = offsetY + point[1] * scaleY;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            drawNoFace() {
                const ctx = this.eyeCtx;
                const width = this.eyeCanvas.width;
                const height = this.eyeCanvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw background
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, '#0a0a1a');
                gradient.addColorStop(1, '#16213e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Draw screen center target
                this.drawScreenCenterTarget(ctx, width, height);
                
                // Draw "no face" message
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No face detected', width / 2, height / 2);
            }
            
            drawScreenCenterTarget(ctx, width, height) {
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Draw target circle
                ctx.strokeStyle = '#95e1d3';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, 12, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw crosshair
                ctx.strokeStyle = 'rgba(149, 225, 211, 0.6)';
                ctx.lineWidth = 1.5;
                
                // Vertical line
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - 20);
                ctx.lineTo(centerX, centerY + 20);
                ctx.stroke();
                
                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(centerX - 20, centerY);
                ctx.lineTo(centerX + 20, centerY);
                ctx.stroke();
            }
            
            drawArrow(ctx, fromX, fromY, toX, toY, color) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length < 15) return;
                
                const angle = Math.atan2(dy, dx);
                const headLength = 8;
                const headWidth = 4;
                
                // Draw arrow line
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw arrow head
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - headLength * Math.cos(angle) + headWidth * Math.cos(angle - Math.PI/2),
                    toY - headLength * Math.sin(angle) + headWidth * Math.sin(angle - Math.PI/2)
                );
                ctx.lineTo(
                    toX - headLength * Math.cos(angle) + headWidth * Math.cos(angle + Math.PI/2),
                    toY - headLength * Math.sin(angle) + headWidth * Math.sin(angle + Math.PI/2)
                );
                ctx.closePath();
                ctx.fill();
            }
            
            updateMickeyAgent(face) {
                if (!face) return;
                
                // Get current emotion
                const dominantEmotion = this.getDominantEmotion(face);
                this.studentEmotion = dominantEmotion.name;
                
                // Update focus calculation
                this.calculateFocus();
                
                // USE THE COMBINED FORMULA
                const helpDecision = this.calculateCombinedHelpScore();
                
                // Check if we need to intervene
                if (helpDecision.helpNeeded && !mickeyAgentVisible) {
                    console.log(` COMBINED INTERVENTION: Score=${helpDecision.score.toFixed(1)}`);
                    console.log(`   Emotion: ${helpDecision.emotion}, Focus: ${helpDecision.focus}`);
                    
                    this.triggerCombinedIntervention(helpDecision);
                }
            }
            
            trackEmotionForIntervention(emotion) {
                const now = Date.now();
                
                // Add to history
                this.emotionInterventionData.emotionHistory.push({
                    emotion: emotion,
                    timestamp: now
                });
                
                // Keep only recent history (last 10 seconds)
                this.emotionInterventionData.emotionHistory = this.emotionInterventionData.emotionHistory.filter(
                    entry => (now - entry.timestamp) < 10000
                );
                
                // Count negative emotions
                const negativeEmotions = this.emotionInterventionData.emotionHistory.filter(
                    entry => ['angry', 'sad', 'confused'].includes(entry.emotion)
                ).length;
                
                this.emotionInterventionData.negativeEmotionCount = negativeEmotions;
                
                // Check if we need to intervene
                if (negativeEmotions >= this.emotionInterventionData.NEGATIVE_THRESHOLD && 
                    (now - this.emotionInterventionData.lastInterventionTime) > this.emotionInterventionData.interventionCooldown) {
                    
                    this.triggerEmotionIntervention(emotion);
                }
            }

            triggerEmotionIntervention(emotion) {
                const now = Date.now();
                this.emotionInterventionData.lastInterventionTime = now;
                
                // Get intervention data for this emotion
                const interventionData = botPhrases.intervention[emotion] || botPhrases.intervention.frustrated;
                
                // Show interactive intervention with immediate buttons
                this.showInteractiveIntervention(interventionData, emotion);
                
                // Reset negative count after intervention
                this.emotionInterventionData.negativeEmotionCount = 0;
                
                console.log(` Interactive intervention triggered for: ${emotion}`);
            } 

            showInteractiveIntervention(interventionData, emotion) {
                // Show the bot with message AND buttons immediately
                showSpeakingBot(interventionData.message, {
                    type: 'intervention',
                    autoClose: false,
                    showOptions: true,
                    options: interventionData.options,
                    emotion: emotion
                });
            }

            updateEmotionWithSmoothing(newEmotion, confidence) {
                const now = Date.now();
                
                this.emotionHistory.push({
                    emotion: newEmotion,
                    confidence: confidence,
                    timestamp: now
                });
                
                while (this.emotionHistory.length > this.MAX_HISTORY) {
                    this.emotionHistory.shift();
                }
                
                if (this.emotionHistory.length >= 3) {
                    const recentEmotions = this.emotionHistory.slice(-5);
                    const emotionCounts = {};
                    
                    recentEmotions.forEach((entry, index) => {
                        const weight = 0.7 * (index / recentEmotions.length);
                        emotionCounts[entry.emotion] = (emotionCounts[entry.emotion] || 0) + weight;
                    });
                    
                    let smoothedEmotion = newEmotion;
                    let maxCount = 0;
                    
                    for (const [emote, count] of Object.entries(emotionCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            smoothedEmotion = emote;
                        }
                    }
                    
                    if (maxCount > 0.6 && smoothedEmotion !== newEmotion) {
                        newEmotion = smoothedEmotion;
                    }
                }
                
                this.studentEmotion = newEmotion;
            }
            
            showSuccess(message) {
                this.updateStatusPanel('success', message);
            }
            
            showError(message) {
                this.updateStatusPanel('error', message);
            }
            
            showInfo(message) {
                this.updateStatusPanel('info', message);
            }
            
            updateStatusPanel(type, message) {
                const statusPanel = document.getElementById('detection-status');
                if (!statusPanel) return;
                
                let icon = 'fa-magic';
                let title = 'ENHANCED EMOTION & EYE TRACKING';
                let color = 'var(--mickey-black)';
                
                switch(type) {
                    case 'success':
                        icon = 'fa-check-circle';
                        color = 'var(--mickey-green)';
                        break;
                    case 'error':
                        icon = 'fa-exclamation-circle';
                        color = 'var(--mickey-red)';
                        break;
                    case 'info':
                        icon = 'fa-info-circle';
                        color = 'var(--mickey-blue)';
                        break;
                }
                
                statusPanel.innerHTML = `
                    <div class="status-header">
                        <div class="status-icon" style="color: ${color};">
                            <i class="fas ${icon}"></i>
                        </div>
                        <div class="status-title">
                            ${title}
                        </div>
                    </div>
                    <div class="status-message">
                        ${message}
                    </div>
                `;
            }

            calculateCombinedHelpScore() {
                // 1. EMOTION SCORE (0-100)
                let emotionScore = 0;
                if (this.studentEmotion === "angry") emotionScore = 90;
                else if (this.studentEmotion === "sad") emotionScore = 70;
                else if (this.studentEmotion === "confused") emotionScore = 50;
                else emotionScore = 20; // neutral/happy
                
                // 2. EYE FOCUS SCORE (0-100)
                const eyeFocusScore = this.focusData.focusScore || 0;
                
                // 3. COMBINE THEM: 60% emotion, 40% eye focus
                const combinedScore = (emotionScore * 0.6) + (eyeFocusScore * 0.4);
                
                // 4. FRUSTRATION HISTORY (last 10 seconds)
                const recentFrustration = this.emotionInterventionData.negativeEmotionCount;
                
                // 5. FINAL DECISION: Should we help?
                if (combinedScore >= 60 || recentFrustration >= 2) {
                    return {
                        helpNeeded: true,
                        score: combinedScore,
                        mainReason: combinedScore >= 60 ? "low_attention" : "frustrated",
                        emotion: this.studentEmotion,
                        focus: this.focusData.overallFocus
                    };
                }
                
                return { helpNeeded: false, score: combinedScore };
            }
        }

        // Initialize dual camera detection
        let dualCameraDetection = null;

        // ============================================
        // PAGE VISIBILITY API (BUILT INTO BROWSER)
        // ============================================

        class TabFocusTracker {
            constructor() {
                this.isTabActive = true;
                this.tabSwitchCount = 0;
                this.lastTabSwitchTime = Date.now();
                this.totalTimeInactive = 0;
                this.startTime = Date.now();
                
                this.init();
            }
            
            init() {
                // Listen for visibility changes
                document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
                
                // Listen for window blur/focus (when switching windows)
                window.addEventListener('blur', () => this.handleWindowBlur());
                window.addEventListener('focus', () => this.handleWindowFocus());
                
                // Listen for page show/hide (for mobile)
                window.addEventListener('pageshow', () => this.handlePageShow());
                window.addEventListener('pagehide', () => this.handlePageHide());
            }
            
            handleVisibilityChange() {
                if (document.hidden) {
                    // Tab/window became inactive
                    this.isTabActive = false;
                    this.tabSwitchCount++;
                    this.lastTabSwitchTime = Date.now();
                    
                    console.log(' Tab switched away!');
                    this.triggerTabSwitchAlert();
                } else {
                    // Tab/window became active again
                    const inactiveDuration = Date.now() - this.lastTabSwitchTime;
                    this.totalTimeInactive += inactiveDuration;
                    this.isTabActive = true;
                    
                    console.log(` Tab back after ${Math.round(inactiveDuration/1000)} seconds`);
                }
            }
            
            handleWindowBlur() {
                console.log(' Window lost focus');
                this.isTabActive = false;
                this.tabSwitchCount++;
                this.lastTabSwitchTime = Date.now();
            }
            
            handleWindowFocus() {
                const inactiveDuration = Date.now() - this.lastTabSwitchTime;
                this.totalTimeInactive += inactiveDuration;
                this.isTabActive = true;
                console.log(' Window regained focus');
            }
            
            handlePageShow() {
                this.isTabActive = true;
            }
            
            handlePageHide() {
                this.isTabActive = false;
                this.tabSwitchCount++;
                this.lastTabSwitchTime = Date.now();
            }
            
            triggerTabSwitchAlert() {
                // Show immediate alert
                if (voiceEnabled) {
                    speakText("Please stay focused on your learning!");
                }
                
                // Show visual notification
                showNotification(
                    "Focus Alert! ",
                    "Please return to your learning activity",
                    "warning"
                );
                
                // Deduct points
                this.deductPointsForTabSwitch();
                
                // Log for teacher/parent review
                this.logTabSwitchEvent();
            }
            
            deductPointsForTabSwitch() {
                const deduction = 10; // Points to deduct
                studentScore = Math.max(0, studentScore - deduction);
                
                // Update display
                if (document.getElementById('student-points')) {
                    document.getElementById('student-points').textContent = studentScore;
                }
                
                console.log(` Deducted ${deduction} points for tab switching. New score: ${studentScore}`);
                
                // Show deduction message
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 150px;
                    right: 30px;
                    background: var(--mickey-red);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 15px;
                    border: 3px solid var(--mickey-black);
                    z-index: 10000;
                    animation: slideInRight 0.3s ease;
                    font-family: 'Fredoka One', cursive;
                `;
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <div>
                            <strong>-${deduction} Mickey Points</strong><br>
                            <small>Stay focused on your learning!</small>
                        </div>
                    </div>
                `;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }
            
            logTabSwitchEvent() {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    event: 'tab_switch',
                    duration: Date.now() - this.lastTabSwitchTime,
                    currentScore: studentScore,
                    totalSwitches: this.tabSwitchCount,
                    totalInactiveTime: this.totalTimeInactive
                };
                
                // Save to localStorage for session tracking
                let sessionLog = JSON.parse(localStorage.getItem('focusLog') || '[]');
                sessionLog.push(logEntry);
                localStorage.setItem('focusLog', JSON.stringify(sessionLog));
                
                console.log(' Tab switch logged:', logEntry);
            }
            
            getFocusReport() {
                const sessionDuration = Date.now() - this.startTime;
                const focusPercentage = ((sessionDuration - this.totalTimeInactive) / sessionDuration * 100) || 100;
                
                return {
                    isTabActive: this.isTabActive,
                    tabSwitchCount: this.tabSwitchCount,
                    totalInactiveTime: this.totalTimeInactive,
                    focusPercentage: Math.round(focusPercentage),
                    currentScore: studentScore,
                    lastSwitch: this.lastTabSwitchTime ? Date.now() - this.lastTabSwitchTime : 0
                };
            }
        }

        // Add at the top of your script
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                alert(" Please stay on the learning tab!");
                studentScore = Math.max(0, studentScore - 10);
                document.getElementById('student-points').textContent = studentScore;
            }
        });

        // ============================================
        // ENHANCED DUAL CAMERA DETECTION SYSTEM
        // ============================================

        class EnhancedFocusDetection {
            constructor() {
                this.tabTracker = new TabFocusTracker();
                this.eyeTracker = new EyeFocusTracker(); // Your existing eye tracking
                this.keyboardActivity = new KeyboardTracker();
                this.mouseActivity = new MouseTracker();
                
                this.focusScores = {
                    tabFocus: 100,      // Most important - 40% weight
                    eyeFocus: 100,      // Secondary - 30% weight  
                    activityFocus: 100, // Keyboard/mouse - 30% weight
                };
            }
            
            calculateOverallFocus() {
                // Get individual scores
                const tabScore = this.calculateTabFocusScore();
                const eyeScore = this.calculateEyeFocusScore();
                const activityScore = this.calculateActivityScore();
                
                // Weighted average (Tab focus is most important!)
                const overallScore = 
                    (tabScore * 0.4) +      // 40% weight - tab staying
                    (eyeScore * 0.3) +      // 30% weight - eye position
                    (activityScore * 0.3);   // 30% weight - keyboard/mouse
                
                return {
                    score: Math.round(overallScore),
                    level: this.getFocusLevel(overallScore),
                    details: {
                        tabScore,
                        eyeScore,
                        activityScore,
                        tabSwitches: this.tabTracker.tabSwitchCount,
                        isCurrentlyActive: this.tabTracker.isTabActive
                    }
                };
            }
            
            calculateTabFocusScore() {
                const report = this.tabTracker.getFocusReport();
                
                // Base score starts at 100
                let score = 100;
                
                // Deduct for each tab switch
                score -= (this.tabTracker.tabSwitchCount * 5); // -5 points per switch
                
                // Deduct for total inactive time
                const inactiveMinutes = report.totalInactiveTime / (1000 * 60);
                score -= (inactiveMinutes * 2); // -2 points per minute away
                
                // Big penalty if currently not in tab
                if (!this.tabTracker.isTabActive) {
                    score -= 30;
                }
                
                return Math.max(0, Math.min(100, score));
            }
            
            calculateEyeFocusScore() {
                // Your existing eye tracking logic
                // But with reduced importance now
                return this.eyeTracker.getFocusScore();
            }
            
            calculateActivityScore() {
                // Track keyboard and mouse activity
                return this.keyboardActivity.getScore() * 0.5 + 
                    this.mouseActivity.getScore() * 0.5;
            }
            
            getFocusLevel(score) {
                if (score >= 85) return 'excellent';
                if (score >= 70) return 'good';
                if (score >= 50) return 'fair';
                return 'poor';
            }
            
            // Add to your existing DualCameraDetection class
            integrateWithCameraDetection() {
                // Check every 5 seconds
                setInterval(() => {
                    const focusReport = this.calculateOverallFocus();
                    
                    // If tab is inactive for too long, trigger strong intervention
                    if (!this.tabTracker.isTabActive) {
                        const timeAway = Date.now() - this.tabTracker.lastTabSwitchTime;
                        
                        if (timeAway > 30000) { // 30 seconds away
                            this.triggerSeriousIntervention();
                        } else if (timeAway > 10000) { // 10 seconds away
                            this.triggerMildIntervention();
                        }
                    }
                    
                    // Update UI
                    this.updateFocusDisplay(focusReport);
                    
                }, 5000);
            }
            
            triggerSeriousIntervention() {
                // Stop any current activity
                if (currentGame) {
                    pauseCurrentGame();
                }
                
                // Show full-screen warning
                const warning = document.createElement('div');
                warning.id = 'serious-focus-warning';
                warning.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(255, 50, 50, 0.95);
                    z-index: 99999;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    text-align: center;
                    font-family: 'Fredoka One', cursive;
                    animation: pulseWarning 1s infinite;
                `;
                
                warning.innerHTML = `
                    <div style="font-size: 4rem; margin-bottom: 20px;">
                        
                    </div>
                    <h1 style="color: white; font-size: 2.5rem;">
                        RETURN TO LEARNING!
                    </h1>
                    <p style="font-size: 1.5rem; margin: 20px 0;">
                        You've been away for too long!
                    </p>
                    <div style="background: white; color: red; padding: 20px; border-radius: 15px; margin: 20px 0;">
                        <h3 style="margin: 0;">-50 Mickey Points</h3>
                        <p style="margin: 10px 0 0 0;">Please return to continue learning</p>
                    </div>
                    <button onclick="document.getElementById('serious-focus-warning').remove(); 
                                    resumeLearning();" 
                            style="padding: 15px 30px; background: white; color: red; 
                                border: none; border-radius: 10px; font-size: 1.2rem;
                                cursor: pointer; margin-top: 20px;">
                        I'm Back! Continue Learning
                    </button>
                `;
                
                document.body.appendChild(warning);
                
                // Deduct significant points
                studentScore = Math.max(0, studentScore - 50);
                updateScoreDisplay();
                
                // Speak warning
                speakText("Warning! Please return to your learning immediately!");
            }
        }

        // 3. Initialize the Tab Tracker
        let tabTracker = null;

        function initTabFocusTracking() {
            tabTracker = new TabFocusTracker();
            
            // Add to your existing initialization
            console.log(" Tab focus tracking initialized");
            
            // Prevent cheating by opening developer tools (optional)
            preventDevToolsCheating();
        }

        function preventDevToolsCheating() {
            // Detect if developer tools opens (students might try to disable tracking)
            const devToolsOpen = /./;
            devToolsOpen.toString = function() {
                console.warn(" Developer tools detected!");
                tabTracker.deductPointsForTabSwitch();
                return " Focus on learning, not developer tools!";
            };
            
            console.log(devToolsOpen);
        }

        // 4. Update Your Profile Display
        function updateFocusDisplayInProfile() {
            if (!tabTracker) return;
            
            const report = tabTracker.getFocusReport();
            
            const focusHTML = `
                <div style="background: var(--mickey-white); padding: 20px; border-radius: 15px; 
                            border: 4px solid var(--mickey-black); margin-bottom: 20px;">
                    <h3 style="color: var(--mickey-red); margin-top: 0;">
                        <i class="fas fa-desktop"></i> Tab Focus Tracker
                    </h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
                        <div style="background: ${report.isTabActive ? '#95e1d3' : '#ff6b8b'}; 
                                    padding: 15px; border-radius: 10px; border: 3px solid var(--mickey-black); text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">
                                ${report.isTabActive ? ' ACTIVE' : ' INACTIVE'}
                            </div>
                            <div style="font-size: 0.9rem;">
                                Current Tab Status
                            </div>
                        </div>
                        
                        <div style="background: var(--mickey-yellow); padding: 15px; 
                                    border-radius: 10px; border: 3px solid var(--mickey-black); text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--mickey-red);">
                                ${report.tabSwitchCount}
                            </div>
                            <div style="font-size: 0.9rem;">
                                Tab Switches
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: var(--mickey-blue); color: white; padding: 10px; 
                                border-radius: 10px; margin-top: 10px; text-align: center;">
                        <i class="fas fa-info-circle"></i>
                        <strong>Focus Score:</strong> ${report.focusPercentage}%
                        <br>
                        <small>${report.tabSwitchCount > 0 ? 
                            `Lost ${report.tabSwitchCount * 10} points for switching tabs` : 
                            'Great focus! Keep it up!'}</small>
                    </div>
                </div>
            `;
            
            // Add to profile or create new section
            const profileContent = document.getElementById('profile-content-area') || 
                                document.querySelector('.profile-content');
            if (profileContent) {
                const existingTracker = profileContent.querySelector('.tab-tracker-display');
                if (existingTracker) {
                    existingTracker.innerHTML = focusHTML;
                } else {
                    const trackerDiv = document.createElement('div');
                    trackerDiv.className = 'tab-tracker-display';
                    trackerDiv.innerHTML = focusHTML;
                    profileContent.querySelector('.student-profile').appendChild(trackerDiv);
                }
            }
        }

        // ============================================
        // INDEPENDENT SPEAKING BOT SYSTEM
        // ============================================

        // Bot speaking queue system
        const botSpeakingQueue = {
            messages: [],
            isSpeaking: false,
            currentUtterance: null,
            currentCallback: null,
            autoClose: true
        };

        // Common bot phrases for different scenarios
        const botPhrases = {
            welcome: [
                "Welcome back! Ready for some learning fun?",
                "Great to see you again! Let's continue our adventure!",
                "Hello there! I'm excited to help you learn today!"
            ],
            
            intervention: {
                angry: {
                    message: "I notice you're feeling frustrated. How can I help you feel better?",
                    options: [
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                        { text: "Make it easier", icon: "fa-thumbs-up", action: "easier", color: "var(--mickey-green)" },
                        { text: "Skip this", icon: "fa-forward", action: "skip", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                sad: {
                    message: "I see you're feeling a bit down. What would help you feel better?",
                    options: [
                        { text: "Tell me a joke", icon: "fa-grin-squint", action: "joke", color: "var(--mickey-pink)" },
                        { text: "Different activity", icon: "fa-random", action: "different", color: "var(--mickey-green)" },
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                confused: {
                    message: "This seems confusing. How can I help you understand better?",
                    options: [
                        { text: "Explain differently", icon: "fa-comment-alt", action: "explain", color: "var(--mickey-pink)" },
                        { text: "Give me a hint", icon: "fa-lightbulb", action: "hint", color: "var(--mickey-green)" },
                        { text: "Go back to basics", icon: "fa-undo", action: "basics", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                frustrated: {
                    message: "This seems tricky. What would you like to do?",
                    options: [
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                        { text: "Make it easier", icon: "fa-thumbs-up", action: "easier", color: "var(--mickey-green)" },
                        { text: "Give me a hint", icon: "fa-lightbulb", action: "hint", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                distracted: {
                    message: "I notice your attention drifting. What would help you refocus?",
                    options: [
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                        { text: "Do a quick stretch", icon: "fa-running", action: "stretch", color: "var(--mickey-green)" },
                        { text: "Switch activity", icon: "fa-random", action: "different", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                }
            },
            
            greeting: [
                "Yes! How may I help you?",
                "I'm here! What can I do for you?",
                "Hello! What would you like to know?",
                "How can I assist you today?"
            ],
            
            encouragement: [
                "You're doing amazing! Keep up the great work!",
                "Wow! I'm so impressed with your progress!",
                "You're getting better every time! I'm so proud of you!",
                "That was fantastic! You're a natural at this!"
            ],
            
            correction: [
                "That's okay! Let's try it again together.",
                "Almost there! Try one more time.",
                "Good effort! Now let me show you the right way.",
                "Not quite, but you're getting closer!"
            ],
            
            break: [
                "Time for a quick break! Let's stretch and come back refreshed!",
                "Great work so far! How about a 30-second break?",
                "You've been working hard! Let's take a moment to relax."
            ],
            
            gameComplete: [
                "Congratulations! You completed the game! You're a superstar!",
                "Amazing job! You finished all the activities!",
                "Hooray! You did it! I'm so proud of you!"
            ]
        };

        // Initialize the speaking bot system
        function initSpeakingBot() {
            console.log("Initializing speaking bot system...");
            
            // Continue button
            const continueBtn = document.getElementById('bot-speaker-continue');
            if (continueBtn) {
                continueBtn.addEventListener('click', hideSpeakingBot);
            }
            
            // Escape key to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('speaking-bot-overlay').style.display === 'block') {
                    hideSpeakingBot();
                }
            });
            
            // Click outside to close (only when autoClose is false)
            const overlay = document.getElementById('speaking-bot-overlay');
            if (overlay) {
                overlay.addEventListener('click', function(e) {
                    if (e.target === this && !botSpeakingQueue.autoClose) {
                        hideSpeakingBot();
                    }
                });
            }
            
            // Speak welcome message if just logged in
            const userRole = localStorage.getItem('userRole');
            if (userRole) {
                setTimeout(() => {
                    speakWelcomeMessage();
                }, 1000);
            }
            
            console.log(" Speaking bot system initialized!");
        }

        // Handle clicking on the speaking bot bubble
        function handleSpeakingBotClick() {
            // If bot is currently speaking, stop it
            if (botSpeakingQueue.isSpeaking) {
                stopBotSpeaking();
                hideSpeakingBot();
                return;
            }
            
            // If bot was just speaking and closed, show greeting
            if (document.getElementById('speaking-bot-overlay').style.display === 'none') {
                speakBotGreeting();
            }
        }

        // Show the speaking bot overlay
        function showSpeakingBot(message, options = {}) {
            const overlay = document.getElementById('speaking-bot-overlay');
            const container = document.getElementById('speaking-bot-container');
            const statusText = document.getElementById('bot-speaker-status-text');
            const continueBtn = document.getElementById('bot-speaker-continue');
            const sideBubble = document.getElementById('side-speaking-bot');
            
            // Set options
            const settings = {
                autoClose: options.autoClose !== undefined ? options.autoClose : true,
                onComplete: options.onComplete || null,
                type: options.type || 'info',
                duration: options.duration || 3000,
                showOptions: options.showOptions || false,
                botOptions: options.options || [],
                emotion: options.emotion || null
            };
            
            botSpeakingQueue.autoClose = settings.autoClose;
            botSpeakingQueue.currentCallback = settings.onComplete;
            
            // Update side bubble state
            if (sideBubble) {
                sideBubble.classList.add('active');
            }
            
            // Hide message indicator
            hideBotMessageIndicator();
            
            // Show overlay
            overlay.style.display = 'block';
            container.classList.add('speaking');
            
            // Update status text
            if (statusText) {
                statusText.textContent = getStatusText(settings.type);
            }
            
            // Hide continue button initially
            continueBtn.classList.remove('show');
            
            // Show options immediately if specified
            if (settings.showOptions && settings.botOptions.length > 0) {
                this.createInterventionOptions(settings.botOptions, settings.emotion);
            }
            
            // Start speaking
            speakBotMessage(message, settings);
        }

        function createInterventionOptions(options, emotion) {
            const botStatus = document.getElementById('bot-speaker-status');
            if (!botStatus) return;
            
            // Remove any existing options
            const existingOptions = document.getElementById('intervention-options');
            if (existingOptions) {
                existingOptions.remove();
            }
            
            // Create options container
            const optionsContainer = document.createElement('div');
            optionsContainer.id = 'intervention-options';
            optionsContainer.className = 'intervention-options';
            optionsContainer.style.cssText = `
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
                margin-top: 1000px;
                width: 100%;
                animation: slideUp 0.3s ease;
            `;
            
            // Create option buttons
            options.forEach((option, index) => {
                const optionBtn = document.createElement('button');
                optionBtn.className = 'intervention-option-btn';
                optionBtn.style.cssText = `
                    padding: 12px 8px;
                    background: ${option.color || 'var(--mickey-white)'};
                    color: var(--mickey-black);
                    border: 3px solid var(--mickey-black);
                    border-radius: 15px;
                    font-family: 'Fredoka One', cursive;
                    cursor: pointer;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    gap: 8px;
                    transition: all 0.3s;
                    font-size: 0.8rem;
                    min-height: 60px;
                `;
                
                optionBtn.innerHTML = `
                    <i class="fas ${option.icon}" style="font-size: 1.2rem;"></i>
                    <span>${option.text}</span>
                `;
                
                // Add hover effects
                optionBtn.addEventListener('mouseenter', () => {
                    optionBtn.style.transform = 'translateY(-3px)';
                    optionBtn.style.boxShadow = '0 5px 0 var(--mickey-black)';
                });
                
                optionBtn.addEventListener('mouseleave', () => {
                    optionBtn.style.transform = 'translateY(0)';
                    optionBtn.style.boxShadow = 'none';
                });
                
                // Add click handler
                optionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleInterventionChoice(option.action, emotion);
                });
                
                optionsContainer.appendChild(optionBtn);
            });
            
            // Add to bot status container
            botStatus.appendChild(optionsContainer);
        }

        // Global function to handle intervention choices
        function handleInterventionChoice(choice, emotion) {
            console.log(`User chose intervention: ${choice} for emotion: ${emotion}`);
            
            let responseMessage = "";
            let actionFunction = null;
            
            switch(choice) {
                case 'break':
                    responseMessage = "Great idea! Let's take a quick break.";
                    actionFunction = () => startMickeyBreak();
                    break;
                    
                case 'easier':
                    responseMessage = "I'll make this easier for you!";
                    actionFunction = () => makeGameEasier();
                    break;
                    
                case 'skip':
                    responseMessage = "Let's skip this and move to the next one!";
                    actionFunction = () => skipToNext();
                    break;
                    
                case 'continue':
                    responseMessage = "Glad you're okay! Let's continue!";
                    break;
                    
                case 'joke':
                    responseMessage = tellAJoke();
                    break;
                    
                case 'different':
                    responseMessage = "Let's try a different activity!";
                    actionFunction = () => switchToDifferentActivity();
                    break;
                    
                case 'explain':
                    responseMessage = "Let me explain this in a different way...";
                    actionFunction = () => explainDifferently();
                    break;
                    
                case 'hint':
                    responseMessage = "Here's a hint to help you...";
                    actionFunction = () => giveHint();
                    break;
                    
                case 'basics':
                    responseMessage = "Let's go back to the basics and build up!";
                    actionFunction = () => goBackToBasics();
                    break;
                    
                case 'stretch':
                    responseMessage = "Great! Let's do a quick stretch together!";
                    actionFunction = () => doQuickStretch();
                    break;
                    
                default:
                    responseMessage = "Let's continue then!";
            }
            
            // Remove options
            const optionsContainer = document.getElementById('intervention-options');
            if (optionsContainer) {
                optionsContainer.remove();
            }
            
            // Speak the response
            queueBotMessage(responseMessage, {
                type: 'info',
                autoClose: true,
                duration: 2000,
                onComplete: () => {
                    // Execute the action after speaking
                    if (actionFunction) {
                        setTimeout(actionFunction, 500);
                    }
                }
            });
        }

        // Hide the speaking bot
        function hideSpeakingBot() {
            const overlay = document.getElementById('speaking-bot-overlay');
            const container = document.getElementById('speaking-bot-container');
            const continueBtn = document.getElementById('bot-speaker-continue');
            const sideBubble = document.getElementById('side-speaking-bot');
            
            // Stop any ongoing speech
            stopBotSpeaking();
            
            // Remove options if they exist
            const optionsContainer = document.getElementById('intervention-options');
            if (optionsContainer) {
                optionsContainer.remove();
            }
            
            // Update side bubble state
            if (sideBubble) {
                sideBubble.classList.remove('active');
                
                // Show message indicator if there are queued messages
                if (botSpeakingQueue.messages.length > 0) {
                    showBotMessageIndicator();
                }
            }
            
            // Hide elements
            overlay.style.display = 'none';
            container.classList.remove('speaking');
            continueBtn.classList.remove('show');
            
            // Clear queue if autoClose is true
            if (botSpeakingQueue.autoClose) {
                botSpeakingQueue.messages = [];
            }
            
            // Process next in queue
            processSpeakingQueue();
        }

        // Queue a message for the bot to speak
        function queueBotMessage(message, options = {}) {
            botSpeakingQueue.messages.push({
                message: message,
                options: options
            });
            
            // Show message indicator on side bubble
            if (!botSpeakingQueue.isSpeaking) {
                showBotMessageIndicator();
            }
            
            // Start processing if not already speaking
            if (!botSpeakingQueue.isSpeaking) {
                processSpeakingQueue();
            }
        }

        // Process the speaking queue
        function processSpeakingQueue() {
            if (botSpeakingQueue.messages.length === 0 || botSpeakingQueue.isSpeaking) {
                return;
            }
            
            const nextItem = botSpeakingQueue.messages.shift();
            showSpeakingBot(nextItem.message, nextItem.options);
        }

        // Core speaking function
        function speakBotMessage(message, settings) {
            if (!voiceEnabled) {
                // If voice is disabled, just show the bot briefly
                setTimeout(() => {
                    completeSpeaking(settings);
                }, 2000);
                return;
            }
            
            botSpeakingQueue.isSpeaking = true;
            
            // Create speech synthesis utterance
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.rate = 0.9;
            utterance.pitch = 1.2;
            utterance.volume = 1;
            
            // Try to get a friendly voice
            const voices = speechSynthesis.getVoices();
            const friendlyVoice = voices.find(voice => 
                voice.name.includes('Child') || 
                voice.name.includes('Kids') ||
                voice.lang.includes('en')
            );
            
            if (friendlyVoice) {
                utterance.voice = friendlyVoice;
            }
            
            // Event handlers
            utterance.onstart = function() {
                onSpeechStart(settings);
            };
            
            utterance.onend = function() {
                completeSpeaking(settings);
            };
            
            utterance.onerror = function() {
                completeSpeaking(settings);
            };
            
            // Start speaking
            botSpeakingQueue.currentUtterance = utterance;
            speechSynthesis.speak(utterance);
            
            // Animate volume bar
            animateVoiceWaves();
        }

        // Function called when speech starts
        function onSpeechStart(settings) {
            const container = document.getElementById('speaking-bot-container');
            const waves = document.getElementById('speaker-waves');
            
            if (container) container.classList.add('speaking');
            if (waves) waves.style.display = 'block';
        }

        // Function called when speech completes
        function completeSpeaking(settings) {
            const continueBtn = document.getElementById('bot-speaker-continue');
            
            // Update UI
            const container = document.getElementById('speaking-bot-container');
            const waves = document.getElementById('speaker-waves');
            const statusText = document.getElementById('bot-speaker-status-text');
            
            if (container) container.classList.remove('speaking');
            if (waves) waves.style.display = 'none';
            if (statusText) statusText.textContent = "Ready!";
            
            // Show continue button if autoClose is false AND no options are shown
            const hasOptions = document.getElementById('intervention-options');
            if (!botSpeakingQueue.autoClose && continueBtn && !hasOptions) {
                continueBtn.classList.add('show');
            }
            
            // Call callback if provided
            if (botSpeakingQueue.currentCallback) {
                botSpeakingQueue.currentCallback();
                botSpeakingQueue.currentCallback = null;
            }
            
            // Mark as not speaking
            botSpeakingQueue.isSpeaking = false;
            botSpeakingQueue.currentUtterance = null;
            
            // Auto hide if enabled and no options
            if (botSpeakingQueue.autoClose && !hasOptions) {
                setTimeout(() => {
                    if (!botSpeakingQueue.isSpeaking) {
                        hideSpeakingBot();
                    }
                }, 1000);
            }
            
            // Process next in queue
            setTimeout(processSpeakingQueue, 500);
        }

        // Stop current speaking
        function stopBotSpeaking() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            if (botSpeakingQueue.currentUtterance) {
                speechSynthesis.cancel();
                botSpeakingQueue.currentUtterance = null;
            }
            
            botSpeakingQueue.isSpeaking = false;
        }

        // Animate volume bar during speech
        function animateVoiceWaves() {
            const voiceBars = document.querySelectorAll('.voice-wave-bar');
            if (!voiceBars.length) return;
            
            let animationInterval = setInterval(() => {
                if (!botSpeakingQueue.isSpeaking) {
                    clearInterval(animationInterval);
                    resetVoiceWaves();
                    return;
                }
                
                // Animate each bar with random heights
                voiceBars.forEach((bar, index) => {
                    const delay = index * 0.1;
                    const height = 10 + Math.random() * 20;
                    
                    setTimeout(() => {
                        bar.style.height = `${height}px`;
                        bar.style.opacity = 0.5 + Math.random() * 0.5;
                    }, delay * 100);
                });
                
            }, 200);
        }

        // Reset voice waves to initial state
        function resetVoiceWaves() {
            const voiceBars = document.querySelectorAll('.voice-wave-bar');
            voiceBars.forEach(bar => {
                bar.style.height = '10px';
                bar.style.opacity = '0.5';
            });
        }

        // Get appropriate status text based on type
        function getStatusText(type) {
            switch(type) {
                case 'welcome': return "Welcoming you...";
                case 'greeting': return "How can I help?";
                case 'intervention': return "Offering help...";
                case 'encouragement': return "Cheering you on!";
                case 'correction': return "Helping out...";
                case 'break': return "Suggesting a break...";
                case 'complete': return "Celebrating!";
                default: return "Speaking...";
            }
        }

        // Show message indicator on side bubble
        function showBotMessageIndicator() {
            const sideBubble = document.getElementById('side-speaking-bot');
            const indicator = document.getElementById('bot-message-indicator');
            
            if (sideBubble && indicator) {
                sideBubble.classList.add('has-message');
                indicator.style.display = 'block';
            }
        }

        // Hide message indicator
        function hideBotMessageIndicator() {
            const sideBubble = document.getElementById('side-speaking-bot');
            const indicator = document.getElementById('bot-message-indicator');
            
            if (sideBubble && indicator) {
                sideBubble.classList.remove('has-message');
                indicator.style.display = 'none';
            }
        }

        // ============================================
        // HELPER FUNCTIONS TO USE THE SPEAKING BOT
        // ============================================

        // Welcome message (after login)
        function speakWelcomeMessage() {
            const message = botPhrases.welcome[Math.floor(Math.random() * botPhrases.welcome.length)];
            queueBotMessage(message, {
                type: 'welcome',
                autoClose: true,
                onComplete: function() {
                    // Show regular Mickey agent after welcome
                    setTimeout(() => {
                        // You can add back your Mickey agent here if needed
                    }, 500);
                }
            });
        }

        // Greeting message (when clicking the bot)
        function speakBotGreeting() {
            const message = botPhrases.greeting[Math.floor(Math.random() * botPhrases.greeting.length)];
            queueBotMessage(message, {
                type: 'greeting',
                autoClose: false,
                onComplete: function() {
                    // After greeting, the bot stays open for user to respond
                }
            });
        }

        // Intervention message (when frustrated/confused)
        function speakIntervention(emotion = 'frustrated') {
            const messages = botPhrases.intervention[emotion] || botPhrases.intervention.frustrated;
            const message = messages[Math.floor(Math.random() * messages.length)];
            
            queueBotMessage(message, {
                type: 'intervention',
                autoClose: false,
                onComplete: function() {
                    // Keep bot open for user response
                }
            });
        }

        // Encouragement message
        function speakEncouragement() {
            const message = botPhrases.encouragement[Math.floor(Math.random() * botPhrases.encouragement.length)];
            queueBotMessage(message, {
                type: 'encouragement',
                autoClose: true
            });
        }

        // Game completion
        function speakGameComplete() {
            const message = botPhrases.gameComplete[Math.floor(Math.random() * botPhrases.gameComplete.length)];
            queueBotMessage(message, {
                type: 'complete',
                autoClose: true
            });
        }

        // ============================================
        // TRACING ENGINE
        // ============================================

        class LetterTracingEngine {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.points = [];
                this.targetPath = [];
                this.currentLetter = '';
                this.tolerance = 20;
                this.score = 0;
                this.maxScore = 100;
            }
            
            initialize(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                this.setupEventListeners();
                this.setupDrawingStyle();
                
                // Mobile optimization
                if ('ontouchstart' in window) {
                    this.tolerance = 30;
                }
            }
            
            setupDrawingStyle() {
                this.ctx.lineWidth = 8;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#ff6b8b';
                this.ctx.fillStyle = '#ff6b8b';
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.draw.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseout', this.stopDrawing.bind(this));
                
                // Touch events
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.canvas.addEventListener('touchend', this.stopDrawing.bind(this));
                
                // Prevent scrolling on touch
                this.canvas.addEventListener('touchmove', (e) => {
                    if (e.scale !== 1) { e.preventDefault(); }
                }, { passive: false });
            }
            
            startDrawing(e) {
                this.isDrawing = true;
                const pos = this.getMousePos(e);
                [this.lastX, this.lastY] = [pos.x, pos.y];
                this.points.push({x: pos.x, y: pos.y});
                this.playSound('start');
            }
            
            draw(e) {
                if (!this.isDrawing) return;
                
                e.preventDefault();
                const pos = this.getMousePos(e);
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.lastX, this.lastY);
                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();
                
                this.points.push({x: pos.x, y: pos.y});
                [this.lastX, this.lastY] = [pos.x, pos.y];
            }
            
            stopDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                this.analyzeTrace();
                this.playSound('end');
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let x, y;
                
                if (e.type.includes('touch')) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: x * scaleX,
                    y: y * scaleY
                };
            }
            
            setTargetLetter(letter, strokePath) {
                this.currentLetter = letter;
                this.targetPath = strokePath;
                this.drawGuideLines();
                this.placeStartDot();
            }
            
            drawGuideLines() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                this.ctx.strokeStyle = '#CCCCCC';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.lineCap = 'round';
                
                if (this.targetPath.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.targetPath[0].x, this.targetPath[0].y);
                    
                    for (let i = 1; i < this.targetPath.length; i++) {
                        this.ctx.lineTo(this.targetPath[i].x, this.targetPath[i].y);
                    }
                    
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            placeStartDot() {
                if (this.targetPath.length > 0) {
                    const startDot = document.querySelector('.start-dot');
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const scaleX = canvasRect.width / this.canvas.width;
                    const scaleY = canvasRect.height / this.canvas.height;
                    
                    startDot.style.left = (this.targetPath[0].x * scaleX) + 'px';
                    startDot.style.top = (this.targetPath[0].y * scaleY) + 'px';
                }
            }
            
            analyzeTrace() {
                if (this.points.length < 2 || this.targetPath.length < 2) {
                    this.showFeedback("Try drawing something first!", "needs-improvement");
                    return;
                }
                
                let matchScore = 0;
                const totalPoints = Math.max(this.points.length, this.targetPath.length);
                
                for (let i = 0; i < Math.min(this.points.length, this.targetPath.length); i++) {
                    const tracePoint = this.points[i];
                    const targetPoint = this.targetPath[i];
                    
                    const distance = Math.sqrt(
                        Math.pow(tracePoint.x - targetPoint.x, 2) + 
                        Math.pow(tracePoint.y - targetPoint.y, 2)
                    );
                    
                    if (distance < this.tolerance) {
                        matchScore++;
                    }
                }
                
                const accuracy = Math.round((matchScore / totalPoints) * 100);
                this.score = accuracy;
                
                document.getElementById('trace-accuracy').textContent = accuracy + '%';
                document.getElementById('trace-progress').style.width = accuracy + '%';
                
                if (accuracy > 80) {
                    this.showFeedback(
                        "Excellent tracing! Perfect letter formation! ",
                        "success"
                    );
                    this.playSound('success');
                    
                    studentScore += 15;
                    document.getElementById('student-points').textContent = studentScore;
                    
                } else if (accuracy > 50) {
                    this.showFeedback(
                        "Good effort! Try to stay closer to the guide lines.",
                        "needs-improvement"
                    );
                } else {
                    this.showFeedback(
                        "Let's try again. Start from the green dot and follow the dotted line.",
                        "needs-improvement"
                    );
                }
                
                this.points = [];
            }
            
            showFeedback(message, type) {
                const feedback = document.getElementById('tracing-feedback');
                feedback.textContent = message;
                feedback.className = `tracing-feedback show ${type}`;
                
                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 3000);
            }
            
            playSound(type) {
                const sounds = {
                    start: 'https://assets.mixkit.co/sfx/preview/mixkit-pencil-writing-2444.mp3',
                    end: 'https://assets.mixkit.co/sfx/preview/mixkit-pencil-scribble-on-paper-2426.mp3',
                    success: 'https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3'
                };
                
                if (sounds[type]) {
                    const audio = new Audio(sounds[type]);
                    audio.volume = 0.3;
                    audio.play();
                }
            }
            
            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGuideLines();
                this.points = [];
                this.score = 0;
                
                document.getElementById('trace-accuracy').textContent = '0%';
                document.getElementById('trace-progress').style.width = '0%';
                
                const feedback = document.getElementById('tracing-feedback');
                feedback.classList.remove('show');
            }
            
            showDemo() {
                this.clearCanvas();
                
                this.ctx.save();
                this.ctx.strokeStyle = '#95e1d3';
                this.ctx.lineWidth = 6;
                this.ctx.lineCap = 'round';
                
                let i = 0;
                const animate = () => {
                    if (i < this.targetPath.length - 1) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.targetPath[i].x, this.targetPath[i].y);
                        this.ctx.lineTo(this.targetPath[i + 1].x, this.targetPath[i + 1].y);
                        this.ctx.stroke();
                        i++;
                        setTimeout(animate, 200);
                    }
                };
                
                animate();
                this.ctx.restore();
            }
        }

        const tracingEngine = new LetterTracingEngine();

        // ============================================
        // SIDE TOGGLE SYSTEM
        // ============================================

        function initSideToggle() {
            const sideToggle = document.getElementById('side-toggle');
            const sideBubbles = document.getElementById('side-bubbles');
            
            if (!sideToggle || !sideBubbles) {
                console.warn("Side toggle elements not found, skipping initialization");
                return;
            }
            
            let sideOpen = false;
            
            sideToggle.addEventListener('click', function(event) {
                event.stopPropagation();
                sideOpen = !sideOpen;
                
                if (sideOpen) {
                    sideBubbles.classList.add('show');
                    sideToggle.innerHTML = '<i class="fas fa-times"></i>';
                    sideToggle.style.background = 'var(--mickey-blue)';
                } else {
                    sideBubbles.classList.remove('show');
                    sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                    sideToggle.style.background = 'var(--mickey-red)';
                }
            });
            
            // Initialize bubble handlers
            initBubbleHandlers();
            
            document.addEventListener('click', function(event) {
                if (!event.target.closest('#side-collapsible') && sideOpen) {
                    sideBubbles.classList.remove('show');
                    sideOpen = false;
                    sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                    sideToggle.style.background = 'var(--mickey-red)';
                }
            });
        }

        function initBubbleHandlers() {
            // Emotion camera bubble
            const emotionBubble = document.getElementById('side-emotion-camera');
            if (emotionBubble) {
                emotionBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    // Open camera panel
                    openCameraPanel();
                    
                    // Toggle emotion detection
                    if (dualCameraDetection) {
                        dualCameraDetection.toggleEmotionDetection();
                    }
                    
                    closeSideBubbles();
                });
            }
            
            // Eye camera bubble
            const eyeBubble = document.getElementById('side-eye-camera');
            if (eyeBubble) {
                eyeBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    // Open camera panel
                    openCameraPanel();
                    
                    // Toggle eye detection
                    if (dualCameraDetection) {
                        dualCameraDetection.toggleEyeDetection();
                    }
                    
                    closeSideBubbles();
                });
            }
            
            // Speaking bot bubble
            const speakingBotBubble = document.getElementById('side-speaking-bot');
            if (speakingBotBubble) {
                speakingBotBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    handleSpeakingBotClick();
                    closeSideBubbles();
                });
                
                // Add message indicator to speaking bot bubble
                if (!document.getElementById('bot-message-indicator')) {
                    const messageIndicator = document.createElement('div');
                    messageIndicator.className = 'bot-message-indicator';
                    messageIndicator.id = 'bot-message-indicator';
                    speakingBotBubble.appendChild(messageIndicator);
                    speakingBotBubble.classList.add('has-message');
                }
            }
            
            // Close camera content button
            const closeCameraBtn = document.getElementById('close-camera-content');
            if (closeCameraBtn) {
                closeCameraBtn.addEventListener('click', function(event) {
                    event.stopPropagation();
                    closeCameraPanel();
                });
            }
        }

        function openCameraPanel() {
            document.querySelectorAll('.collapsible-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const cameraContent = document.getElementById('camera-content');
            if (cameraContent) {
                cameraContent.classList.add('active');
            }
        }

        function closeCameraPanel() {
            const cameraContent = document.getElementById('camera-content');
            if (cameraContent) {
                cameraContent.classList.remove('active');
            }
        }

        function closeSideBubbles() {
            const sideBubbles = document.getElementById('side-bubbles');
            if (sideBubbles) {
                sideBubbles.classList.remove('show');
            }
            
            const sideToggle = document.getElementById('side-toggle');
            if (sideToggle) {
                sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                sideToggle.style.background = 'var(--mickey-red)';
            }
        }

        // ============================================
        // WELCOME SCREEN FUNCTIONS
        // ============================================

        function showLoginForm() {
            document.getElementById('welcome-buttons').style.display = 'none';
            document.getElementById('register-form-container').style.display = 'none';
            document.getElementById('login-form-container').style.display = 'block';
            
            const formsContainer = document.getElementById('forms-container');
            formsContainer.scrollTop = 0;
        }

        function showRegisterForm() {
            document.getElementById('welcome-buttons').style.display = 'none';
            document.getElementById('login-form-container').style.display = 'none';
            document.getElementById('register-form-container').style.display = 'block';
            
            const formsContainer = document.getElementById('forms-container');
            formsContainer.scrollTop = 0;
        }

        function submitLogin() {
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;
            
            if (!username || !password) {
                alert("Please enter both username and password!");
                return;
            }
            
            if (username === 'student123' && password === 'student123') {
                localStorage.setItem('userRole', 'student');
                localStorage.setItem('username', username);
                
                // Hide welcome screen, show main interface
                document.getElementById('welcome-screen').style.display = 'none';
                document.body.classList.remove('welcome-active');
                
                // Initialize main system
                initMainSystem('student');
                
                // Speak welcome message
                setTimeout(() => {
                   speakWelcomeMessage() ;
                }, 300);
                
            } else if (username === 'teacher123' && password === 'teacher123') {
                localStorage.setItem('userRole', 'teacher');
                localStorage.setItem('username', username);
                
                // Hide welcome screen, show main interface
                document.getElementById('welcome-screen').style.display = 'none';
                document.body.classList.remove('welcome-active');
                
                // Initialize main system
                initMainSystem('teacher');
                
                // Speak welcome message
                setTimeout(() => {
                    speakText("Welcome back! Ready for some teaching fun?");
                }, 300);
                
            } else {
                alert("Invalid username or password!\n\nTry:\nStudent: student123 / student123\nTeacher: teacher123 / teacher123");
            }
        }

        function submitRegistration() {
            const name = document.getElementById('register-name').value;
            const username = document.getElementById('register-username').value;
            const password = document.getElementById('register-password').value;
            const role = document.getElementById('register-role').value;
            
            if (!name || !username || !password) {
                alert("Please fill in all required fields!");
                return;
            }
            
            if (password.length < 6) {
                alert("Password must be at least 6 characters!");
                return;
            }
            
            localStorage.setItem('userRole', role);
            localStorage.setItem('username', username);
            localStorage.setItem('userName', name);
            
            // Hide welcome screen, show main interface
            document.getElementById('welcome-screen').style.display = 'none';
            document.body.classList.remove('welcome-active');
            
            // Initialize main system
            initMainSystem(role);
            
            // Speak welcome message
            setTimeout(() => {
                speakText(`Welcome ${name}! Ready to start learning?`);
            }, 300);
        }

        // ============================================
        // MAIN SYSTEM INITIALIZATION
        // ============================================

        function initializeAll() {
            console.log(" Initializing Mickey's Enhanced Learning Hub...");
            
            // Show welcome screen with buttons only
            document.body.classList.add('welcome-active');
            document.getElementById('welcome-screen').style.display = 'flex';
            
            // Setup button click handlers
            document.getElementById('show-login-btn').addEventListener('click', showLoginForm);
            document.getElementById('show-register-btn').addEventListener('click', showRegisterForm);
            
            console.log(" System ready - showing buttons only!");
        }

        function initMainSystem(role) {
            initHeaderNavigation();
            initSideToggle();
            initAccessibilityFunctions();
            initGameFunctions();
            initTabFocusTracking();

            // Start checking focus
            setInterval(() => {
                if (tabTracker) {
                    updateFocusDisplayInProfile();
                }
            }, 5000);

            // Initialize dual camera detection
            if (typeof Human !== 'undefined') {
                dualCameraDetection = new DualCameraDetection();
            } else {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/human.js';
                script.onload = function() {
                    dualCameraDetection = new DualCameraDetection();
                    console.log(' Dual camera detection initialized with Human.js');
                };
                document.head.appendChild(script);
            }
            
            // Initialize speaking bot
            initSpeakingBot();
            
            if (role === 'teacher') {
                switchContent('profile');
                setActiveNavTab('profile-tab');
            } else {
                switchContent('game-center');
                setActiveNavTab('game-tab');
            }
        }

        // ============================================
        // HEADER NAVIGATION
        // ============================================

        function initHeaderNavigation() {
            // Game Center tab
            document.getElementById('game-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('game-center');
                setActiveNavTab('game-tab');
            });
            
            // Profile tab
            document.getElementById('profile-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('profile');
                setActiveNavTab('profile-tab');
                updateProfileDisplay();
            });
            
            // About Us tab
            document.getElementById('about-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('about');
                setActiveNavTab('about-tab');
            });
            
            // Settings tab
            document.getElementById('settings-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('settings');
                setActiveNavTab('settings-tab');
                updateSettingsDisplay();
            });
        }

        function setActiveNavTab(tabId) {
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const activeTab = document.getElementById(tabId);
            if (activeTab) {
                activeTab.classList.add('active');
            }
        }

        function switchContent(contentType) {
            document.querySelectorAll('.content-area').forEach(area => {
                area.classList.remove('active');
            });
            
            // Hide tracing container if showing
            document.getElementById('tracing-game-container').style.display = 'none';
            
            const targetArea = document.getElementById(`${contentType}-content-area`);
            if (targetArea) {
                targetArea.classList.add('active');
            }
            
            const moduleContent = document.getElementById('module-content');
            if (moduleContent) {
                moduleContent.classList.remove('active');
            }
        }

        // ============================================
        // ACCESSIBILITY FUNCTIONS
        // ============================================

        function initAccessibilityFunctions() {
            // Dyslexia mode in settings
            const settingsDyslexiaBtn = document.getElementById('toggle-dyslexia');
            if (settingsDyslexiaBtn) {
                settingsDyslexiaBtn.addEventListener('click', function() {
                    toggleDyslexiaMode();
                    this.innerHTML = `<i class="fas fa-toggle-${document.body.classList.contains('dyslexia-mode') ? 'on' : 'off'}"></i> Dyslexia Mode ${document.body.classList.contains('dyslexia-mode') ? 'ON' : 'OFF'}`;
                });
            }
            
            // Settings camera button
            const settingsCameraBtn = document.getElementById('settings-start-camera');
            if (settingsCameraBtn) {
                settingsCameraBtn.addEventListener('click', function() {
                    if (dualCameraDetection) {
                        dualCameraDetection.startBothDetections();
                    } else {
                        alert("Please wait for detection system to load.");
                    }
                });
            }
        }

        function toggleDyslexiaMode() {
            document.body.classList.toggle('dyslexia-mode');
            showNotification("Dyslexia Mode", 
                document.body.classList.contains('dyslexia-mode') ? 
                "Dyslexia-friendly font enabled! " : 
                "Dyslexia-friendly font disabled.", 
                "info");
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================

        function initGameFunctions() {
            // Close module
            const closeModuleBtn = document.getElementById('close-module');
            if (closeModuleBtn) {
                closeModuleBtn.addEventListener('click', closeModule);
            }
        }

        function startGame(gameName) {
            currentGame = gameName;
            const game = learningGames[gameName];
            currentActivityIndex = 0;
            
            if (gameName === 'tracing') {
                startTracingGame();
                return;
            }
            
            document.getElementById('game-center-content-area').classList.remove('active');
            document.getElementById('module-content').classList.add('active');
            
            document.getElementById('module-content-title').textContent = game.title;
            document.getElementById('module-content-body').innerHTML = generateGameActivity(gameName, 0);
            
            // Start detection if not running
            if (dualCameraDetection && !dualCameraDetection.isEmotionRunning) {
                dualCameraDetection.startEmotionDetection();
            }
            
            // Quick focus awareness message
            setTimeout(() => {
                if (voiceEnabled) {
                    speakText("Let's focus and have fun!");
                }
            }, 500);
            
            console.log(` Starting "${game.title}"`);
        }

        function startTracingGame() {
            const game = learningGames.tracing;
            currentActivityIndex = 0;
            
            // Hide main content, show tracing container
            document.getElementById('game-center-content-area').classList.remove('active');
            document.getElementById('tracing-game-container').style.display = 'block';
            
            loadTracingActivity(0);
            
            // Start emotion detection if not already running
            if (dualCameraDetection && !dualCameraDetection.isEmotionRunning) {
                dualCameraDetection.startEmotionDetection();
            }
            
            queueBotMessage("Let's trace some letters! Follow the green dot and have fun!");
        }

        function loadTracingActivity(activityIndex) {
            const game = learningGames.tracing;
            const activity = game.activities[activityIndex];
            
            document.getElementById('target-letter').textContent = activity.letter;
            document.getElementById('tracing-counter').textContent = `Activity ${activityIndex + 1} of ${game.activities.length}`;
            
            // Update navigation buttons
            document.getElementById('prev-tracing').disabled = activityIndex === 0;
            document.getElementById('next-tracing').disabled = activityIndex === game.activities.length - 1;
            
            // Initialize tracing engine
            setTimeout(() => {
                tracingEngine.initialize('tracing-canvas');
                tracingEngine.setTargetLetter(activity.letter, activity.strokeOrder);
            }, 100);
            
            // Setup controls
            document.getElementById('clear-trace').onclick = () => tracingEngine.clearCanvas();
            document.getElementById('check-trace').onclick = () => tracingEngine.analyzeTrace();
            document.getElementById('auto-trace').onclick = () => tracingEngine.showDemo();
            document.getElementById('hint-trace').onclick = () => {
                tracingEngine.showFeedback(activity.hint || "Start from the green dot and follow the path", "needs-improvement");
            };
            
            // Play sound button
            document.getElementById('play-sound-btn').onclick = () => {
                speakText(`The letter ${activity.letter}`);
            };
        }

        function prevTracingActivity() {
            if (currentActivityIndex > 0) {
                currentActivityIndex--;
                loadTracingActivity(currentActivityIndex);
                frustrationLevel = 0;
            }
        }

        function nextTracingActivity() {
            const game = learningGames.tracing;
            if (currentActivityIndex < game.activities.length - 1) {
                currentActivityIndex++;
                loadTracingActivity(currentActivityIndex);
                frustrationLevel = 0;
            } else {
                completeGame('tracing');
            }
        }

        function viewModule(moduleName) {
            const game = learningGames[moduleName];
            document.getElementById('module-content-title').textContent = `${game.title} - Information`;
            document.getElementById('module-content-body').innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 4rem; color: var(--mickey-yellow); margin-bottom: 20px;">
                        <i class="fas fa-info-circle"></i>
                    </div>
                    <h3 style="color: var(--mickey-blue);">${game.description}</h3>
                    <div style="background: var(--mickey-white); padding: 25px; border-radius: 20px; border: 4px solid var(--mickey-black); margin: 30px auto; max-width: 600px;">
                        <h4 style="color: var(--mickey-red);">Enhanced Features:</h4>
                        <ul style="text-align: left; color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.1rem;">
                            <li> <strong>Real-time emotion detection</strong></li>
                            <li> <strong>Eye tracking focus analysis</strong></li>
                            <li> <strong>Dyslexia-friendly design</strong></li>
                            <li> <strong>Proactive Mickey interventions</strong></li>
                        </ul>
                    </div>
                    <div style="margin-top: 30px;">
                        <button class="module-btn start-btn" onclick="startGame('${moduleName}')" 
                                style="padding: 15px 30px; font-size: 1.2rem;">
                            <i class="fas fa-play"></i> Play Game Now!
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('module-content').classList.add('active');
        }

        function generateGameActivity(gameName, activityIndex) {
            const game = learningGames[gameName];
            const activity = game.activities[activityIndex];
            
            let contentHTML = '';
            
            if (activity.type === "letter_recognition" || activity.type === "vowel_identification" || 
                activity.type === "consonant_identification" || activity.type === "letter_sequence") {
                
                const questionText = activity.question || "Identify the correct answer:";
                const optionsList = activity.options || ["Option 1", "Option 2", "Option 3", "Option 4"];
                
                contentHTML = `
                    <div class="game-container">
                        <div class="game-counter">
                            Activity ${activityIndex + 1} of ${game.activities.length}
                        </div>
                        
                        <!-- DYSLEXIA SUPPORT HEADER -->
                        <div class="dyslexia-support-header" style="background: #e6f7ff; padding: 15px; border-radius: 15px; border: 3px solid var(--mickey-blue); margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; color: var(--mickey-blue);">
                                <i class="fas fa-lightbulb"></i>
                                <strong>Dyslexia Tips for this activity:</strong>
                            </div>
                            <ul style="margin: 10px 0 0 20px; color: var(--mickey-black); font-family: 'OpenDyslexic', sans-serif; font-size: 0.9em;">
                                ${game.dyslexia_tips.map(tip => `<li>${tip}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div class="game-question">
                            <i class="fas fa-question-circle" style="color: var(--mickey-red); margin-right: 10px;"></i>
                            ${questionText}
                            
                            ${activity.letter ? `
                                <div style="margin-top: 15px; font-size: 5rem; text-align: center; color: var(--mickey-red);">
                                    ${activity.letter}
                                </div>
                            ` : ''}
                        </div>
                        
                        <div class="game-options">
                            ${optionsList.map((option, index) => `
                                <div class="game-option" onclick="checkAnswer(${index}, '${gameName}')">
                                    ${option}
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="game-feedback" id="game-feedback"></div>
                        <div class="game-progress">
                            <div class="progress-bar" id="game-progress" 
                                style="width: ${((activityIndex + 1) / game.activities.length) * 100}%"></div>
                            <div class="progress-text">
                                ${activityIndex + 1} of ${game.activities.length} activities completed
                            </div>
                        </div>
                        <div class="game-navigation">
                            <button class="nav-btn" ${activityIndex === 0 ? 'disabled' : ''} 
                                    onclick="previousActivity('${gameName}')">
                                <i class="fas fa-arrow-left"></i> Previous
                            </button>
                            <button class="nav-btn" onclick="nextActivity('${gameName}')" 
                                    ${activityIndex === game.activities.length - 1 ? 'disabled' : ''}>
                                Next <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                `;
            }
            
            return contentHTML;
        }

        function checkAnswer(answerIndex, gameName) {
            const game = learningGames[gameName];
            const activity = game.activities[currentActivityIndex];
            const feedback = document.getElementById('game-feedback');
            const options = document.querySelectorAll('.game-option');
            
            options.forEach(opt => {
                opt.classList.remove('correct', 'wrong');
            });
            
            if (answerIndex === activity.correct) {
                // Correct answer
                options[answerIndex].classList.add('correct');
                
                feedback.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <i class="fas fa-check-circle" style="color: var(--mickey-green); font-size: 2rem;"></i>
                        <div>
                            <strong style="color: var(--mickey-green); font-family: 'OpenDyslexic', sans-serif;">Oh boy! Correct!</strong>
                            <p style="margin: 5px 0; color: var(--mickey-white); font-family: 'OpenDyslexic', sans-serif;">${activity.explanation}</p>
                            <p style="margin: 5px 0; color: var(--mickey-yellow);">
                                <i class="fas fa-star"></i> +${activity.points} Mickey Points!
                            </p>
                        </div>
                    </div>
                `;
                
                // Award points
                studentScore += activity.points;
                document.getElementById('student-points').textContent = studentScore;
                
                // Positive emotional feedback
                if (dualCameraDetection) {
                    dualCameraDetection.studentEmotion = "happy";
                    dualCameraDetection.emotionInterventionData.negativeEmotionCount = 0;
                }
                frustrationLevel = 0;
                
                // Play correct audio
                speakEncouragement();
                
                // Auto-advance
                setTimeout(() => {
                    if (currentActivityIndex < game.activities.length - 1) {
                        nextActivity(gameName);
                    } else {
                        completeGame(gameName);
                    }
                }, 2500);
                
            } else {
                // Wrong answer
                options[answerIndex].classList.add('wrong');
                options[activity.correct].classList.add('correct');
                
                feedback.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <i class="fas fa-times-circle" style="color: var(--mickey-red); font-size: 2rem;"></i>
                        <div>
                            <strong style="color: var(--mickey-red); font-family: 'OpenDyslexic', sans-serif;">Let's try again!</strong>
                            <p style="margin: 5px 0; color: var(--mickey-white); font-family: 'OpenDyslexic', sans-serif;">
                                The correct answer is: ${activity.options[activity.correct]}
                            </p>
                        </div>
                    </div>
                `;
                
                // Play incorrect audio
                queueBotMessage("That's okay! Let's try again.", { type: 'correction' });
                
                // Negative emotional feedback
                if (dualCameraDetection) {
                    dualCameraDetection.studentEmotion = "confused";
                    dualCameraDetection.emotionInterventionData.negativeEmotionCount++;
                }
                
                frustrationLevel++;
                
                // Check for intervention (both emotion and frustration)
                if (frustrationLevel >= FRUSTRATION_THRESHOLD) {
                    if (dualCameraDetection) {
                        dualCameraDetection.triggerEmotionIntervention("frustrated");
                    } else {
                        // Fallback if detection not available
                        queueBotMessage("This seems tricky. Would you like some help?", {
                            type: 'intervention',
                            autoClose: false
                        });
                    }
                    frustrationLevel = 0;
                }
            }
            
            feedback.classList.add('show');
        }

        function nextActivity(gameName) {
            if (currentActivityIndex < learningGames[gameName].activities.length - 1) {
                currentActivityIndex++;
                document.getElementById('module-content-body').innerHTML = generateGameActivity(gameName, currentActivityIndex);
                frustrationLevel = 0;
            }
        }

        function previousActivity(gameName) {
            if (currentActivityIndex > 0) {
                currentActivityIndex--;
                document.getElementById('module-content-body').innerHTML = generateGameActivity(gameName, currentActivityIndex);
                frustrationLevel = 0;
            }
        }

        function completeGame(gameName) {
            const game = learningGames[gameName];
            game.completed = true;
            
            // Speak game completion message
            speakGameComplete();
            
            const totalPoints = game.activities.reduce((sum, activity) => sum + (activity.points || 0), 0);
            
            // Show completion screen after speech
            setTimeout(() => {
                if (gameName === 'tracing') {
                    document.getElementById('tracing-game-container').innerHTML = `
                        <div style="text-align: center; padding: 60px 40px;">
                            <div style="font-size: 6rem; color: var(--mickey-yellow); margin-bottom: 30px;">
                                <i class="fas fa-trophy"></i>
                            </div>
                            <h2 style="color: var(--mickey-red);">Tracing Master!</h2>
                            <p style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive; font-size: 1.3rem;">
                                You've mastered letter tracing!
                            </p>
                            <div style="background: var(--mickey-yellow); padding: 25px; border-radius: 20px; 
                                        border: 4px solid var(--mickey-black); margin: 30px auto; max-width: 400px;">
                                <h3 style="color: var(--mickey-black); margin: 0 0 15px 0;">
                                    <i class="fas fa-star"></i> You earned ${totalPoints} Mickey Points!
                                </h3>
                                <p style="color: var(--mickey-red); font-size: 1.2rem;">
                                    Total Score: <strong>${studentScore}</strong> points
                                </p>
                            </div>
                            <button class="module-btn start-btn" onclick="closeTracingGame()" style="padding: 15px 30px;">
                                <i class="fas fa-check"></i> Great Job! Back to Games
                            </button>
                        </div>
                    `;
                } else {
                    document.getElementById('module-content-body').innerHTML = `
                        <div style="text-align: center; padding: 60px 40px;">
                            <div style="font-size: 6rem; color: var(--mickey-yellow); margin-bottom: 30px;">
                                <i class="fas fa-trophy"></i>
                            </div>
                            <h2 style="color: var(--mickey-red);">Congratulations!</h2>
                            <p style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive; font-size: 1.3rem;">
                                You've completed ${game.title}!
                            </p>
                            <div style="background: var(--mickey-yellow); padding: 25px; border-radius: 20px; 
                                        border: 4px solid var(--mickey-black); margin: 30px auto; max-width: 400px;">
                                <h3 style="color: var(--mickey-black); margin: 0 0 15px 0;">
                                    <i class="fas fa-star"></i> You earned ${totalPoints} Mickey Points!
                                </h3>
                                <p style="color: var(--mickey-red); font-size: 1.2rem;">
                                    Total Score: <strong>${studentScore}</strong> points
                                </p>
                            </div>
                            <button class="module-btn start-btn" onclick="closeModule()" style="padding: 15px 30px;">
                                <i class="fas fa-check"></i> Great Job! Play Another Game
                            </button>
                        </div>
                    `;
                }
                
                // Update progress
                updateProfileDisplay();
            }, 2000);
        }

        function closeTracingGame() {
            document.getElementById('tracing-game-container').style.display = 'none';
            document.getElementById('game-center-content-area').classList.add('active');
            closeModule();
        }

        function closeModule() {
            frustrationLevel = 0;
            studentEmotion = 'neutral';
            
            document.getElementById('module-content').classList.remove('active');
            document.getElementById('game-center-content-area').classList.add('active');
            
            currentGame = null;
        }

        // ============================================
        // MICKEY AGENT FUNCTIONS
        // ============================================

        function triggerMickeyIntervention(emotion) {
            showInterventionModal(emotion);
        }

        function showInterventionModal(emotion) {
            const modal = document.createElement('div');
            modal.id = 'intervention-modal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 500px;
                background: var(--mickey-white);
                border-radius: 25px;
                border: 5px solid var(--mickey-black);
                box-shadow: 0 15px 0 var(--mickey-black), 0 25px 50px rgba(0,0,0,0.3);
                z-index: 10003;
                overflow: hidden;
                animation: interventionPop 0.5s ease;
            `;
            
            const titles = {
                frustrated: "You seem frustrated with this question...",
                sad: "I notice you're feeling a bit down...",
                bored: "This might not be engaging enough...",
                confused: "This seems confusing..."
            };
            
            modal.innerHTML = `
                <div style="background: linear-gradient(145deg, var(--mickey-pink), var(--mickey-red)); padding: 25px; text-align: center; color: var(--mickey-white);">
                    <h2 style="margin: 0; color: var(--mickey-white);">
                        <i class="fas fa-heart"></i> I notice you might need help!
                    </h2>
                    <p style="margin: 10px 0 0 0; color: var(--mickey-yellow); font-family: 'Comic Neue', cursive;">
                        Let me help you feel better!
                    </p>
                </div>
                <div style="padding: 30px; text-align: center;">
                    <div style="font-size: 4rem; color: var(--mickey-red); margin-bottom: 20px;">
                        <i class="fas fa-robot"></i>
                    </div>
                    <h3 style="color: var(--mickey-blue); margin-bottom: 10px;">
                        ${titles[emotion] || "You might need some help..."}
                    </h3>
                    <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.1rem;">
                        How would you like me to help?
                    </p>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 25px;">
                        <button class="intervention-btn break" onclick="handleInterventionChoice('break')" style="padding: 15px; background: var(--mickey-yellow); color: var(--mickey-black); border: 3px solid var(--mickey-black); border-radius: 15px; font-family: 'Fredoka One', cursive; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 15px;">
                            <i class="fas fa-coffee"></i> Take a 30-second break
                        </button>
                        <button class="intervention-btn easier" onclick="handleInterventionChoice('easier')" style="padding: 15px; background: var(--mickey-green); color: white; border: 3px solid #009900; border-radius: 15px; font-family: 'Fredoka One', cursive; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 15px;">
                            <i class="fas fa-thumbs-up"></i> Make questions easier
                        </button>
                        <button class="intervention-btn next" onclick="handleInterventionChoice('next')" style="padding: 15px; background: var(--mickey-blue); color: white; border: 3px solid #0055aa; border-radius: 15px; font-family: 'Fredoka One', cursive; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 15px;">
                            <i class="fas fa-forward"></i> Skip to next question
                        </button>
                    </div>
                    
                    <button class="module-btn start-btn" onclick="closeIntervention()" style="margin-top: 20px;">
                        <i class="fas fa-times"></i> I'm okay, continue
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function handleInterventionChoice(choice) {
            const modal = document.getElementById('intervention-modal');
            if (modal) {
                document.body.removeChild(modal);
            }
            
            switch(choice) {
                case 'break':
                    startMickeyBreak();
                    break;
                case 'easier':
                    makeGameEasier();
                    break;
                case 'next':
                    skipToNext();
                    break;
            }
            
            frustrationLevel = 0;
        }

        function closeIntervention() {
            const modal = document.getElementById('intervention-modal');
            if (modal) {
                document.body.removeChild(modal);
            }
            speakText("Glad you're okay! Let's continue!");
        }

        function startMickeyBreak() {
            const breakTimer = document.createElement('div');
            breakTimer.id = 'break-timer';
            breakTimer.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 400px;
                background: var(--mickey-white);
                border-radius: 25px;
                border: 5px solid var(--mickey-black);
                box-shadow: 0 15px 0 var(--mickey-black), 0 25px 50px rgba(0,0,0,0.3);
                z-index: 10001;
                overflow: hidden;
                animation: interventionPop 0.5s;
            `;
            
            breakTimer.innerHTML = `
                <div style="background: linear-gradient(145deg, var(--mickey-pink), var(--mickey-red)); padding: 25px; text-align: center; color: var(--mickey-white);">
                    <h2 style="margin: 0; color: var(--mickey-white);">
                        <i class="fas fa-clock"></i> Break Time!
                    </h2>
                    <p style="margin: 10px 0 0 0; color: var(--mickey-yellow); font-family: 'Comic Neue', cursive;">
                        Take a deep breath and relax
                    </p>
                </div>
                <div style="padding: 30px; text-align: center;">
                    <div class="timer-display" id="timer-display" style="font-size: 4rem; color: var(--mickey-red); margin: 20px 0; font-family: 'Fredoka One', cursive; text-align: center;">00:30</div>
                    <h3 style="color: var(--mickey-blue); margin-bottom: 10px;">
                        Mickey says: "Take a break!"
                    </h3>
                    <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.1rem;">
                        Stretch, take deep breaths, and come back refreshed!
                    </p>
                    
                    <div id="breathing-animation" style="background: var(--mickey-yellow); padding: 20px; border-radius: 15px; border: 3px solid var(--mickey-black); margin: 20px 0; text-align: center; font-size: 1.2rem; color: var(--mickey-red);">
                        Breathe IN... (4 seconds)
                    </div>
                    
                    <button class="module-btn start-btn" onclick="endMickeyBreak()" style="margin-top: 20px;">
                        <i class="fas fa-play"></i> End Break Early
                    </button>
                </div>
            `;
            
            document.body.appendChild(breakTimer);
            
            breakTimerActive = true;
            breakTimeLeft = 30;
            updateBreakTimer();
            
            breakInterval = setInterval(() => {
                breakTimeLeft--;
                updateBreakTimer();
                
                if (breakTimeLeft <= 0) {
                    endMickeyBreak();
                }
            }, 1000);
            
            startBreathingAnimation();
            
            speakText("Time for a quick break! Let's stretch and come back refreshed!");
        }

        function updateBreakTimer() {
            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                const minutes = Math.floor(breakTimeLeft / 60);
                const seconds = breakTimeLeft % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function startBreathingAnimation() {
            const breathingText = document.getElementById('breathing-animation');
            if (!breathingText) return;
            
            let phase = 'in';
            let count = 4;
            
            clearInterval(breathingInterval);
            
            breathingInterval = setInterval(() => {
                if (count === 0) {
                    phase = phase === 'in' ? 'hold' : phase === 'hold' ? 'out' : 'in';
                    count = phase === 'in' ? 4 : phase === 'hold' ? 4 : 6;
                }
                
                let text = '';
                let emoji = '';
                
                switch(phase) {
                    case 'in':
                        text = `Breathe IN... (${count} seconds)`;
                        emoji = '';
                        break;
                    case 'hold':
                        text = `Hold... (${count} seconds)`;
                        emoji = '';
                        break;
                    case 'out':
                        text = `Breathe OUT... (${count} seconds)`;
                        emoji = '';
                        break;
                }
                
                breathingText.innerHTML = `${emoji} ${text}`;
                count--;
                
                if (!breakTimerActive) {
                    clearInterval(breathingInterval);
                }
            }, 1000);
        }

        function endMickeyBreak() {
            breakTimerActive = false;
            clearInterval(breakInterval);
            clearInterval(breathingInterval);
            
            const breakTimer = document.getElementById('break-timer');
            if (breakTimer) {
                document.body.removeChild(breakTimer);
            }
            
            speakText("Break time's over! Ready to continue? You're doing great!");
        }

        function makeGameEasier() {
            isEasyMode = true;
            speakText("I'll make the questions easier for you!");
            
            if (currentGame) {
                if (currentGame === 'tracing') {
                    tracingEngine.tolerance = 30;
                    speakText("I've made the tracing more forgiving!");
                } else {
                    document.getElementById('module-content-body').innerHTML = generateGameActivity(currentGame, currentActivityIndex);
                }
            }
        }

        function skipToNext() {
            if (currentGame && currentActivityIndex < learningGames[currentGame].activities.length - 1) {
                currentActivityIndex++;
                
                if (currentGame === 'tracing') {
                    loadTracingActivity(currentActivityIndex);
                } else {
                    document.getElementById('module-content-body').innerHTML = generateGameActivity(currentGame, currentActivityIndex);
                }
                
                frustrationLevel = 0;
                speakText("Let's skip to the next activity!");
            }
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function speakText(text) {
            if ('speechSynthesis' in window && voiceEnabled) {
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1.2;
                utterance.volume = 1;
                
                const voices = speechSynthesis.getVoices();
                const childVoice = voices.find(voice => 
                    voice.name.includes('Child') || 
                    voice.name.includes('Kids') ||
                    voice.lang.includes('en')
                );
                
                if (childVoice) {
                    utterance.voice = childVoice;
                }
                
                speechSynthesis.speak(utterance);
            }
        }

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                right: 30px;
                background: var(--mickey-white);
                color: var(--mickey-black);
                padding: 15px 20px;
                border-radius: 15px;
                border: 3px solid var(--mickey-black);
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                z-index: 10000;
                font-family: 'Comic Neue', cursive;
                max-width: 300px;
                animation: slideInRight 0.3s ease;
            `;
            
            notification.innerHTML = `
                <strong style="color: var(--mickey-red); display: block; margin-bottom: 5px;">${title}</strong>
                <div>${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 5000);
        }

        function updateProfileDisplay() {
            document.getElementById('student-points').textContent = studentScore;
            
            const completedGames = Object.values(learningGames).filter(g => g.completed).length;
            const totalGames = Object.keys(learningGames).length;
            const progressPercent = (completedGames / totalGames) * 100;
            
            document.getElementById('overall-progress').style.width = `${progressPercent}%`;
            document.querySelector('.progress-text').textContent = `${Math.round(progressPercent)}% Complete`;
            
            document.getElementById('games-completed').textContent = `${completedGames}/${totalGames}`;
            
            // Get focus data
            let focusLevel = '75%';
            if (dualCameraDetection) {
                const focusReport = dualCameraDetection.getFocusReport();
                focusLevel = `${focusReport.score}%`;
                
                // Update focus trend if element exists
                updateFocusTrend(focusReport);
            }
            
            document.getElementById('focus-level').textContent = focusLevel;
        }

        function updateFocusTrend(focusReport) {
            const trendElement = document.getElementById('focus-trend-display');
            if (!trendElement) return;
            
            let focusText = '';
            switch(focusReport.level) {
                case 'high':
                    focusText = `<span style="color: #4CAF50"> HIGH Focus (${focusReport.score}%)</span>`;
                    break;
                case 'medium':
                    focusText = `<span style="color: #FFA500"> MEDIUM Focus (${focusReport.score}%)</span>`;
                    break;
                case 'low':
                    focusText = `<span style="color: #f44336"> LOW Focus (${focusReport.score}%)</span>`;
                    break;
                default:
                    focusText = `<span style="color: #999"> Focus: Calculating...</span>`;
            }
            
            trendElement.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="font-size: 2.5rem; color: var(--mickey-blue);">
                        <i class="fas fa-brain"></i>
                    </div>
                    <div>
                        <h5 style="color: var(--mickey-blue); margin: 0 0 5px 0;">Current Focus Level</h5>
                        <div style="color: var(--mickey-black); font-family: 'Comic Neue', cursive;">
                            ${focusText}
                            <div style="font-size: 0.9em; margin-top: 5px; color: var(--mickey-blue);">
                                <i class="fas fa-eye"></i> Eye tracking: ${(focusReport.eyeDistance * 100).toFixed(1)}% from center
                                <br>
                                <i class="fas fa-mouse-pointer"></i> Cursor: ${focusReport.cursorActive ? 'Active' : 'Inactive'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateSettingsDisplay() {
            const isDetectionActive = dualCameraDetection ? 
                (dualCameraDetection.isEmotionRunning || dualCameraDetection.isEyeTracking) : false;
            
            document.getElementById('detection-status-text').textContent = isDetectionActive ? 'ACTIVE' : 'INACTIVE';
            document.getElementById('detection-status-text').style.color = isDetectionActive ? '#95e1d3' : '#ff6b8b';
            
            const settingsBtn = document.getElementById('settings-start-camera');
            if (settingsBtn) {
                if (isDetectionActive) {
                    settingsBtn.innerHTML = '<i class="fas fa-stop-circle"></i> Stop Detection';
                    settingsBtn.onclick = function() {
                        if (dualCameraDetection) {
                            dualCameraDetection.stopBothDetections();
                        }
                    };
                } else {
                    settingsBtn.innerHTML = '<i class="fas fa-camera"></i> Start Detection';
                    settingsBtn.onclick = function() {
                        if (dualCameraDetection) {
                            dualCameraDetection.startBothDetections();
                        }
                    };
                }
            }
        }

        // ============================================
        // INITIALIZE ON LOAD
        // ============================================

        window.addEventListener('load', function() {
            initializeAll();
        });

        // ============================================
        // GLOBAL FUNCTION EXPORTS
        // ============================================

        window.startGame = startGame;
        window.viewModule = viewModule;
        window.checkAnswer = checkAnswer;
        window.nextActivity = nextActivity;
        window.previousActivity = previousActivity;
        window.closeModule = closeModule;
        window.prevTracingActivity = prevTracingActivity;
        window.nextTracingActivity = nextTracingActivity;
        window.startMickeyBreak = startMickeyBreak;
        window.endMickeyBreak = endMickeyBreak;
        window.toggleDyslexiaMode = toggleDyslexiaMode;
        window.dualCameraDetection = dualCameraDetection;
        window.openCameraPanel = openCameraPanel;
        window.closeCameraPanel = closeCameraPanel;

        window.tellAJoke = function() {
            const jokes = [
                "Why did the math book look sad? Because it had too many problems!",
                "What do you call a bear with no teeth? A gummy bear!",
                "Why did the student eat his homework? Because the teacher said it was a piece of cake!",
                "What do you call a dinosaur that is sleeping? A dino-snore!",
                "Why did the computer go to the doctor? Because it had a virus!",
                "What do you get when you cross a snowman and a vampire? Frostbite!",
                "Why don't scientists trust atoms? Because they make up everything!",
                "What do you call a fish with no eyes? Fsh!"
            ];
            
            return jokes[Math.floor(Math.random() * jokes.length)];
        };

        window.switchToDifferentActivity = function() {
            if (currentGame) {
                // Close current game
                closeModule();
                
                // Suggest a different game
                const availableGames = Object.keys(learningGames).filter(game => game !== currentGame);
                if (availableGames.length > 0) {
                    const randomGame = availableGames[Math.floor(Math.random() * availableGames.length)];
                    
                    setTimeout(() => {
                        queueBotMessage(`How about we try ${learningGames[randomGame].title} instead?`, {
                            type: 'suggestion',
                            autoClose: true
                        });
                        
                        setTimeout(() => {
                            startGame(randomGame);
                        }, 1500);
                    }, 500);
                }
            }
        };

        window.explainDifferently = function() {
            if (currentGame && learningGames[currentGame].activities[currentActivityIndex]) {
                const activity = learningGames[currentGame].activities[currentActivityIndex];
                
                let explanation = "";
                if (activity.type === "letter_recognition") {
                    explanation = "Think of this letter like a picture. Look at its shape and try to draw it in the air with your finger!";
                } else if (activity.type === "vowel_identification") {
                    explanation = "Remember, vowels are A, E, I, O, U (and sometimes Y). They're like the 'voice' letters!";
                } else if (activity.type === "word_spelling") {
                    explanation = "Try sounding out each letter slowly. C says 'kuh', A says 'ah', T says 'tuh'... put them together!";
                } else {
                    explanation = "Let's break this down step by step. First, look at the whole picture, then focus on each part.";
                }
                
                queueBotMessage(explanation, {
                    type: 'explanation',
                    autoClose: true
                });
            }
        };

        window.giveHint = function() {
            if (currentGame && learningGames[currentGame].activities[currentActivityIndex]) {
                const activity = learningGames[currentGame].activities[currentActivityIndex];
                
                let hint = "";
                if (activity.type === "letter_recognition" && activity.tactile_feature) {
                    hint = `Hint: This letter feels ${activity.tactile_feature}. Try tracing it with your finger!`;
                } else if (activity.type === "vowel_identification") {
                    hint = "Hint: Only one of these is a vowel. Remember A, E, I, O, U!";
                } else if (activity.type === "word_spelling") {
                    hint = `Hint: The word "${activity.word}" starts with "${activity.word[0]}" and ends with "${activity.word[activity.word.length-1]}".`;
                } else {
                    hint = "Hint: Take your time and look carefully at each option. You can do this!";
                }
                
                queueBotMessage(hint, {
                    type: 'hint',
                    autoClose: true
                });
            }
        };

        window.goBackToBasics = function() {
            if (currentGame && currentActivityIndex > 0) {
                currentActivityIndex = 0;
                
                if (currentGame === 'tracing') {
                    loadTracingActivity(0);
                } else {
                    document.getElementById('module-content-body').innerHTML = generateGameActivity(currentGame, 0);
                }
                
                queueBotMessage("Let's start from the beginning and take it step by step!", {
                    type: 'info',
                    autoClose: true
                });
            }
        };

        window.doQuickStretch = function() {
            // Create a quick stretch animation
            const stretchOverlay = document.createElement('div');
            stretchOverlay.id = 'stretch-overlay';
            stretchOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(149, 225, 211, 0.95);
                z-index: 10010;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                animation: fadeIn 0.3s ease;
            `;
            
            stretchOverlay.innerHTML = `
                <div style="text-align: center; color: var(--mickey-black);">
                    <div style="font-size: 4rem; margin-bottom: 20px;">
                        <i class="fas fa-running"></i>
                    </div>
                    <h2 style="color: var(--mickey-red); margin-bottom: 10px;">Quick Stretch Break!</h2>
                    <p style="font-family: 'Comic Neue', cursive; font-size: 1.2rem; margin-bottom: 30px;">
                        Follow along with Mickey!
                    </p>
                    <div id="stretch-animation" style="font-size: 3rem; margin-bottom: 30px;">
                        <div style="animation: stretchUpDown 1s infinite alternate;">
                            <i class="fas fa-arrow-up"></i>
                        </div>
                    </div>
                    <button class="module-btn start-btn" onclick="endStretchBreak()" style="padding: 15px 30px;">
                        <i class="fas fa-check"></i> Done Stretching!
                    </button>
                </div>
            `;
            
            document.body.appendChild(stretchOverlay);
            
            // Add stretch animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes stretchUpDown {
                    0% { transform: translateY(0) scale(1); }
                    100% { transform: translateY(-20px) scale(1.2); }
                }
            `;
            document.head.appendChild(style);
            
            // Speak stretch instructions
            queueBotMessage("Let's stretch! Reach up high, then bend down and touch your toes. Ready? 1... 2... 3...", {
                type: 'instruction',
                autoClose: true
            });
        };

        window.endStretchBreak = function() {
            const stretchOverlay = document.getElementById('stretch-overlay');
            if (stretchOverlay) {
                stretchOverlay.remove();
            }
            
            queueBotMessage("Great stretching! You're ready to focus again!", {
                type: 'encouragement',
                autoClose: true
            });
        };
    </script>
</body>
</html>