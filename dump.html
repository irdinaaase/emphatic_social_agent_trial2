<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ============================================
         META & EXTERNAL RESOURCES
         ============================================ -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mickey's Learning Hub - Enhanced with Emotion & Eye Tracking</title>
    
    <!-- External CSS Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Fredoka+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@open-dyslexic/open-dyslexic@1.0.3/css/open-dyslexic.css">

    <!-- ============================================
         CSS STYLES
         Organized by component and functionality
         ============================================ -->
    <style>
/* ------------------------------------------------------------
   ROOT VARIABLES & GLOBAL STYLES
------------------------------------------------------------ */
:root {
    /* Mickey Mouse Theme Colors */
    --mickey-red: #d84a54;
    --mickey-yellow: #e9a946;
    --mickey-black: #25221a;
    --mickey-white: #e9e7db;
    --mickey-blue: #8ac6d1;
    --mickey-pink: #ffb8c6;
    --mickey-green: #95e1d3;
    --mickey-purple: #b8b8ff;
    --mickey-bg: #fff5f5;
}

body {
    margin: 0;
    padding: 20px;
    font-family: 'Fredoka One', cursive;
    background: linear-gradient(135deg, var(--mickey-bg) 0%, #ffe6e6 100%);
    min-height: 100vh;
    background-image: 
        radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.8) 2px, transparent 2px),
        radial-gradient(circle at 90% 80%, rgba(255, 255, 255, 0.8) 2px, transparent 2px);
    background-size: 40px 40px;
    padding-top: 120px;
}

/* Form input focus styles */
input:focus, select:focus {
    outline: none;
    border-color: var(--mickey-red);
    box-shadow: 0 0 10px rgba(255, 107, 139, 0.3);
    transform: translateY(-2px);
    transition: all 0.3s ease;
}

/* Dyslexia-friendly mode */
body.dyslexia-mode {
    font-family: 'OpenDyslexic', 'Comic Sans MS', sans-serif !important;
    letter-spacing: 0.1em;
    line-height: 1.8;
    background: linear-gradient(135deg, #ffffcc 0%, #fff5cc 100%) !important;
}

/* Dyslexia-specific text styling */
.dyslexia-text {
    font-family: 'OpenDyslexic', 'Comic Sans MS', sans-serif !important;
    letter-spacing: 0.15em;
    line-height: 2;
    word-spacing: 0.2em;
    font-size: 1.1em;
}

/* Content fade-in animation */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* ------------------------------------------------------------
   HEADER & NAVIGATION COMPONENTS
------------------------------------------------------------ */
.fixed-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(145deg, var(--mickey-pink), var(--mickey-red));
    border-bottom: 5px solid var(--mickey-black);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    z-index: 9999;
    padding: 15px 20px;
}

.header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 1400px;
    margin: 0 auto;
}

.header-logo {
    display: flex;
    align-items: center;
    gap: 15px;
    color: var(--mickey-white);
    font-size: 1.5rem;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.3s;
}

.header-logo:hover {
    transform: scale(1.05);
}

.logo-icon {
    width: 50px;
    height: 50px;
    background: var(--mickey-yellow);
    border-radius: 50%;
    border: 3px solid var(--mickey-black);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    color: var(--mickey-red);
}

.header-nav {
    display: flex;
    gap: 10px;
}

.nav-tab {
    padding: 12px 20px;
    background: var(--mickey-yellow);
    color: var(--mickey-black);
    border: 3px solid var(--mickey-black);
    border-radius: 15px;
    font-family: 'Fredoka One', cursive;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 8px;
    text-decoration: none;
}

.nav-tab:hover {
    background: var(--mickey-white);
    transform: translateY(-3px);
    box-shadow: 0 5px 0 var(--mickey-black);
}

.nav-tab.active {
    background: var(--mickey-blue);
    color: var(--mickey-white);
}

/* ------------------------------------------------------------
   MAIN CONTENT AREAS
------------------------------------------------------------ */
.content-area {
    display: none;
}

.content-area.active {
    display: block;
}


.profile-content, .settings-content, .about-content {
    padding: 30px;
    background: var(--mickey-white);
    border-radius: 25px;
    border: 5px solid var(--mickey-black);
    box-shadow: 0 10px 0 var(--mickey-black);
    margin-top: 20px;
}

.performance-card {
    transition: all 0.3s ease;
    cursor: pointer;
}

.performance-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0,0,0,0.2);
}

.performance-card.good {
    border-color: #4CAF50 !important;
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
}

.performance-card.warning {
    border-color: #FF9800 !important;
    box-shadow: 0 0 15px rgba(255, 152, 0, 0.3);
}

.performance-card.critical {
    border-color: #F44336 !important;
    box-shadow: 0 0 15px rgba(244, 67, 54, 0.3);
}

@keyframes pulse-healthy {
    0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
}

@keyframes pulse-warning {
    0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(255, 152, 0, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
}

/* Demo credentials box */
.demo-credentials {
    background: var(--mickey-yellow);
    padding: 15px;
    border-radius: 10px;
    border: 3px solid var(--mickey-black);
    margin-top: 15px;
    font-family: 'Comic Neue', cursive;
}

.demo-credentials code {
    background: var(--mickey-white);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--mickey-black);
    font-family: monospace;
    color: var(--mickey-red);
    margin: 2px;
}

/* ------------------------------------------------------------
   LEARNING HUB & GAME MODULES
------------------------------------------------------------ */
.learning-hub {
    position: relative;
}

.mickey-header {
    text-align: center;
    position: relative;
    margin-bottom: 40px;
}

h1 {
    color: var(--mickey-black);
    font-size: 3rem;
    margin: 0 20px;
    text-align: center;
    letter-spacing: 2px;
    position: relative;
    z-index: 2;
}

/* ===============================
   SIMPLE CARD STYLING (NO FLIP)
================================ */
.module-card {
    height: 460px;
    position: relative;
    background: linear-gradient(145deg, #ffffff, #f0f0f0);
    border: 8px solid #ffffff;
    border-radius: 16px;
    box-shadow: 
        0 10px 0 var(--mickey-black),
        0 15px 25px rgba(0, 0, 0, 0.2),
        inset 0 0 30px rgba(255, 255, 255, 0.8);
    padding: 25px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.module-card:hover {
    transform: translateY(-5px);
    box-shadow: 
        0 15px 0 var(--mickey-black),
        0 20px 35px rgba(0, 0, 0, 0.25);
}

/* Poker card pattern overlay */
.module-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
        radial-gradient(circle at 20% 30%, rgba(255, 0, 0, 0.05) 2%, transparent 2%),
        radial-gradient(circle at 80% 70%, rgba(255, 0, 0, 0.05) 2%, transparent 2%);
    background-size: 60px 60px;
    pointer-events: none;
}

/* Corner decorations - Poker card style */
.module-card::after {
    content: '';
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    bottom: 15px;
    border: 2px solid rgba(255, 0, 0, 0.1);
    border-radius: 8px;
    pointer-events: none;
}

/* ===============================
   CARD LOGO
================================ */
.card-logo {
    width: 100px;
    height: 100px;
    background: linear-gradient(145deg, #ff4444, #cc0000);
    border-radius: 50%;
    border: 6px solid var(--mickey-black);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
    margin-top: 15px;
}

.module-card:hover .card-logo {
    transform: rotate(0deg) scale(1.05);
}

.card-logo i {
    font-size: 4rem;
    color: #ffffff;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.2));
}

/* ===============================
   CARD CONTENT
================================ */
.module-card h3 {
    font-family: 'Fredoka One', cursive;
    font-size: 2rem;
    margin-bottom: 15px;
    color: var(--mickey-red);
    text-shadow: 
        2px 2px 0 var(--mickey-black),
        4px 4px 8px rgba(0, 0, 0, 0.3);
    letter-spacing: 1px;
    position: relative;
    z-index: 2;
}

.module-card p {
    font-size: 1.1rem;
    line-height: 1.6;
    font-family: 'Comic Neue', cursive;
    color: var(--mickey-black);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 2;
    padding: 0 10px;
    flex-grow: 1;
}

/* ===============================
   PLAY BUTTON - SIMPLE CARD STYLE
================================ */
.play-btn {
    width: 90%;
    padding: 16px;
    background: linear-gradient(145deg, #ffd700, #ffaa00);
    color: var(--mickey-black);
    border: 4px solid var(--mickey-black);
    border-radius: 50px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-top: auto;
    box-shadow: 
        0 6px 0 var(--mickey-black),
        0 10px 20px rgba(0, 0, 0, 0.2),
        inset 0 2px 4px rgba(255, 255, 255, 0.5),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    position: relative;
    z-index: 2;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.play-btn:hover {
    background: linear-gradient(145deg, #ffed4e, #ffcc00);
    transform: translateY(-5px) scale(1.02);
    box-shadow: 
        0 8px 0 var(--mickey-black),
        0 15px 25px rgba(0, 0, 0, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.8);
}

.play-btn:active {
    transform: translateY(-2px);
    box-shadow: 
        0 4px 0 var(--mickey-black),
        0 8px 15px rgba(0, 0, 0, 0.2);
}

/* ===============================
   REWARD BADGE
================================ */
.reward {
    margin-top: 20px;
    padding: 12px 24px;
    color: var(--mickey-black);
    font-size: 1rem;
    position: relative;
    z-index: 2;
    display: inline-block;
}

.reward::before {
    content: '‚≠ê';
    margin-right: 8px;
    animation: spinStar 3s linear infinite;
}

@keyframes spinStar {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.2); }
    100% { transform: rotate(360deg) scale(1); }
}

/* ===============================
   POKER SUIT DECORATIONS
================================ */
.poker-suit {
    position: absolute;
    font-size: 2rem;
    opacity: 0.2;
    z-index: 1;
    animation: floatSuit 10s infinite linear;
}

.poker-suit.heart {
    color: #ff4444;
    top: 20px;
    left: 20px;
}

.poker-suit.diamond {
    color: #ff4444;
    top: 20px;
    right: 20px;
}

.poker-suit.club {
    color: #000000;
    bottom: 20px;
    left: 20px;
}

.poker-suit.spade {
    color: #000000;
    bottom: 20px;
    right: 20px;
}

@keyframes floatSuit {
    0%, 100% {
        transform: translateY(0) rotate(0deg);
        opacity: 0.2;
    }
    50% {
        transform: translateY(-10px) rotate(180deg);
        opacity: 0.4;
    }
}

/* Ensure modules grid works with new cards */
.modules-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 25px;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
    border-radius: 20px;
    border: 3px dashed rgba(255, 255, 255, 0.3);
    height: auto; /* Remove fixed height */
}


/* MODULE CONTENT AREA */
/* Add to your CSS section */
.module-content-area {
    display: none;
    position: relative !important;
    z-index: 1000 !important;
    background: var(--mickey-white) !important;
}

.module-content-area.active {
    display: block !important;
    animation: fadeIn 0.5s ease !important;
    opacity: 1 !important;
    visibility: visible !important;
    margin-top: 20px !important;
    margin-bottom: 50px !important;
}

.content-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 15px;
    border-bottom: 4px solid var(--mickey-yellow);
}
/* ===============================
   MODULE BUTTON STYLES
================================ */
.module-btn {
    padding: 12px 25px;
    background: var(--mickey-yellow);
    color: var(--mickey-black);
    border: 3px solid var(--mickey-black);
    border-radius: 15px;
    font-family: 'Fredoka One', cursive;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    text-decoration: none;
    box-shadow: 0 4px 0 var(--mickey-black);
    margin: 5px;
}

.module-btn:hover {
    background: var(--mickey-red);
    color: var(--mickey-white);
    transform: translateY(-3px);
    box-shadow: 0 6px 0 var(--mickey-black);
}

.module-btn:active {
    transform: translateY(-1px);
    box-shadow: 0 2px 0 var(--mickey-black);
}

/* Module button variants */
.module-btn.success {
    background: var(--mickey-green);
    color: white;
}

.module-btn.primary {
    background: var(--mickey-blue);
    color: white;
}

.module-btn.danger {
    background: var(--mickey-red);
    color: white;
}

.module-btn.warning {
    background: var(--mickey-yellow);
    color: var(--mickey-black);
}

.module-btn.info {
    background: var(--mickey-pink);
    color: white;
}

/* Large module button */
.module-btn.large {
    padding: 15px 30px;
    font-size: 1.2rem;
}

/* Full width module button */
.module-btn.full {
    width: 100%;
    display: flex;
}

/* Disabled state */
.module-btn:disabled {
    background: #cccccc;
    color: #666666;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 4px 0 #999999;
}

/* Keep your existing nav-btn styles as they are */
.nav-btn {
    padding: 12px 25px;
    background: var(--mickey-blue);
    color: var(--mickey-white);
    border: none;
    border-radius: 15px;
    cursor: pointer;
    font-family: 'Fredoka One', cursive;
    border: 3px solid var(--mickey-black);
}

.nav-btn:hover {
    background: var(--mickey-red);
    transform: scale(1.05);
}

.nav-btn:disabled {
    background: #cccccc;
    cursor: not-allowed;
}

/* Update the existing close-module button */
.close-module {
    background: var(--mickey-red);
    color: var(--mickey-white);
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 1.2rem;
    cursor: pointer;
    border: 3px solid var(--mickey-black);
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-module:hover {
    background: var(--mickey-blue);
    transform: rotate(90deg);
}

.content-body {
    min-height: 400px !important;
    padding: 20px !important;
}

/* ------------------------------------------------------------
   GAME/ACTIVITY STYLES
------------------------------------------------------------ */
.game-container {
    background: var(--mickey-yellow);
    padding: 25px;
    border-radius: 20px;
    border: 4px solid var(--mickey-black);
    margin-bottom: 30px;
}

.game-question {
    font-size: 1.4rem;
    color: var(--mickey-black);
    margin-bottom: 20px;
    font-family: 'Fredoka One', cursive;
}

.game-options {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-bottom: 25px;
}

.game-option {
    padding: 15px;
    background: var(--mickey-white);
    border: 3px solid var(--mickey-black);
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s;
    font-family: 'Comic Neue', cursive;
    font-weight: 700;
    text-align: center;
}

.game-option:hover {
    transform: translateY(-5px);
    background: var(--mickey-red);
    color: var(--mickey-white);
}

.game-option.correct {
    background: var(--mickey-green);
    color: white;
    border-color: var(--mickey-green);
}

.game-option.wrong {
    background: var(--mickey-red);
    color: white;
    border-color: var(--mickey-red);
}

.game-feedback {
    padding: 15px;
    background: var(--mickey-blue);
    color: var(--mickey-white);
    border-radius: 15px;
    display: none;
    margin-bottom: 20px;
    border: 3px solid var(--mickey-black);
}

.game-feedback.show {
    display: block;
    animation: fadeIn 0.3s ease;
}

.game-progress {
    background: var(--mickey-white);
    padding: 20px;
    border-radius: 15px;
    border: 4px solid var(--mickey-black);
    margin-top: 30px;
}

.progress-bar {
    height: 30px;
    background: linear-gradient(90deg, var(--mickey-yellow), var(--mickey-pink));
    border-radius: 15px;
    width: 0%;
    transition: width 0.5s ease;
    border: 3px solid var(--mickey-black);
}

.progress-text {
    text-align: center;
    margin-top: 10px;
    font-family: 'Comic Neue', cursive;
    font-weight: 700;
    color: var(--mickey-blue);
}

/* GAME NAVIGATION */
.game-navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 30px;
    padding-top: 20px;
    border-top: 3px dashed var(--mickey-red);
}

.game-counter {
    font-family: 'Fredoka One', cursive;
    color: var(--mickey-red);
    font-size: 1.2rem;
    background: var(--mickey-white);
    padding: 10px 20px;
    border-radius: 20px;
    border: 3px solid var(--mickey-black);
}

.nav-btn {
    padding: 12px 25px;
    background: var(--mickey-blue);
    color: var(--mickey-white);
    border: none;
    border-radius: 15px;
    cursor: pointer;
    font-family: 'Fredoka One', cursive;
    border: 3px solid var(--mickey-black);
}

.nav-btn:hover {
    background: var(--mickey-red);
    transform: scale(1.05);
}

.nav-btn:disabled {
    background: #cccccc;
    cursor: not-allowed;
}

/* ------------------------------------------------------------
   SIDE CONTROLS & BUBBLES SYSTEM
------------------------------------------------------------ */
.side-collapsible {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 9997;
}

.side-toggle {
    width: 60px;
    height: 60px;
    background: var(--mickey-red);
    border-radius: 50%;
    border: 4px solid var(--mickey-black);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(255, 107, 139, 0.4);
    transition: all 0.3s;
    animation: pulse 2s infinite;
}

.side-toggle:hover {
    transform: scale(1.1);
}

.side-toggle i {
    color: var(--mickey-white);
    font-size: 1.5rem;
}

/* Enhanced Side Toggle System */
.side-bubbles {
    position: absolute;
    bottom: 70px;
    right: 0;
    display: none;
    flex-direction: column;
    gap: 15px;
    animation: slideUp 0.3s ease;
    z-index: 9998;
}

.side-bubbles.show {
    display: flex;
}

.side-bubble {
    width: 60px;
    height: 60px;
    background: var(--mickey-yellow);
    border-radius: 50%;
    border: 4px solid var(--mickey-black);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    transition: all 0.3s;
    position: relative;
}

.side-bubble:hover {
    transform: scale(1.1) rotate(10deg);
    background: var(--mickey-white);
}

.side-bubble i {
    color: var(--mickey-red);
    font-size: 1.5rem;
}

/* Bubble variants */
.side-bubble.emotion-camera {
    background: var(--mickey-pink);
}

.side-bubble.emotion-camera i {
    color: var(--mickey-white);
}

.side-bubble.eye-camera {
    background: var(--mickey-blue);
}

.side-bubble.eye-camera i {
    color: var(--mickey-white);
}

.side-bubble.speaking-bot {
    background: var(--mickey-pink);
    animation: pulse 2s infinite;
}

.side-bubble.speaking-bot i {
    color: var(--mickey-white);
}

.side-bubble.active {
    background: var(--mickey-green);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--mickey-green);
    animation: pulse 2s infinite;
}

.side-bubble.active i {
    color: var(--mickey-white);
}

/* Speaking bot message indicator */
.bot-message-indicator {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 20px;
    height: 20px;
    background: var(--mickey-red);
    border-radius: 50%;
    border: 2px solid var(--mickey-white);
    display: none;
    animation: bounce 1s infinite;
}

.side-bubble.speaking-bot.has-message .bot-message-indicator {
    display: block;
}

/* Camera status indicators */
.camera-status-dot {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 15px;
    height: 15px;
    border-radius: 50%;
    border: 2px solid var(--mickey-white);
    display: none;
}

.camera-status-dot.active {
    background: var(--mickey-green);
    box-shadow: 0 0 10px var(--mickey-green);
    display: block;
    animation: pulse-green 2s infinite;
}

.camera-status-dot.inactive {
    background: var(--mickey-red);
    display: block;
}

/* Camera status indicators in header */
.camera-status-indicators {
    position: fixed;
    bottom: 30px;
    right: 100px;
    display: flex;
    gap: 10px;
    z-index: 9995;
}

.camera-indicator {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid var(--mickey-black);
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
    display: none;
}

.emotion-indicator {
    background: var(--mickey-pink);
}

.eye-indicator {
    background: var(--mickey-blue);
}

.indicator-active {
    display: block;
    animation: pulse-indicator 2s infinite;
}

/* ------------------------------------------------------------
   DUAL CAMERA DETECTION INTERFACE
------------------------------------------------------------ */
.collapsible-controls {
    position: fixed;
    top: 120px;
    right: 30px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    z-index: 9999;
}

.collapsible-content {
    display: none;
    position: absolute;
    top: 60px;
    right: 0;
    background: var(--mickey-white);
    border-radius: 20px;
    border: 4px solid var(--mickey-black);
    padding: 20px;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    z-index: 9997;
    width: 300px;
    /* Add these properties for scrollability */
    max-height: 80vh; /* Limit height to 80% of viewport */
    overflow-y: auto; /* Enable vertical scrolling */
    overflow-x: hidden; /* Prevent horizontal scrolling */
}

.camera-container {
    /* Ensure proper layout for scrolling */
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* Add custom scrollbar styling for better appearance */
.collapsible-content::-webkit-scrollbar {
    width: 8px;
}

.collapsible-content::-webkit-scrollbar-track {
    background: var(--mickey-yellow);
    border-radius: 10px;
}

.collapsible-content::-webkit-scrollbar-thumb {
    background: var(--mickey-red);
    border-radius: 10px;
    border: 2px solid var(--mickey-white);
}

.collapsible-content::-webkit-scrollbar-thumb:hover {
    background: var(--mickey-pink);
}

.collapsible-content.active {
    display: block;
    animation: slideInRight 0.3s ease;
}

.collapsible-close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 30px;
    height: 30px;
    background: var(--mickey-red);
    color: var(--mickey-white);
    border: 3px solid var(--mickey-black);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    z-index: 9998;
    transition: all 0.3s;
}

.collapsible-close-btn:hover {
    background: var(--mickey-blue);
    transform: rotate(90deg) scale(1.1);
}

/* Enhanced detection interface */
.dual-screen-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 20px 0;
}

.detection-screen {
    background: var(--mickey-white);
    border-radius: 15px;
    border: 4px solid var(--mickey-black);
    padding: 15px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.screen-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.screen-title {
    color: var(--mickey-red);
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

.screen-status {
    background: var(--mickey-yellow);
    padding: 5px 10px;
    border-radius: 15px;
    border: 2px solid var(--mickey-black);
    font-size: 0.8rem;
    color: var(--mickey-black);
    display: flex;
    align-items: center;
    gap: 5px;
}

.screen-status.active {
    background: var(--mickey-green);
    color: white;
}

.video-container {
    position: relative;
    width: 100%;
    height: 180px;
    background: black;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 10px;
}

.detection-video {
    width: 100%;
    height: 100%;
    transform: scaleX(-1);
    object-fit: cover;
}

.detection-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.detection-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
}

.stat-item {
    background: var(--mickey-yellow);
    padding: 8px;
    border-radius: 8px;
    border: 2px solid var(--mickey-black);
    text-align: center;
}

.stat-value {
    font-size: 1rem;
    font-weight: bold;
    color: var(--mickey-red);
    line-height: 1.2;
}

.stat-label {
    font-size: 0.7rem;
    color: var(--mickey-black);
}

/* Focus and emotion indicators */
.focus-status {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 5px 10px;
    border-radius: 15px;
    color: white;
    font-size: 11px;
    display: flex;
    align-items: center;
    gap: 5px;
    z-index: 10;
}

.status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
}

.status-focusing {
    background: #4CAF50;
    box-shadow: 0 0 5px #4CAF50;
}

.status-distracted {
    background: #f44336;
    box-shadow: 0 0 5px #f44336;
}

.status-unknown {
    background: #FFA500;
    box-shadow: 0 0 5px #FFA500;
}

.iris-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 4px 6px;
    border-radius: 6px;
    color: white;
    font-size: 9px;
    z-index: 10;
    line-height: 1.2;
}

.emotion-info {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 4px 6px;
    border-radius: 6px;
    color: white;
    font-size: 9px;
    z-index: 10;
    line-height: 1.2;
}

/* Combined controls */
.combined-controls {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.control-btn {
    padding: 10px 15px;
    border: 3px solid var(--mickey-black);
    border-radius: 10px;
    font-family: 'Fredoka One', cursive;
    cursor: pointer;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    transition: all 0.3s;
    font-size: 0.9rem;
}

.start-all-btn {
    background: var(--mickey-green);
    color: white;
}

.stop-all-btn {
    background: var(--mickey-red);
    color: white;
}

.separate-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
    flex-wrap: wrap;
}

.separate-btn {
    padding: 8px 12px;
    border: 2px solid var(--mickey-black);
    border-radius: 8px;
    font-family: 'Fredoka One', cursive;
    cursor: pointer;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    transition: all 0.3s;
    font-size: 0.8rem;
}

.start-emotion-btn {
    background: var(--mickey-pink);
    color: white;
}

.stop-emotion-btn {
    background: var(--mickey-pink);
    color: white;
    opacity: 0.7;
}

.start-eye-btn {
    background: var(--mickey-blue);
    color: white;
}

.stop-eye-btn {
    background: var(--mickey-blue);
    color: white;
    opacity: 0.7;
}

.btn-active {
    opacity: 1 !important;
    transform: scale(1.05);
    box-shadow: 0 5px 10px rgba(0,0,0,0.2);
}

.btn-disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Detection status panel */
.detection-status-panel {
    margin-top: 15px;
    padding: 15px;
    background: var(--mickey-yellow);
    border-radius: 10px;
    border: 3px solid var(--mickey-black);
}

.status-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.status-icon {
    font-size: 1.5rem;
    color: var(--mickey-red);
}

.status-title {
    color: var(--mickey-black);
    font-weight: bold;
    font-size: 1rem;
}

.status-message {
    color: var(--mickey-black);
    font-size: 0.9rem;
    line-height: 1.4;
}

/* ------------------------------------------------------------
   TRACING GAME STYLES
------------------------------------------------------------ */
.tracing-game-container {
    max-width: 1400px;
    margin: 0 auto;
    background: var(--mickey-white);
    border-radius: 25px;
    border: 5px solid var(--mickey-black);
    padding: 30px;
    box-shadow: 0 10px 0 var(--mickey-black);
}

.tracing-header {
    text-align: center;
    margin-bottom: 30px;
}

.tracing-instructions {
    background: var(--mickey-yellow);
    padding: 15px;
    border-radius: 15px;
    border: 3px solid var(--mickey-black);
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-family: 'Comic Neue', cursive;
    margin-top: 10px;
}

.tracing-area {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 30px;
}

.letter-display {
    background: var(--mickey-pink);
    border-radius: 20px;
    border: 4px solid var(--mickey-black);
    padding: 30px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.target-letter {
    font-size: 10rem;
    color: var(--mickey-white);
    text-shadow: 5px 5px 0 var(--mickey-black);
    font-family: 'Fredoka One', cursive;
    margin-bottom: 20px;
}

.letter-sound {
    width: 100%;
}

.canvas-container {
    position: relative;
    background: var(--mickey-white);
    border-radius: 20px;
    border: 4px solid var(--mickey-black);
    overflow: hidden;
    height: 400px;
}

#tracing-canvas {
    width: 100%;
    height: 100%;
    cursor: crosshair;
    display: block;
}

.tracing-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.start-dot {
    position: absolute;
    width: 20px;
    height: 20px;
    background: var(--mickey-green);
    border-radius: 50%;
    border: 3px solid var(--mickey-white);
    box-shadow: 0 0 10px var(--mickey-green);
    transform: translate(-50%, -50%);
    animation: pulse 1.5s infinite;
}

.trace-guide {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: radial-gradient(circle at center, transparent 0%, transparent 100%);
    pointer-events: none;
}

.tracing-controls {
    grid-column: 1 / -1;
    display: flex;
    gap: 15px;
    margin-top: 20px;
}

.tracing-btn {
    padding: 12px 20px;
    border: 3px solid var(--mickey-black);
    border-radius: 15px;
    font-family: 'Fredoka One', cursive;
    cursor: pointer;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    transition: all 0.3s;
    background: var(--mickey-yellow);
    color: var(--mickey-black);
}

.tracing-btn:hover {
    transform: translateY(-3px);
}

.tracing-btn.success {
    background: var(--mickey-green);
    color: white;
}

.tracing-btn.hint {
    background: var(--mickey-blue);
    color: white;
}

.tracing-btn.demo {
    background: var(--mickey-pink);
    color: white;
}

.tracing-feedback {
    grid-column: 1 / -1;
    background: var(--mickey-white);
    padding: 15px;
    border-radius: 15px;
    border: 3px solid var(--mickey-black);
    margin-top: 20px;
    display: none;
    font-family: 'Comic Neue', cursive;
}

.tracing-feedback.show {
    display: block;
    animation: fadeIn 0.3s ease;
}

.tracing-feedback.success {
    background: var(--mickey-green);
    color: white;
    border-color: var(--mickey-green);
}

.tracing-feedback.needs-improvement {
    background: var(--mickey-yellow);
    color: var(--mickey-black);
}

.tracing-progress {
    grid-column: 1 / -1;
    margin-top: 20px;
}

.tracing-progress-bar {
    height: 25px;
    background: var(--mickey-white);
    border-radius: 15px;
    border: 3px solid var(--mickey-black);
    overflow: hidden;
}

.tracing-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--mickey-yellow), var(--mickey-pink));
    width: 0%;
    transition: width 0.5s ease;
}

/* ------------------------------------------------------------
   WELCOME SCREEN STYLES
------------------------------------------------------------ */
body.welcome-active {
    overflow: hidden;
    padding: 0 !important;
    background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), 
                url('images/the road in mickey mouse wallpaper.jpg') center/cover no-repeat !important;
}

body.welcome-active .fixed-header,
body.welcome-active .content-area,
body.welcome-active .side-collapsible,
body.welcome-active .camera-status-indicators,
body.welcome-active .collapsible-controls,
body.welcome-active .polka-dot,
body.welcome-active .mickey-dot {
    display: none !important;
}

.welcome-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), 
                url('images/the road in mickey mouse wallpaper.jpg') center/cover no-repeat;
    z-index: 10002;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.5s ease;
}

.welcome-content {
    background: rgba(255, 249, 240, 0.95);
    border-radius: 30px;
    border: 8px solid var(--mickey-black);
    box-shadow: 0 15px 0 var(--mickey-black), 0 30px 50px rgba(0,0,0,0.2);
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    overflow: hidden;
    animation: bounceIn 0.8s ease;
    display: flex;
    flex-direction: column;
}

.welcome-header {
    padding: 30px 20px;
    text-align: center;
    position: relative;
    flex-shrink: 0;
}

.mickey-welcome-logo {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    margin-bottom: 20px;
}

.mickey-welcome-logo img {
    height: 150px;
    margin-bottom: 20px;
    object-fit: cover;
}

.welcome-body {
    text-align: center;
    flex: 1;
    overflow-y: auto;
    max-height: calc(90vh - 200px);
    padding: 0 20px 20px 20px;
}

.welcome-message {
    margin-bottom: 20px;
}

.welcome-message p {
    color: #25221a;
    font-size: 1.4rem;
    font-family: 'Comic Neue', cursive;
    margin: 15px 0;
}

.welcome-features {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-top: 20px;
    flex-wrap: wrap;
}

.feature {
    background: var(--mickey-yellow);
    padding: 12px 20px;
    border-radius: 15px;
    border: 3px solid var(--mickey-black);
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: 'Fredoka One', cursive;
    color: var(--mickey-black);
    font-size: 1rem;
}

.feature i {
    color: var(--mickey-red);
    font-size: 1.3rem;
}

/* Forms Container */
.forms-container {
    margin-top: 20px;
    padding-right: 10px;
    flex: 1;
    display: flex;
    flex-direction: column;
}

.form-container {
    background: var(--mickey-white);
    padding: 20px;
    border-radius: 15px;
    border: 3px solid var(--mickey-black);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    margin: 20px 0;
    display: none;
}

.form-title {
    color: var(--mickey-red);
    text-align: center;
    margin-bottom: 20px;
    font-family: 'Fredoka One', cursive;
}

/* Form Fields */
.form-field {
    margin-bottom: 15px;
}

.form-label {
    display: block;
    margin-bottom: 5px;
    color: var(--mickey-black);
    font-family: 'Fredoka One', cursive;
}

.form-input {
    width: 95%;
    padding: 12px 15px;
    border-radius: 10px;
    border: 3px solid var(--mickey-black);
    font-family: 'Comic Neue', cursive;
    font-size: 1rem;
    background: var(--mickey-white);
}

.form-input:focus {
    outline: none;
    border-color: var(--mickey-red);
    box-shadow: 0 0 10px rgba(255, 107, 139, 0.3);
    transform: translateY(-2px);
    transition: all 0.3s ease;
}

.form-select {
    width: 100%;
    padding: 12px 15px;
    border-radius: 10px;
    border: 3px solid var(--mickey-black);
    font-family: 'Comic Neue', cursive;
    font-size: 1rem;
    background: var(--mickey-white);
    cursor: pointer;
}

/* Remember Me Checkbox */
.remember-me {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 15px;
}

.remember-me input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.remember-me label {
    color: var(--mickey-black);
    font-family: 'Comic Neue', cursive;
    cursor: pointer;
}

/* Form Buttons */
.form-submit-btn {
    width: 100%;
    margin-bottom: 15px;
}

/* Password Hint */
.password-hint {
    margin-top: 5px;
    font-size: 0.8rem;
    color: var(--mickey-blue);
    font-family: 'Comic Neue', cursive;
}

/* Demo Credentials */
.demo-title {
    padding: 2px;
    color: var(--mickey-black);
    font-size: 0.9rem;
    margin: 0 0 10px 0;
}

.credentials-list {
    margin: 8px 0;
}

.credential-item {
    align-items: center;
    gap: 5px;
    margin-bottom: 6px;
}

.credential-item:last-child {
    margin-bottom: 0;
    margin-top: 6px;
}

.credential-icon {
    font-size: 0.8rem;
}

.student-cred .credential-icon {
    color: var(--mickey-blue);
}

.teacher-cred .credential-icon {
    color: var(--mickey-red);
}

.credential-label {
    font-weight: bold;
    color: var(--mickey-black);
}

.credential-username,
.credential-password {
    background: var(--mickey-white);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--mickey-black);
    font-family: monospace;
    color: var(--mickey-red);
}

.credential-separator {
    margin: 0 5px;
    color: var(--mickey-black);
}

/* Form Footer */
.form-footer {
    text-align: center;
    margin-top: 15px;
}

.form-footer p {
    color: var(--mickey-blue);
    font-family: 'Comic Neue', cursive;
    margin: 0;
}

.form-link {
    color: var(--mickey-red);
    text-decoration: underline;
    cursor: pointer;
    font-weight: bold;
}

.form-link:hover {
    color: var(--mickey-pink);
}

/* Welcome Actions */
.welcome-actions {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin: 20px 0;
}

.start-learning-btn, .explore-btn {
    padding: 15px 30px;
    border: 4px solid var(--mickey-black);
    border-radius: 20px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 12px;
}

.start-learning-btn {
    background: var(--mickey-red);
    color: var(--mickey-white);
}

.explore-btn {
    background: var(--mickey-blue);
    color: var(--mickey-white);
}

.start-learning-btn:hover, .explore-btn:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 0 var(--mickey-black);
}

.start-learning-btn:hover {
    background: var(--mickey-pink);
}

.explore-btn:hover {
    background: #6aa8b5;
}

/* ------------------------------------------------------------
   INDEPENDENT SPEAKING BOT SYSTEM
------------------------------------------------------------ */
.speaking-bot-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(26, 26, 46, 0.95);
    z-index: 10005;
    animation: fadeIn 0.3s ease;
}

.speaking-bot-container {
    position: absolute;
    top: 60%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    padding: 40px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 160px;
    animation: slideUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* Bot speaker avatar */
.bot-speaker-avatar {
    position: relative;
    width: 180px;
    height: 180px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.bot-speaker-circle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
    width: 100%;
    height: 100%;
    background: transparent !important;
    box-shadow: none !important;
}

.speaking .bot-speaker-circle {
    animation: speakingPulse 1.5s infinite alternate;
}

.bot-speaker-img {
    object-fit: contain;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

/* Speaker waves */
.speaker-waves {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
}

.speaking .speaker-waves {
    display: block;
}

.speaker-wave {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 370%;
    height: 370%;
    border-radius: 50%;
    transform: translate(-50%, -45%);
    border: 2px solid rgba(149, 225, 211, 0.3);
    animation: waveExpand 1.5s infinite linear;
}

.speaker-wave:nth-child(1) {
    animation-delay: 0s;
}

.speaker-wave:nth-child(2) {
    animation-delay: 0.5s;
}

.speaker-wave:nth-child(3) {
    animation-delay: 1s;
}

/* Bot speaker status */
.bot-speaker-status {
    text-align: center;
    color: white;
    width: 100%;
}

.status-text {
    font-size: 1.3rem;
    margin-bottom: 15px;
    font-family: 'Comic Neue', cursive;
    color: #95e1d3;
    min-height: 30px;
    transition: all 0.3s;
}

.speaking .status-text {
    animation: textGlow 1s infinite alternate;
}

/* VOICE WAVE VISUALIZATION */
.voice-wave-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    height: 30px;
    margin-top: 15px;
    width: 100%;
}

.voice-wave-bar {
    width: 6px;
    height: 10px;
    background: linear-gradient(to top, #ff6b8b, #ffd166);
    border-radius: 3px;
    transition: all 0.3s ease;
    animation: wavePulse 1.5s infinite ease-in-out;
}

.voice-wave-bar:nth-child(1) { animation-delay: 0s; }
.voice-wave-bar:nth-child(2) { animation-delay: 0.1s; }
.voice-wave-bar:nth-child(3) { animation-delay: 0.2s; }
.voice-wave-bar:nth-child(4) { animation-delay: 0.3s; }
.voice-wave-bar:nth-child(5) { animation-delay: 0.4s; }

/* Speaking state adjustments */
.speaking .voice-wave-bar {
    animation-play-state: running;
}

/* Non-speaking state */
:not(.speaking) .voice-wave-bar {
    animation-play-state: paused;
    height: 8px;
    opacity: 0.3;
}

/* Continue button */
.bot-speaker-continue {
    padding: 12px 25px;
    background: rgba(255, 107, 139, 0.8);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 15px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: all 0.3s;
    opacity: 0;
    pointer-events: none;
}

.bot-speaker-continue.show {
    opacity: 1;
    pointer-events: all;
}

.bot-speaker-continue:hover {
    background: rgba(255, 107, 139, 1);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(255, 107, 139, 0.4);
}

/* Make eye video identical to emotion video */
#eye-video {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    transform: scaleX(-1) !important;
    background: black !important;
}

/* Make eye overlay canvas identical to emotion overlay */
#eye-tracking-canvas {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 2 !important;
    pointer-events: none !important;
    background: transparent !important;
}

/* Remove the eye-canvas class styles that might conflict */
.eye-canvas {
    /* Remove any conflicting styles */
    display: none; /* We're not using this class anymore */
}

/* ------------------------------------------------------------
   DECORATIVE ELEMENTS
------------------------------------------------------------ */
/* MICKEY DECORATIONS */
.mickey-dot {
    position: fixed;
    width: 20px;
    height: 20px;
    background: var(--mickey-red);
    border-radius: 50%;
    border: 3px solid var(--mickey-black);
    z-index: -1;
    animation: float 20s infinite linear;
}

.polka-dot {
    position: fixed;
    width: 40px;
    height: 40px;
    background: var(--mickey-yellow);
    border-radius: 50%;
    border: 4px solid var(--mickey-white);
    z-index: -1;
    opacity: 0.3;
}

/* ------------------------------------------------------------
   ANIMATIONS
------------------------------------------------------------ */
@keyframes float {
    0% { transform: translateY(0) rotate(0deg); }
    100% { transform: translateY(-100vh) rotate(360deg); }
}

@keyframes bounceIn {
    0% { transform: scale(0.5); opacity: 0; }
    70% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes slideUp {
    0% { 
        transform: translate(-50%, -40%); 
        opacity: 0; 
    }
    100% { 
        transform: translate(-50%, -50%); 
        opacity: 1; 
    }
}

@keyframes speakingPulse {
    0% { 
        transform: scale(1);
        box-shadow: 
            0 0 30px rgba(255, 107, 139, 0.7),
            0 0 60px rgba(255, 107, 139, 0.4);
    }
    100% { 
        transform: scale(1.05);
        box-shadow: 
            0 0 40px rgba(255, 107, 139, 0.9),
            0 0 80px rgba(255, 107, 139, 0.6);
    }
}

@keyframes waveExpand {
    0% {
        transform: translate(-50%, -45%) scale(0.8);
        opacity: 1;
        border-width: 2px;
    }
    100% {
        transform: translate(-50%, -45%) scale(1.5);
        opacity: 0;
        border-width: 1px;
    }
}

@keyframes textGlow {
    0% { text-shadow: 0 0 5px rgba(149, 225, 211, 0.5); }
    100% { text-shadow: 0 0 10px rgba(149, 225, 211, 0.8); }
}

@keyframes wavePulse {
    0%, 100% { 
        height: 10px;
        opacity: 0.5;
        transform: scaleY(1);
    }
    50% { 
        height: 25px;
        opacity: 1;
        transform: scaleY(1.3);
    }
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

@keyframes pulse-green {
    0% { box-shadow: 0 0 0 0 rgba(149, 225, 211, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(149, 225, 211, 0); }
    100% { box-shadow: 0 0 0 0 rgba(149, 225, 211, 0); }
}

@keyframes pulse-indicator {
    0% { box-shadow: 0 0 0 0 rgba(255, 107, 139, 0.7); }
    70% { box-shadow: 0 0 0 8px rgba(255, 107, 139, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255, 107, 139, 0); }
}

@keyframes pulse-indicator-blue {
    0% { box-shadow: 0 0 0 0 rgba(138, 198, 209, 0.7); }
    70% { box-shadow: 0 0 0 8px rgba(138, 198, 209, 0); }
    100% { box-shadow: 0 0 0 0 rgba(138, 198, 209, 0); }
}

/* ------------------------------------------------------------
   RESPONSIVE DESIGN
------------------------------------------------------------ */
@media (max-width: 1200px) {
    .modules-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 768px) {
    body {
        padding-top: 160px;
    }
    
    .fixed-header {
        padding: 10px;
    }
    
    .header-container {
        flex-direction: column;
        gap: 10px;
    }
    
    .header-nav {
        flex-wrap: wrap;
        justify-content: center;
    }
    
    .nav-tab {
        padding: 8px 15px;
        font-size: 0.9rem;
    }
    
    .side-collapsible {
        bottom: 20px;
        right: 20px;
    }
    
    .collapsible-controls {
        top: 160px;
        right: 20px;
    }
    
    .modules-grid {
        grid-template-columns: 1fr;
        gap: 20px;
        margin: 10px;
    }
    
    .game-options {
        grid-template-columns: 1fr;
    }
    
    .module-content-area {
        margin: 20px 10px;
        padding: 20px;
    }
    
    .tracing-area {
        grid-template-columns: 1fr;
    }
    
    .tracing-controls {
        flex-wrap: wrap;
    }
    
    .tracing-btn {
        min-width: calc(50% - 10px);
    }
    
    .welcome-content {
        width: 95%;
        margin: 20px;
        max-height: 95vh;
    }
    
    .welcome-header {
        padding: 20px 10px;
    }
    
    .welcome-header h1 {
        font-size: 1.8rem;
    }
    
    .welcome-message p {
        font-size: 1.1rem;
    }
    
    .welcome-features {
        flex-direction: column;
        gap: 15px;
    }
    
    .welcome-actions {
        flex-direction: column;
    }
    
    .welcome-body {
        padding: 20px;
        max-height: calc(95vh - 150px);
    }
    
    .forms-container {
        max-height: 300px;
    }
    
    .start-learning-btn, .explore-btn {
        padding: 12px 20px;
        font-size: 1.1rem;
    }
    
    /* Responsive poker card adjustments */
    .module-card {
        height: 350px;
    }
    
    .card-logo {
        width: 120px;
        height: 120px;
    }
    
    .card-logo i {
        font-size: 3.5rem;
    }

}

/* Add to your CSS */
.screen-status.auto-active {
    background: var(--mickey-green);
    color: white;
    border-color: var(--mickey-green);
}

.side-bubble.auto-active {
    background: var(--mickey-green) !important;
    animation: pulse-green 2s infinite;
}

.side-bubble.auto-active i {
    color: white !important;
}
    </style>
</head>
<body>
    <!-- ============================================
         HTML STRUCTURE
         Organized by component hierarchy
         ============================================ -->
    
    <!-- SPEAKING BOT OVERLAY (Full Screen) -->
    <div class="speaking-bot-overlay" id="speaking-bot-overlay">
        <div class="speaking-bot-container" id="speaking-bot-container">
            <!-- Bot speaker avatar -->
            <div class="bot-speaker-avatar">
                <div class="bot-speaker-circle" id="bot-speaker-circle">
                    <img src="images/toodles.png" alt="Speaking Bot" class="bot-speaker-img">
                </div>
                <!-- Speaker waves animation -->
                <div class="speaker-waves" id="speaker-waves">
                    <div class="speaker-wave"></div>
                    <div class="speaker-wave"></div>
                    <div class="speaker-wave"></div>
                </div>
            </div>
                    
            <!-- Continue button -->
            <button class="bot-speaker-continue" id="bot-speaker-continue">
                <i class="fas fa-check"></i> Continue
            </button>
        </div>
    </div>

    <!-- WELCOME SCREEN -->
    <div class="welcome-screen" id="welcome-screen">
        <div class="welcome-content">
            <div class="welcome-header">
                <div class="mickey-welcome-logo">
                    <img src="images/Mickey_Mouse_Clubhouse_logo.png" alt="Mickey Mouse Clubhouse" class="user-photo-img">
                    <h1>Welcome to Mickey's Learning Hub!</h1>
                </div>
            </div>
            <div class="welcome-body">
                
                <!-- FORMS CONTAINER -->
                <div class="forms-container" id="forms-container">
                    <!-- BUTTONS ONLY - NO FORMS INITIALLY -->
                    <div class="welcome-actions" id="welcome-buttons">
                        <button class="start-learning-btn" id="show-login-btn">
                            <i class="fas fa-sign-in-alt"></i> Login Now
                        </button>
                        <button class="explore-btn" id="show-register-btn">
                            <i class="fas fa-user-plus"></i> Register Now
                        </button>
                    </div>
                    
                    <!-- LOGIN FORM (HIDDEN BY DEFAULT) -->
                    <div id="login-form-container" class="form-container">
                        <h3 class="form-title">
                            <i class="fas fa-sign-in-alt"></i> Login
                        </h3>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-user"></i> Username
                            </label>
                            <input type="text" id="login-username" 
                                placeholder="Enter your username" 
                                class="form-input">
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-key"></i> Password
                            </label>
                            <input type="password" id="login-password" 
                                placeholder="Enter your password" 
                                class="form-input">
                        </div>
                        
                        <div class="remember-me">
                            <input type="checkbox" id="remember-me">
                            <label for="remember-me">Remember me</label>
                        </div>
                        
                        <button class="start-learning-btn form-submit-btn" onclick="submitLogin()">
                            <i class="fas fa-sign-in-alt"></i> Login Now
                        </button>
                        
                        <!-- Demo credentials -->
                        <div class="demo-credentials">
                            <p class="demo-title">
                                <strong><i class="fas fa-lightbulb"></i> Demo Credentials:</strong>
                            </p>
                            <div class="credentials-list">
                                <div class="credential-item student-cred">
                                    <i class="fas fa-user-graduate credential-icon"></i>
                                    <span class="credential-label">Student:</span>
                                    <code class="credential-username">student123</code>
                                    <span class="credential-separator">/</span>
                                    <code class="credential-password">student123</code>
                                </div>
                                <div class="credential-item teacher-cred">
                                    <i class="fas fa-chalkboard-teacher credential-icon"></i>
                                    <span class="credential-label">Teacher:</span>
                                    <code class="credential-username">teacher123</code>
                                    <span class="credential-separator">/</span>
                                    <code class="credential-password">teacher123</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-footer">
                            <p>
                                Don't have an account? 
                                <a href="#" onclick="showRegisterForm()" class="form-link">
                                    Register here
                                </a>
                            </p>
                        </div>
                    </div>
                    
                    <!-- REGISTER FORM (HIDDEN BY DEFAULT) -->
                    <div id="register-form-container" class="form-container">
                        <h3 class="form-title">
                            <i class="fas fa-user-plus"></i> Register
                        </h3>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-user"></i> Full Name
                            </label>
                            <input type="text" id="register-name" 
                                placeholder="Enter your full name" 
                                class="form-input">
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-at"></i> Username
                            </label>
                            <input type="text" id="register-username" 
                                placeholder="Choose a username" 
                                class="form-input">
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-key"></i> Password
                            </label>
                            <input type="password" id="register-password" 
                                placeholder="Create a password" 
                                class="form-input">
                            <div class="password-hint">
                                <i class="fas fa-info-circle"></i> Must be at least 6 characters
                            </div>
                        </div>
                        
                        <div class="form-field">
                            <label class="form-label">
                                <i class="fas fa-user-tag"></i> I am a...
                            </label>
                            <select id="register-role" class="form-select">
                                <option value="student">Student</option>
                                <option value="teacher">Teacher</option>
                                <option value="parent">Parent</option>
                            </select>
                        </div>
                        
                        <button class="explore-btn form-submit-btn" onclick="submitRegistration()">
                            <i class="fas fa-check"></i> Create Account
                        </button>
                        
                        <div class="form-footer">
                            <p>
                                Already have an account? 
                                <a href="#" onclick="showLoginForm()" class="form-link">
                                    Login here
                                </a>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- FIXED HEADER -->
    <header class="fixed-header">
        <div class="header-container">
            <div class="header-logo">
                <div class="logo-icon">
                    <i class="fas fa-graduation-cap"></i>
                </div>
                <span>Mickey's Learning Hub</span>
            </div>
            
            <nav class="header-nav">
                <a href="#" class="nav-tab active" id="game-tab">
                    <i class="fas fa-gamepad"></i> Game Center
                </a>
                <a href="#" class="nav-tab" id="profile-tab">
                    <i class="fas fa-user"></i> Profile
                </a>
                <a href="#" class="nav-tab" id="about-tab">
                    <i class="fas fa-info-circle"></i> About Us
                </a>
                <a href="#" class="nav-tab" id="settings-tab">
                    <i class="fas fa-cog"></i> Settings
                </a>
            </nav>
        </div>
    </header>

</div>

<script>
function testGame(gameName) {
    console.log('Testing game:', gameName);
    startGame(gameName);
}
</script>    
    <!-- SIDE BUBBLES -->
    <div class="side-collapsible" id="side-collapsible">
        <div class="side-toggle" id="side-toggle">
            <i class="fas fa-plus"></i>
        </div>
        <div class="side-bubbles" id="side-bubbles">
            <!-- Emotion Camera Bubble -->
            <div class="side-bubble emotion-camera" id="side-emotion-camera" title="Emotion Detection">
                <i class="fas fa-smile"></i>
                <div class="camera-status-dot" id="emotion-status-dot"></div>
            </div>
            
            <!-- Eye Tracking Camera Bubble -->
            <div class="side-bubble eye-camera" id="side-eye-camera" title="Eye Tracking">
                <i class="fas fa-eye"></i>
                <div class="camera-status-dot" id="eye-status-dot"></div>
            </div>
            
            <!-- Speaking Bot Bubble -->
            <div class="side-bubble speaking-bot" id="side-speaking-bot" title="Click to talk">
                <i class="fas fa-microphone"></i>
                <div class="bot-message-indicator" id="bot-message-indicator"></div>
            </div>
        </div>
    </div>

    <!-- Camera Status Indicators -->
    <div class="camera-status-indicators" id="camera-status-indicators">
        <div class="camera-indicator emotion-indicator" id="emotion-indicator" title="Emotion Detection Active"></div>
        <div class="camera-indicator eye-indicator" id="eye-indicator" title="Eye Tracking Active"></div>
    </div>

    <!-- CAMERA COLLAPSIBLE CONTENT -->
    <div class="collapsible-controls" id="collapsible-controls">
        <div class="collapsible-content" id="camera-content">
            <button class="collapsible-close-btn" id="close-camera-content" title="Close camera panel">
                <i class="fas fa-times"></i>
            </button>
            <div class="camera-container">
                <!-- Dual Detection Screens -->
                <div class="dual-screen-container">
                    <!-- Emotion Detection Screen -->
                    <div class="detection-screen" id="emotion-screen">
                        <div class="screen-header">
                            <div class="screen-title">
                                <i class="fas fa-smile"></i> Emotion Detection
                            </div>
                            <div class="screen-status" id="emotion-status">
                                <i class="fas fa-circle"></i> AUTO-ONLY (In Game)
                            </div>
                        </div>
                        
                        <div class="video-container">
                            <video id="emotion-video" class="detection-video" playsinline muted></video>
                            <canvas id="emotion-overlay" class="detection-overlay"></canvas>
                            <div class="emotion-info" id="emotion-info">
                                Status: Waiting for game to start
                            </div>
                        </div>
                        
                        <div class="detection-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="emotion-face-count">-</div>
                                <div class="stat-label">Faces</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="emotion-confidence">-</div>
                                <div class="stat-label">Confidence</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Eye Tracking Screen -->
                    <div class="detection-screen" id="eye-screen">
                        <div class="screen-header">
                            <div class="screen-title">
                                <i class="fas fa-eye"></i> Eye Tracking
                            </div>
                            <div class="screen-status" id="eye-status">
                                <i class="fas fa-circle"></i> AUTO-ONLY (In Game)
                            </div>
                        </div>
                        
                        <!-- CHANGE THIS PART - make it identical to emotion detection -->
                        <div class="video-container">
                            <!-- Add video element just like emotion -->
                            <video id="eye-video" class="detection-video" playsinline muted></video>
                            <!-- Keep the canvas for drawing overlays -->
                            <canvas id="eye-tracking-canvas" class="detection-overlay"></canvas>
                            
                            <div class="focus-status" id="focus-status">
                                <div class="status-dot status-unknown"></div>
                                <span>Eye: Waiting for game</span>
                            </div>
                            <div class="iris-info" id="iris-info">
                                Status: Waiting for game to start
                            </div>
                        </div>
                        
                        <div class="detection-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="eye-iris-confidence">-</div>
                                <div class="stat-label">Iris Conf</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="focus-direction">-</div>
                                <div class="stat-label">Direction</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="eye-score">-</div>
                                <div class="stat-label">Eye Score</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="eye-alignment-score">-</div>
                                <div class="stat-label">Alignment</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- REMOVE ALL CONTROL BUTTONS - REPLACE WITH INFO MESSAGE -->
                <div class="detection-status-panel" id="detection-status" style="margin-top: 20px;">
                    <div class="status-header">
                        <div class="status-icon">
                            <i class="fas fa-gamepad"></i>
                        </div>
                        <div class="status-title">
                            AUTO-ACTIVATION SYSTEM
                        </div>
                    </div>
                    <div class="status-message">
                        <br><br>
                        <i class="fas fa-info-circle"></i> Start any game from the Game Center to begin monitoring.
                    </div>
                </div>
            </div>
        </div>
    </div>
        
    <!-- GAME CENTER CONTENT AREA (DEFAULT ACTIVE) -->
    <div class="content-area active" id="game-center-content-area">
        <!-- LEARNING HUB -->
        <main class="learning-hub">
            <!-- MICKEY MOUSE DECORATIONS -->
            <div class="polka-dot" style="top: 10%; left: 5%;"></div>
            <div class="polka-dot" style="top: 20%; right: 10%;"></div>
            <div class="polka-dot" style="bottom: 30%; left: 15%;"></div>
            <div class="mickey-dot" style="top: 15%; right: 20%; animation-delay: -5s;"></div>
            <div class="mickey-dot" style="top: 40%; left: 8%; animation-delay: -10s;"></div>
            
            <!-- MICKEY MOUSE HEADER -->
            <div class="mickey-header">
                <h1>MICKEY'S EMPATHIC LEARNING HUB</h1>
            </div>
            
<!-- LEARNING CONTENT GRID -->
<div class="modules-grid">

    <!-- GAME 1: LETTER INTRODUCTION -->
    <div class="module-card" data-module="letters">
        <!-- Poker suits decoration -->
        <div class="poker-suit heart">‚ô•</div>
        <div class="poker-suit diamond">‚ô¶</div>
        <div class="poker-suit club">‚ô£</div>
        <div class="poker-suit spade">‚ô†</div>
        
        <div class="card-logo">
            <i class="fas fa-font"></i>
        </div>
        
        <h3>Letter Explorer</h3>
        <p>
            Learn letter recognition, shapes, and sounds.
        </p>
        
        <button class="play-btn" onclick="startGame('letters')">
            <i class="fas fa-play"></i> Play Now
        </button>
        
        <div class="reward">‚≠ê +10 XP</div>
    </div>
    
    <!-- GAME 2: VOWEL / CONSONANT -->
    <div class="module-card" data-module="vowels">
        <!-- Poker suits decoration -->
        <div class="poker-suit heart">‚ô•</div>
        <div class="poker-suit diamond">‚ô¶</div>
        <div class="poker-suit club">‚ô£</div>
        <div class="poker-suit spade">‚ô†</div>
        
        <div class="card-logo">
            <i class="fas fa-volume-up"></i>
        </div>
        
        <h3>Vowel Fun</h3>
        <p>
            Identify vowels and consonants with sounds and examples.
        </p>
        
        <button class="play-btn" onclick="startGame('vowels')">
            <i class="fas fa-play"></i> Play Now
        </button>
        
        <div class="reward">‚≠ê +12 XP</div>
    </div>

    <!-- GAME 3: WORD SPELLING -->
    <div class="module-card" data-module="spelling">
        <!-- Poker suits decoration -->
        <div class="poker-suit heart">‚ô•</div>
        <div class="poker-suit diamond">‚ô¶</div>
        <div class="poker-suit club">‚ô£</div>
        <div class="poker-suit spade">‚ô†</div>
        
        <div class="card-logo">
            <i class="fas fa-spell-check"></i>
        </div>
        
        <h3>Word Builder</h3>
        <p>
            Build and read simple words using phonics-based activities.
        </p>
        
        <button class="play-btn" onclick="startGame('spelling')">
            <i class="fas fa-play"></i> Play Now
        </button>
        
        <div class="reward">‚≠ê +15 XP</div>
    </div>

    <!-- GAME 4: LETTER TRACING -->
    <div class="module-card" data-module="tracing">
        <!-- Poker suits decoration -->
        <div class="poker-suit heart">‚ô•</div>
        <div class="poker-suit diamond">‚ô¶</div>
        <div class="poker-suit club">‚ô£</div>
        <div class="poker-suit spade">‚ô†</div>
        
        <div class="card-logo">
            <i class="fas fa-pen-nib"></i>
        </div>
        
        <h3>Letter Tracer</h3>
        <p>
            Practice writing letters using guided tracing exercises.
        </p>
        
        <button class="play-btn" onclick="startGame('tracing')">
            <i class="fas fa-pen-fancy"></i> Start Tracing
        </button>
        
        <div class="reward">‚≠ê +8 XP</div>
    </div>

</div>
        </main>
    </div>
    
            <!-- ENHANCED PROFILE CONTENT AREA -->
            <div class="content-area" id="profile-content-area">
                <div class="profile-content">
                    <h2 style="color: var(--mickey-red); text-align: center; margin-bottom: 30px;">
                        <i class="fas fa-user-graduate"></i> Student Profile & Analysis
                    </h2>
                    
                    <div class="student-profile">
                        <div class="profile-header">
                            <div class="avatar" style="width: 80px; height: 80px; background: var(--mickey-yellow); 
                                                    border-radius: 50%; border: 4px solid var(--mickey-black);
                                                    display: flex; align-items: center; justify-content: center;
                                                    font-size: 2rem; color: var(--mickey-red);">
                                <i class="fas fa-user"></i>
                            </div>
                            <div>
                                <h3 style="margin: 0; color: var(--mickey-red);">Student Progress Dashboard</h3>
                                <p style="margin: 5px 0; color: var(--mickey-blue); font-family: 'Comic Neue', cursive;">
                                    <i class="fas fa-star"></i> 
                                    <span id="student-points">150</span> Mickey Points
                                </p>
                            </div>
                        </div>
                        
                        <!-- PROGRESS OVERVIEW -->
                        <div class="progress-overview" style="margin: 30px 0; background: var(--mickey-white); 
                                                            padding: 20px; border-radius: 15px; border: 4px solid var(--mickey-black);">
                            <h4 style="color: var(--mickey-blue); margin-bottom: 15px;">
                                <i class="fas fa-chart-line"></i> Overall Progress
                            </h4>
                            <div class="game-progress">
                                <div class="progress-bar" id="overall-progress" style="width: 40%"></div>
                                <div class="progress-text">40% Complete</div>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
                                        gap: 15px; margin-top: 20px;">
                                <div class="stat-card" style="background: var(--mickey-pink); padding: 15px; 
                                                            border-radius: 10px; border: 3px solid var(--mickey-black);">
                                    <div style="font-size: 2rem; color: var(--mickey-red);">
                                        <i class="fas fa-clock"></i>
                                    </div>
                                    <div style="font-weight: bold; color: var(--mickey-black);">Time Spent</div>
                                    <div style="font-size: 1.5rem; color: var(--mickey-blue);">45 min</div>
                                </div>
                                
                                <div class="stat-card" style="background: var(--mickey-green); padding: 15px; 
                                                            border-radius: 10px; border: 3px solid var(--mickey-black);">
                                    <div style="font-size: 2rem; color: var(--mickey-red);">
                                        <i class="fas fa-trophy"></i>
                                    </div>
                                    <div style="font-weight: bold; color: var(--mickey-black);">Games Completed</div>
                                    <div style="font-size: 1.5rem; color: var(--mickey-blue);" id="games-completed">2/4</div>
                                </div>
                                
                                <div class="stat-card" style="background: var(--mickey-purple); padding: 15px; 
                                                            border-radius: 10px; border: 3px solid var(--mickey-black);">
                                    <div style="font-size: 2rem; color: var(--mickey-red);">
                                        <i class="fas fa-bolt"></i>
                                    </div>
                                    <div style="font-weight: bold; color: var(--mickey-black);">Focus Level</div>
                                    <div style="font-size: 1.5rem; color: var(--mickey-blue);" id="focus-level">75%</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Progress Dashboard -->
                        <div id="progress-dashboard" style="margin-top: 30px;">
                            
                        </div>

                        <!-- PERFORMANCE SECTION -->
                        <div class="performance-section" style="margin-top: 40px; background: var(--mickey-white); 
                        padding: 25px; border-radius: 20px; border: 4px solid var(--mickey-black);">
                        <h3 style="color: var(--mickey-red); margin-top: 0; display: flex; align-items: center; gap: 10px;">
                            <i class="fas fa-tachometer-alt"></i> System Performance Dashboard
                        </h3>
                        
                        <!-- Performance Stats Grid -->
                        <div class="performance-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
                            gap: 15px; margin-bottom: 20px;">
                            
                            <!-- Calculation Performance -->
                            <div class="performance-card" style="background: var(--mickey-green); padding: 15px; 
                                border-radius: 15px; border: 3px solid var(--mickey-black);">
                                <div style="font-size: 1.8rem; color: white; margin-bottom: 10px;">
                                    <i class="fas fa-calculator"></i>
                                </div>
                                <div style="font-weight: bold; color: white;">Calculations</div>
                                <div style="font-size: 1.5rem; color: var(--mickey-yellow);" id="total-calculations">0</div>
                                <div style="font-size: 0.9rem; color: white;" id="calc-speed">Avg: 0ms</div>
                            </div>
                            
                            <!-- Focus Detection -->
                            <div class="performance-card" style="background: var(--mickey-blue); padding: 15px; 
                                border-radius: 15px; border: 3px solid var(--mickey-black);">
                                <div style="font-size: 1.8rem; color: white; margin-bottom: 10px;">
                                    <i class="fas fa-eye"></i>
                                </div>
                                <div style="font-weight: bold; color: white;">Focus Detection</div>
                                <div style="font-size: 1.5rem; color: var(--mickey-yellow);" id="focus-accuracy">0%</div>
                                <div style="font-size: 0.9rem; color: white;" id="focus-status">Status: Inactive</div>
                            </div>
                            
                            <!-- Emotion Detection -->
                            <div class="performance-card" style="background: var(--mickey-pink); padding: 15px; 
                                border-radius: 15px; border: 3px solid var(--mickey-black);">
                                <div style="font-size: 1.8rem; color: white; margin-bottom: 10px;">
                                    <i class="fas fa-smile"></i>
                                </div>
                                <div style="font-weight: bold; color: white;">Emotion Detection</div>
                                <div style="font-size: 1.5rem; color: var(--mickey-yellow);" id="emotion-accuracy">0%</div>
                                <div style="font-size: 0.9rem; color: white;" id="emotion-status">Status: Inactive</div>
                            </div>
                            
                            <!-- System Health -->
                            <div class="performance-card" style="background: var(--mickey-purple); padding: 15px; 
                                border-radius: 15px; border: 3px solid var(--mickey-black);">
                                <div style="font-size: 1.8rem; color: white; margin-bottom: 10px;">
                                    <i class="fas fa-heartbeat"></i>
                                </div>
                                <div style="font-weight: bold; color: white;">System Health</div>
                                <div style="font-size: 1.5rem; color: var(--mickey-yellow);" id="system-health">100%</div>
                                <div style="font-size: 0.9rem; color: white;" id="last-update">Last update: -</div>
                            </div>
                        </div>
                        
                        <!-- Performance Controls -->
                        <div class="performance-controls" style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="module-btn" onclick="refreshPerformanceData()" 
                                    style="background: var(--mickey-yellow); color: var(--mickey-black); flex: 1;">
                                <i class="fas fa-sync-alt"></i> Refresh Performance Data
                            </button>
                            <button class="module-btn" onclick="showDetailedPerformance()" 
                                    style="background: var(--mickey-blue); color: white; flex: 1;">
                                <i class="fas fa-chart-bar"></i> Detailed Report
                            </button>
                            <button class="module-btn" onclick="resetPerformanceCounters()" 
                                    style="background: var(--mickey-pink); color: white; flex: 1;">
                                <i class="fas fa-redo"></i> Reset Counters
                            </button>
                        </div>
                        
                        <!-- Performance Progress Bars -->
                        <div class="performance-progress" style="margin-top: 25px;">
                            <h4 style="color: var(--mickey-black); margin-bottom: 15px;">
                                <i class="fas fa-chart-line"></i> Real-time Performance Metrics
                            </h4>
                            
                            <div style="margin-bottom: 15px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive;">
                                        <i class="fas fa-bolt"></i> Calculation Speed
                                    </span>
                                    <span style="color: var(--mickey-red); font-weight: bold;" id="calc-speed-text">0ms avg</span>
                                </div>
                                <div class="progress-bar" style="height: 12px; background: var(--mickey-white); 
                                    border-radius: 6px; border: 2px solid var(--mickey-black); overflow: hidden;">
                                    <div id="calc-speed-bar" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); 
                                        width: 0%; transition: width 0.5s ease;"></div>
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive;">
                                        <i class="fas fa-brain"></i> Focus Detection Accuracy
                                    </span>
                                    <span style="color: var(--mickey-red); font-weight: bold;" id="focus-accuracy-text">0%</span>
                                </div>
                                <div class="progress-bar" style="height: 12px; background: var(--mickey-white); 
                                    border-radius: 6px; border: 2px solid var(--mickey-black); overflow: hidden;">
                                    <div id="focus-accuracy-bar" style="height: 100%; background: linear-gradient(90deg, #2196F3, #03A9F4); 
                                        width: 0%; transition: width 0.5s ease;"></div>
                                </div>
                            </div>
                            
                            <div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive;">
                                        <i class="fas fa-laugh"></i> Emotion Detection Confidence
                                    </span>
                                    <span style="color: var(--mickey-red); font-weight: bold;" id="emotion-confidence-text">0%</span>
                                </div>
                                <div class="progress-bar" style="height: 12px; background: var(--mickey-white); 
                                    border-radius: 6px; border: 2px solid var(--mickey-black); overflow: hidden;">
                                    <div id="emotion-confidence-bar" style="height: 100%; background: linear-gradient(90deg, #E91E63, #FF4081); 
                                        width: 0%; transition: width 0.5s ease;"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    </div>
                </div>
            </div>
    
            <!-- ABOUT US CONTENT AREA -->
            <div class="content-area" id="about-content-area">
                <div class="about-content">
                    <h2 style="color: var(--mickey-red); text-align: center; margin-bottom: 30px;">
                        <i class="fas fa-info-circle"></i> About Mickey's Learning Hub
                    </h2>
                    
                    <div style="text-align: center; max-width: 800px; margin: 0 auto;">
                        <div style="font-size: 4rem; color: var(--mickey-red); margin-bottom: 20px;">
                            <i class="fas fa-heart"></i>
                        </div>
                        <h3 style="color: var(--mickey-blue); margin-bottom: 20px;">Our Mission</h3>
                        <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.2rem; line-height: 1.6; margin-bottom: 30px;">
                            Welcome to Mickey's Enhanced Empathic Learning Hub! We're dedicated to creating a fun, engaging, and supportive learning environment for children of all abilities, with special focus on dyslexia support.
                        </p>
                    </div>
                </div>
            </div>
    
            <!-- SETTINGS CONTENT AREA -->
            <div class="content-area" id="settings-content-area">
                <div class="settings-content">
                    <h2 style="color: var(--mickey-red); text-align: center; margin-bottom: 30px;">
                        <i class="fas fa-cog"></i> Settings & Preferences
                    </h2>
                    
                    <div style="max-width: 800px; margin: 0 auto;">
                        <div style="background: var(--mickey-white); padding: 30px; border-radius: 20px; border: 4px solid var(--mickey-black); margin-bottom: 30px;">
                            <h3 style="color: var(--mickey-red); margin-bottom: 20px;">Accessibility Settings</h3>
                            
                            <div style="background: var(--mickey-yellow); padding: 20px; border-radius: 15px; border: 3px solid var(--mickey-black); margin-bottom: 20px;">
                                <h4 style="color: var(--mickey-black); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-book-reader"></i> Dyslexia Mode
                                </h4>
                                <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; margin-bottom: 15px;">
                                    Toggle dyslexia-friendly font and spacing
                                </p>
                                <button class="module-btn" id="toggle-dyslexia" style="width: 100%;">
                                    <i class="fas fa-toggle-on"></i> Toggle Dyslexia Mode
                                </button>
                            </div>
                            
                            <h3 style="color: var(--mickey-red); margin-bottom: 20px;">Auto-Detection System</h3>
                            <div style="background: var(--mickey-yellow); padding: 20px; border-radius: 15px; border: 3px solid var(--mickey-black);">
                                <h4 style="color: var(--mickey-black); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-camera"></i> AUTO Game Monitoring
                                </h4>
                                <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; margin-bottom: 15px;">
                                    Status: <span id="detection-status-text" style="color: var(--mickey-blue); font-weight: bold;">
                                        AUTO-ONLY (Start Game to Activate)
                                    </span>
                                </p>
                                <div style="background: var(--mickey-white); padding: 15px; border-radius: 10px; border: 2px solid var(--mickey-black); margin-bottom: 15px;">
                                    <p style="color: var(--mickey-black); margin: 0; font-size: 0.9rem;">
                                        <i class="fas fa-info-circle"></i> 
                                        <strong>Auto-Activation:</strong> Both emotion detection and eye tracking 
                                        automatically activate when you start playing any game.
                                    </p>
                                </div>
                                <button class="module-btn" onclick="openCameraPanel()" style="width: 100%; background: var(--mickey-blue); color: white;">
                                    <i class="fas fa-eye"></i> View Detection Status
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
    
            <!-- MODULE CONTENT AREA -->
            <div class="module-content-area" id="module-content">
                <div class="content-header">
                    <h2 id="module-content-title" style="color: var(--mickey-red); margin: 0;"></h2>
                    <button class="close-module" id="close-module">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="content-body" id="module-content-body">
                    <!-- Dynamic content will be loaded here -->
                </div>
            </div>

            <!-- TRACING GAME CONTAINER -->
            <div class="tracing-game-container" id="tracing-game-container" style="display: none;">
                <div class="tracing-header">
                    <h3 style="color: var(--mickey-red);">Trace the Letter</h3>
                    <div class="tracing-instructions">
                        <i class="fas fa-hand-point-up"></i>
                        Follow the dotted line with your mouse or finger
                    </div>
                </div>
                
                <div class="tracing-area">
                    <!-- Letter display -->
                    <div class="letter-display">
                        <div class="target-letter" id="target-letter">A</div>
                        <div class="letter-sound">
                            <button id="play-sound-btn" class="tracing-btn">
                                <i class="fas fa-volume-up"></i> Listen to sound
                            </button>
                        </div>
                    </div>
                    
                    <!-- Tracing canvas -->
                    <div class="canvas-container">
                        <canvas id="tracing-canvas"></canvas>
                        <div class="tracing-overlay">
                            <div class="start-dot"></div>
                            <div class="trace-guide"></div>
                        </div>
                    </div>
                    
                    <!-- Controls -->
                    <div class="tracing-controls">
                        <button id="clear-trace" class="tracing-btn">
                            <i class="fas fa-eraser"></i> Clear
                        </button>
                        <button id="check-trace" class="tracing-btn success">
                            <i class="fas fa-check"></i> Check
                        </button>
                        <button id="hint-trace" class="tracing-btn hint">
                            <i class="fas fa-lightbulb"></i> Show Hint
                        </button>
                        <button id="auto-trace" class="tracing-btn demo">
                            <i class="fas fa-magic"></i> Show Me How
                        </button>
                    </div>
                    
                    <!-- Feedback -->
                    <div class="tracing-feedback" id="tracing-feedback"></div>
                    
                    <!-- Progress -->
                    <div class="tracing-progress">
                        <div class="tracing-progress-bar">
                            <div class="tracing-progress-fill" id="trace-progress"></div>
                        </div>
                        <div class="progress-text">
                            Accuracy: <span id="trace-accuracy">0%</span>
                        </div>
                    </div>
                    
                    <!-- Navigation -->
                    <div class="game-navigation" style="margin-top: 30px;">
                        <button class="nav-btn" id="prev-tracing" onclick="prevTracingActivity()">
                            <i class="fas fa-arrow-left"></i> Previous
                        </button>
                        <div class="game-counter" id="tracing-counter">Activity 1 of 5</div>
                        <button class="nav-btn" id="next-tracing" onclick="nextTracingActivity()">
                            Next <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                </div>
            </div>

    <!-- ============================================
         EXTERNAL LIBRARIES
         ============================================ -->
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/human.js"></script>

    <!-- ============================================
         JAVASCRIPT CODE
         Organized by functionality and component
         ============================================ -->
    <script>
        
        // ============================================
        // CONSOLIDATED CALCULATION FUNCTIONS SECTION
        // ============================================

        class CalculationManager {
            constructor() {
                this.calculationCache = {};
                this.performanceStats = {
                    calculations: 0,
                    lastCalculation: null,
                    averageTime: 0,
                    maxTime: 0,
                    minTime: 999,
                    history: []
                };
                
                // Tracking for new formulas
                this.focusTracking = {
                    tabSwitches: 0,
                    inactiveMinutes: 0,
                    eyeData: {
                        eyeComponent: 0,
                        irisComponent: 0,
                        fixationTime: 1 // Default to prevent division by zero
                    },
                    activityData: {
                        keyboardScore: 0.5,
                        mouseScore: 0.5
                    }
                };
                  
                // Add focus detection tracking
                this.focusDetectionStats = {
                    successful: 0,
                    failed: 0,
                    total: 0,
                    accuracy: 0,
                    lastDetection: null
                };
                
                // Add emotion detection tracking
                this.emotionDetectionStats = {
                    detections: 0,
                    lastEmotion: null,
                    lastConfidence: 0
                };

                this.systemStartTime = Date.now();
            }

                trackFocusDetection(isSuccessful, confidence) {
            const startTime = performance.now();
            
            this.focusDetectionStats.total++;
            
            if (isSuccessful) {
                this.focusDetectionStats.successful++;
            } else {
                this.focusDetectionStats.failed++;
            }
            
            // Calculate accuracy
            this.focusDetectionStats.accuracy = 
                (this.focusDetectionStats.successful / this.focusDetectionStats.total) * 100;
            
            this.focusDetectionStats.lastDetection = new Date().toISOString();
            
            // Also track this as a calculation for performance stats
            this.trackPerformance(startTime);
            
            // Update performance display
            this.updateFocusDetectionDisplay();
            
            return {
                successful: this.focusDetectionStats.successful,
                failed: this.focusDetectionStats.failed,
                accuracy: Math.round(this.focusDetectionStats.accuracy),
                total: this.focusDetectionStats.total
            };
        }
    
    // ADD THIS METHOD TOO
    trackEmotionDetection(emotion, confidence) {
        const startTime = performance.now();
        
        this.emotionDetectionStats.detections++;
        this.emotionDetectionStats.lastEmotion = emotion;
        this.emotionDetectionStats.lastConfidence = confidence;
        
        this.trackPerformance(startTime);
        
        // Update performance display
        this.updateEmotionDetectionDisplay();
        
        return {
            detections: this.emotionDetectionStats.detections,
            lastEmotion: emotion,
            lastConfidence: Math.round(confidence * 100)
        };
    }

        updateFocusDetectionDisplay() {
        // Update UI elements
        const focusAccuracyElement = document.getElementById('focus-accuracy');
        const focusStatusElement = document.getElementById('focus-status');
        
        if (focusAccuracyElement) {
            focusAccuracyElement.textContent = `${Math.round(this.focusDetectionStats.accuracy)}%`;
        }
        
        if (focusStatusElement) {
            focusStatusElement.textContent = `Status: ${this.focusDetectionStats.total > 0 ? 'Active' : 'Inactive'}`;
        }
    }
    
    updateEmotionDetectionDisplay() {
        // Update UI elements
        const emotionAccuracyElement = document.getElementById('emotion-accuracy');
        const emotionStatusElement = document.getElementById('emotion-status');
        
        if (emotionAccuracyElement) {
            emotionAccuracyElement.textContent = `${Math.round(this.emotionDetectionStats.lastConfidence * 100)}%`;
        }
        
        if (emotionStatusElement) {
            const status = this.emotionDetectionStats.detections > 0 ? 
                `Detected: ${this.emotionDetectionStats.lastEmotion}` : 
                'Status: Inactive';
            emotionStatusElement.textContent = status;
        }
    }
    // Add these methods to get performance data for the profile
    getProfilePerformanceData() {
        return {
            totalCalculations: this.performanceStats.calculations,
            averageCalcTime: Math.round(this.performanceStats.averageTime * 100) / 100,
            minCalcTime: Math.round(this.performanceStats.minTime * 100) / 100,
            maxCalcTime: Math.round(this.performanceStats.maxTime * 100) / 100,
            focusDetections: this.focusDetectionStats.total,
            focusAccuracy: Math.round(this.focusDetectionStats.accuracy),
            emotionDetections: this.emotionDetectionStats.detections,
            emotionConfidence: Math.round(this.emotionDetectionStats.lastConfidence * 100),
            lastEmotion: this.emotionDetectionStats.lastEmotion || 'None',
            systemHealth: this.calculateSystemHealth(),
            lastUpdate: new Date().toLocaleTimeString(),
            uptime: this.formatUptime()
        };
    }
    
    calculateSystemHealth() {
        // Simple system health calculation
        const calculationHealth = Math.max(0, 100 - (this.performanceStats.averageTime));
        const focusHealth = this.focusDetectionStats.accuracy;
        const emotionHealth = this.emotionDetectionStats.lastConfidence * 100;
        
        return Math.round((calculationHealth + focusHealth + emotionHealth) / 3);
    }
    
    formatUptime() {
        const uptimeMs = Date.now() - this.systemStartTime;
        const hours = Math.floor(uptimeMs / 3600000);
        const minutes = Math.floor((uptimeMs % 3600000) / 60000);
        
        return `${hours}h ${minutes}m`;
    }
    
            // Formula 1: Focus Score = (Tab_Score √ó 0.3) + (Eye_Score √ó 0.5) + (Activity_Score √ó 0.2)
            calculateFocusScore() {
                const startTime = performance.now();
                
                // Get tab switching data from the tab tracker
                let tabSwitchData = {
                    switches: 0,
                    inactiveMinutes: 0
                };
                
                if (window.tabTracker) {
                    const report = window.tabTracker.getFocusReport();
                    tabSwitchData.switches = report.tabSwitchCount || 0;
                    tabSwitchData.inactiveMinutes = report.inactiveMinutes || 0;
                }
                
                // Tab_Score = 1 - (Tab_Switches √ó 0.5) - (Inactive_Minutes √ó 0.2)
                const tabScore = this.calculateTabScore(tabSwitchData.switches, tabSwitchData.inactiveMinutes);
                
                // Get eye tracking data (if available)
                let eyeComponent = this.focusTracking.eyeData.eyeComponent || 0;
                let irisComponent = this.focusTracking.eyeData.irisComponent || 0;
                let fixationTime = Math.max(1, this.focusTracking.eyeData.fixationTime);
                
                // If dualCameraDetection is available, use real eye data
                if (window.dualCameraDetection && window.dualCameraDetection.irisData) {
                    // Get actual eye tracking data
                    const irisData = window.dualCameraDetection.irisData;
                    eyeComponent = irisData.confidence || 0;
                    
                    // Calculate iris component based on distance from center
                    const distanceFromCenter = irisData.center ? 
                        Math.sqrt(Math.pow(irisData.center.x - 0.5, 2) + Math.pow(irisData.center.y - 0.5, 2)) : 0.5;
                    irisComponent = Math.max(0, 1 - (distanceFromCenter * 2));
                }
                
                // Eye_Score = ((Eye_Component √ó 0.3) + (Iris_Component √ó 0.5)) / Fixation_Time
                const eyeScore = this.calculateEyeScore(eyeComponent, irisComponent, fixationTime);
                
                // Activity_Score (keyboard/mouse activity)
                const keyboardScore = this.focusTracking.activityData.keyboardScore || 0.5;
                const mouseScore = this.focusTracking.activityData.mouseScore || 0.5;
                const activityScore = this.calculateActivityScore(keyboardScore, mouseScore);
                
                // Final Focus Score = (Tab_Score √ó 0.3) + (Eye_Score √ó 0.5) + (Activity_Score √ó 0.2)
                const focusScore = (tabScore * 0.3) + (eyeScore * 0.5) + (activityScore * 0.2);
                
                const result = {
                    score: Math.max(0, Math.min(100, focusScore * 100)),
                    level: this.getFocusLevel(focusScore),
                    components: {
                        tabScore: Math.round(tabScore * 100),
                        eyeScore: Math.round(eyeScore * 100),
                        activityScore: Math.round(activityScore * 100)
                    },
                    raw: {
                        focusScore: focusScore,
                        tabScore: tabScore,
                        eyeScore: eyeScore,
                        activityScore: activityScore,
                        tabSwitches: tabSwitchData.switches,
                        inactiveMinutes: tabSwitchData.inactiveMinutes
                    }
                };
                
                this.trackPerformance(startTime);
                
                // Update the focus score display
                this.updateFocusScoreDisplay(result);
                
                return result;
            }

            calculateTabScore(tabSwitches, inactiveMinutes) {
                // Tab_Score = 1 - (Tab_Switches √ó 0.5) - (Inactive_Minutes √ó 0.2)
                let score = 1 - (tabSwitches * 0.5) - (inactiveMinutes * 0.2);
                
                // Ensure score is between 0 and 1
                score = Math.max(0, Math.min(1, score));
                
                return score;
            }
            
            updateFocusScoreDisplay(result) {
                // Update the focus score in the eye tracking display
                const focusScoreElement = document.getElementById('focus-score');
                if (focusScoreElement) {
                    focusScoreElement.textContent = `${Math.round(result.score)}%`;
                    
                    // Color code based on score
                    if (result.score >= 70) {
                        focusScoreElement.style.color = '#4CAF50';
                    } else if (result.score >= 40) {
                        focusScoreElement.style.color = '#FFA500';
                    } else {
                        focusScoreElement.style.color = '#f44336';
                    }
                }
                
                // Also update the focus status
                const focusStatus = document.getElementById('focus-status');
                if (focusStatus) {
                    let statusText = 'Focus: ';
                    let statusClass = 'status-unknown';
                    
                    if (result.score >= 70) {
                        statusText += `HIGH (${Math.round(result.score)}%)`;
                        statusClass = 'status-focusing';
                    } else if (result.score >= 40) {
                        statusText += `MEDIUM (${Math.round(result.score)}%)`;
                        statusClass = 'status-unknown';
                    } else {
                        statusText += `LOW (${Math.round(result.score)}%)`;
                        statusClass = 'status-distracted';
                    }
                    
                    focusStatus.innerHTML = `
                        <div class="status-dot ${statusClass}"></div>
                        <span>${statusText}</span>
                    `;
                }
            }

calculateEyeScore() {
    if (this.irisData.confidence < 0.3) {
        return { 
            score: 0, 
            level: 'unknown',
            distance: 1.0,
            direction: 'unknown'
        };
    }
    
    // Get normalized iris center (0-1 coordinates)
    const irisCenter = this.irisData.center;
    
    // Calculate distance from screen center (0.5, 0.5 in normalized coordinates)
    const distanceX = irisCenter.x - 0.5;
    const distanceY = irisCenter.y - 0.5;
    const rawDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
    
    // Normalize distance to 0-1 scale (max possible distance from center is ~0.707)
    const normalizedDistance = Math.min(1, rawDistance / 0.707);
    
    // Calculate eye score: 100% when perfectly centered, 0% when at edge
    // Use exponential decay for better scoring: score = 100 * e^(-2 * distance)
    const eyeScore = Math.round(100 * Math.exp(-2 * normalizedDistance));
    
    // Apply confidence penalty (lower confidence = lower max possible score)
    const confidenceAdjustedScore = Math.round(eyeScore * this.irisData.confidence);
    
    // Determine direction
    let direction = 'CENTER';
    if (Math.abs(distanceX) > 0.1 || Math.abs(distanceY) > 0.1) {
        if (Math.abs(distanceX) > Math.abs(distanceY)) {
            direction = distanceX > 0 ? 'RIGHT' : 'LEFT';
        } else {
            direction = distanceY > 0 ? 'DOWN' : 'UP';
        }
    }
    
    // Determine level based on score
    let level = 'low';
    if (confidenceAdjustedScore >= 80) level = 'high';
    else if (confidenceAdjustedScore >= 50) level = 'medium';
    
    return {
        score: confidenceAdjustedScore,
        level: level,
        distance: rawDistance,
        normalizedDistance: normalizedDistance,
        direction: direction,
        confidence: this.irisData.confidence,
        rawEyeScore: eyeScore
    };
}
            
            calculateActivityScore() {
                // Activity_Score = (Keyboard_Score √ó 0.5) + (Mouse_Score √ó 0.5)
                const keyboardScore = this.focusTracking.activityData.keyboardScore || 0;
                const mouseScore = this.focusTracking.activityData.mouseScore || 0;
                
                const activityScore = (keyboardScore * 0.5) + (mouseScore * 0.5);
                
                // Normalize to 0-1 range
                return Math.max(0, Math.min(1, activityScore));
            }

            // Formula 2: Emotion Score
            calculateEmotionScore(emotion) {
                const startTime = performance.now();
                
                // Map emotion to score based on your table
                let emotionScore = 0;
                
                switch(emotion.toLowerCase()) {
                    case 'angry':
                    case 'frustrated':
                        emotionScore = 1;
                        break;
                    case 'sad':
                    case 'anxious':
                        emotionScore = 0.25;
                        break;
                    case 'happy':
                        emotionScore = 0.25;
                        break;
                    case 'bored':
                        emotionScore = 0.25;
                        break;
                    default:
                        emotionScore = 0.1; // Neutral or unknown
                }
                
                this.emotionTracking.currentEmotion = emotion.toLowerCase();
                this.emotionTracking.emotionHistory.push({
                    emotion: emotion.toLowerCase(),
                    score: emotionScore,
                    timestamp: Date.now()
                });
                
                // Keep only last 10 emotions
                if (this.emotionTracking.emotionHistory.length > 10) {
                    this.emotionTracking.emotionHistory.shift();
                }
                
                const result = {
                    score: emotionScore,
                    emotion: emotion.toLowerCase(),
                    needsIntervention: this.checkEmotionForIntervention(emotion.toLowerCase())
                };
                
                this.trackPerformance(startTime);
                return result;
            }
            
            checkEmotionForIntervention(emotion) {
                // Check if emotion requires intervention based on table logic
                const negativeEmotions = ['angry', 'frustrated', 'sad', 'anxious', 'bored'];
                return negativeEmotions.includes(emotion);
            }

            // Formula 3: Combined Score = (Emotion_Score √ó 0.6) + (Focus_Score √ó 0.4)
            calculateCombinedScore(emotion, focusScore) {
                const startTime = performance.now();
                
                // Get emotion score
                const emotionResult = this.calculateEmotionScore(emotion);
                const emotionScore = emotionResult.score;
                
                // Get focus score (convert from percentage back to 0-1)
                const normalizedFocusScore = (focusScore || 0) / 100;
                
                // Combined score = (Emotion_Score √ó 0.6) + (Focus_Score √ó 0.4)
                const combinedScore = (emotionScore * 0.6) + (normalizedFocusScore * 0.4);
                
                // Check if combined score triggers intervention
                const triggersIntervention = this.shouldTriggerIntervention(combinedScore, emotion);
                
                const result = {
                    combinedScore: combinedScore,
                    percentage: Math.round(combinedScore * 100),
                    triggersIntervention: triggersIntervention,
                    components: {
                        emotionScore: emotionScore,
                        focusScore: normalizedFocusScore
                    },
                    emotion: emotion,
                    focusState: this.getFocusState(normalizedFocusScore)
                };
                
                this.trackPerformance(startTime);
                return result;
            }
            
            shouldTriggerIntervention(combinedScore, emotion) {
                // Intervention is triggered when combined score is above threshold
                // or for specific negative emotions
                const THRESHOLD = 0.6; // 60% threshold
                
                if (combinedScore >= THRESHOLD) {
                    return true;
                }
                
                // Also trigger for strong negative emotions regardless of score
                const strongNegativeEmotions = ['angry', 'frustrated', 'sad'];
                if (strongNegativeEmotions.includes(emotion)) {
                    return true;
                }
                
                return false;
            }
            
getFocusState(focusScore) {
    // Convert focus score (0-100) to 'Focused'/'Not Focused'
    return focusScore >= 50 ? 'Focused' : 'Not Focused';
}
            
            getFocusLevel(focusScore) {
                // Convert 0-1 score to level
                if (focusScore >= 0.8) return 'high';
                if (focusScore >= 0.6) return 'medium';
                if (focusScore >= 0.4) return 'low';
                return 'unknown';
            }
            
            // Method to determine intervention type based on emotion and focus state
            determineInterventionType(emotion, focusState) {
                const emotionKey = this.getEmotionKey(emotion);
                
                // Map to your table logic
                if (emotionKey === 'Anxious / Sad') {
                    if (focusState === 'Focused') {
                        return {
                            type: 'support_keep_learning',
                            flow: ['Light empathy', 'Normalize', 'Small step'],
                            example: "I know this feels hard. You're still trying. Let's do one step together."
                        };
                    } else {
                        return {
                            type: 'regulate_reenter',
                            flow: ['Strong empathy', 'Pause/breath', 'Reduce task', 'Restart'],
                            example: "It looks really heavy right now. Let's pause for one breath. We'll try one easy step when you're ready."
                        };
                    }
                } else if (emotionKey === 'Angry / Frustrated') {
                    if (focusState === 'Focused') {
                        return {
                            type: 'give_tools',
                            flow: ['Reflect feeling', 'Reframe', 'Strategy choice'],
                            example: "That's frustrating. Want a hint or an example to help?"
                        };
                    } else {
                        return {
                            type: 'calm_regain',
                            flow: ['Acknowledge', 'Slow down', 'Choice', 'Restart'],
                            example: "This feels too much. Let's slow down. Do you want a hint or a break?"
                        };
                    }
                } else if (emotionKey === 'Happy') {
                    if (focusState === 'Focused') {
                        return {
                            type: 'stretch_learning',
                            flow: ['Praise effort', 'Slight challenge'],
                            example: "You're doing great! Want to try a harder one?"
                        };
                    } else {
                        return {
                            type: 'channel_energy',
                            flow: ['Acknowledge', 'Redirect', 'Short task'],
                            example: "You're excited! Let's use that energy for one quick question."
                        };
                    }
                } else if (emotionKey === 'Bored') {
                    if (focusState === 'Focused') {
                        return {
                            type: 'increase_engagement',
                            flow: ['Acknowledge', 'Add challenge/choice'],
                            example: "This feels easy, huh? Want a challenge version?"
                        };
                    } else {
                        return {
                            type: 'recapture_attention',
                            flow: ['Acknowledge', 'Relevance/game', 'Short win'],
                            example: "Looks boring right now. Want a quick game or story example?"
                        };
                    }
                }
                
                // Default intervention
                return {
                    type: 'general_support',
                    flow: ['Check in', 'Offer help', 'Continue'],
                    example: "How are you feeling? Need any help with this?"
                };
            }
            calculateTableBasedIntervention(emotion, focusState) {
    const emotionKey = this.getEmotionKey(emotion);
    
    // Map to your table
    if (emotionKey === 'Anxious / Sad') {
        if (focusState === 'Focused') {
            return {
                type: 'support_keep_learning',
                flow: ['Light empathy', 'Normalize', 'Small step'],
                example: "I know this feels hard. You're still trying. Let's do one step together.",
                scoreThreshold: 0.6 // Example threshold
            };
        } else {
            return {
                type: 'regulate_reenter',
                flow: ['Strong empathy', 'Pause/breath', 'Reduce task', 'Restart'],
                example: "It looks really heavy right now. Let's pause for one breath. We'll try one easy step when you're ready.",
                scoreThreshold: 0.7
            };
        }
    } else if (emotionKey === 'Angry / Frustrated') {
        if (focusState === 'Focused') {
            return {
                type: 'give_tools',
                flow: ['Reflect feeling', 'Reframe', 'Strategy choice'],
                example: "That's frustrating. Want a hint or an example to help?",
                scoreThreshold: 0.65
            };
        } else {
            return {
                type: 'calm_regain',
                flow: ['Acknowledge', 'Slow down', 'Choice', 'Restart'],
                example: "This feels too much. Let's slow down. Do you want a hint or a break?",
                scoreThreshold: 0.75
            };
        }
    } else if (emotionKey === 'Happy') {
        if (focusState === 'Focused') {
            return {
                type: 'stretch_learning',
                flow: ['Praise effort', 'Slight challenge'],
                example: "You're doing great! Want to try a harder one?",
                scoreThreshold: 0.3 // Lower threshold for positive emotions
            };
        } else {
            return {
                type: 'channel_energy',
                flow: ['Acknowledge', 'Redirect', 'Short task'],
                example: "You're excited! Let's use that energy for one quick question.",
                scoreThreshold: 0.5
            };
        }
    } else if (emotionKey === 'Bored') {
        if (focusState === 'Focused') {
            return {
                type: 'increase_engagement',
                flow: ['Acknowledge', 'Add challenge/choice'],
                example: "This feels easy, huh? Want a challenge version?",
                scoreThreshold: 0.4
            };
        } else {
            return {
                type: 'recapture_attention',
                flow: ['Acknowledge', 'Relevance/game', 'Short win'],
                example: "Looks boring right now. Want a quick game or story example?",
                scoreThreshold: 0.6
            };
        }
    }
    
    return null;
}
getEmotionKey(emotion) {
    const emotionLower = emotion.toLowerCase();
    
    if (emotionLower === 'angry' || emotionLower === 'frustrated') {
        return 'Angry / Frustrated';
    } else if (emotionLower === 'sad' || emotionLower === 'anxious') {
        return 'Anxious / Sad';
    } else if (emotionLower === 'happy') {
        return 'Happy';
    } else if (emotionLower === 'bored') {
        return 'Bored';
    }
    
    return 'Neutral';
}

            
            // Update tracking data methods
            updateTabTracking(tabSwitches, inactiveMinutes) {
                this.focusTracking.tabSwitches = tabSwitches;
                this.focusTracking.inactiveMinutes = inactiveMinutes;
            }
            
            updateEyeTracking(eyeComponent, irisComponent, fixationTime) {
                this.focusTracking.eyeData.eyeComponent = eyeComponent;
                this.focusTracking.eyeData.irisComponent = irisComponent;
                this.focusTracking.eyeData.fixationTime = Math.max(1, fixationTime);
            }
            
            updateActivityTracking(keyboardScore, mouseScore) {
                this.focusTracking.activityData.keyboardScore = keyboardScore;
                this.focusTracking.activityData.mouseScore = mouseScore;
            }
            
            // Original methods (keep for compatibility)
            trackPerformance(startTime) {
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                this.performanceStats.calculations++;
                this.performanceStats.lastCalculation = new Date().toISOString();
                
                if (this.performanceStats.calculations === 1) {
                    this.performanceStats.averageTime = duration;
                } else {
                    this.performanceStats.averageTime = 
                        (this.performanceStats.averageTime * (this.performanceStats.calculations - 1) + duration) / 
                        this.performanceStats.calculations;
                }
                
                return duration;
            }
            
            getPerformanceReport() {
                return {
                    calculations: this.performanceStats.calculations,
                    averageTime: Math.round(this.performanceStats.averageTime * 100) / 100,
                    lastCalculation: this.performanceStats.lastCalculation,
                    focusTracking: this.focusTracking,
                    emotionTracking: this.emotionTracking
                };
            }
        }
                
        let calculationManager = null;

        // ============================================
        // GLOBAL STATE MANAGEMENT
        // ============================================


        // Enhanced Learning Modules Data
        
        const learningGames = {
            letters: {
                title: "Letter Explorer Game",
                description: "Learn lowercase letters a-z with multisensory support!",
                activities: [
                    {
                        type: "letter_recognition",
                        question: "Touch and identify this letter:",
                        letter: "a",
                        options: ["a", "b", "c", "d"],
                        correct: 0,
                        explanation: "Great! This is lowercase 'a'. Feel its round shape!",
                        points: 10,
                        tactile_feature: "Round shape with a tail"
                    },
                    {
                        type: "letter_recognition",
                        question: "Which letter is different? (No mirror letters)",
                        letters: ["b", "d", "p", "a"],
                        options: ["b", "d", "p", "a"],
                        correct: 3,
                        explanation: "Correct! 'a' is not a mirror letter like b-d or p-q!",
                        points: 10,
                        tactile_feature: "Unique shape prevents confusion"
                    },
                    {
                        type: "letter_sequence",
                        question: "What comes after 'c'?",
                        sequence: ["a", "b", "c", "?"],
                        options: ["d", "e", "f", "g"],
                        correct: 0,
                        explanation: "Correct! c ‚Üí d. Feel the different shapes!",
                        points: 10,
                        tactile_feature: "Different shapes for each letter"
                    }
                ],
                dyslexia_tips: [
                    "Touch and feel each letter shape",
                    "Use color coding for similar letters",
                    "Listen to the click sound when correct"
                ],
                currentActivity: 0,
                completed: false
            },
            
            vowels: {
                title: "Vowel & Consonant Fun",
                description: "Learn to differentiate vowels and consonants!",
                activities: [
                    {
                        type: "vowel_identification",
                        question: "Which of these is a vowel?",
                        letters: ["b", "a", "c", "d"],
                        options: ["b", "a", "c", "d"],
                        correct: 1,
                        explanation: "Correct! 'a' is a vowel (a, e, i, o, u)!",
                        points: 10
                    },
                    {
                        type: "consonant_identification",
                        question: "Find the consonant:",
                        letters: ["e", "i", "m", "o"],
                        options: ["e", "i", "m", "o"],
                        correct: 2,
                        explanation: "Great! 'm' is a consonant!",
                        points: 10
                    }
                ],
                dyslexia_tips: [
                    "Color code vowels and consonants differently",
                    "Use tactile feedback for differentiation",
                    "Practice with phonics sounds"
                ],
                currentActivity: 0,
                completed: false
            },
            
            spelling: {
                title: "Word Builder Game",
                description: "Spell and read words using phonics!",
                activities: [
                    {
                        type: "word_spelling",
                        question: "Spell 'cat' using letter blocks",
                        word: "cat",
                        letters: ["c", "a", "t", "b", "d", "e"],
                        correct: ["c", "a", "t"],
                        explanation: "Excellent! c-a-t spells 'cat'!",
                        points: 10,
                        phonics: "/k/ /√¶/ /t/"
                    },
                    {
                        type: "malay_word",
                        question: "Spell 'buku' (book in Malay)",
                        word: "buku",
                        letters: ["b", "u", "k", "a", "e", "i"],
                        correct: ["b", "u", "k", "u"],
                        explanation: "Perfect! b-u-k-u = buku!",
                        points: 10,
                        syllable_breakdown: "bu-ku (2 syllables)"
                    }
                ],
                dyslexia_tips: [
                    "Break words into syllables",
                    "Use phonics sounds for each letter",
                    "Listen to the click sound feedback"
                ],
                currentActivity: 0,
                completed: false
            },
            
            tracing: {
                title: "Letter Tracer",
                description: "Trace letters with mouse or finger to build muscle memory",
                activities: [
                    {
                        type: "uppercase_tracing",
                        letter: "A",
                        strokeOrder: [
                            {x: 50, y: 150},
                            {x: 100, y: 50},
                            {x: 150, y: 150},
                            {x: 70, y: 100},
                            {x: 130, y: 100}
                        ],
                        difficulty: "easy",
                        points: 15,
                        hint: "Start at the green dot, go up to the point, then down to the other side"
                    },
                    {
                        type: "lowercase_tracing",
                        letter: "a",
                        strokeOrder: [
                            {x: 100, y: 100, type: "circle"},
                            {x: 100, y: 150, type: "line"}
                        ],
                        difficulty: "easy",
                        points: 15,
                        hint: "Make a circle first, then add the tail"
                    }
                ],
                dyslexia_tips: [
                    "Trace slowly and follow the guide",
                    "Say the letter sound as you trace",
                    "Start from the correct starting point",
                    "Use the starting dot as reference"
                ],
                currentActivity: 0,
                completed: false
            }
        };

        // Game State
        let currentGame = null;
        let currentActivityIndex = 0;
        let studentScore = 150;
        let isEasyMode = false;

        // Mickey Agent State
        let mickeyAgentVisible = false;
        let breakTimerActive = false;
        let breakTimeLeft = 30;
        let breakInterval = null;
        let breathingInterval = null;
        let studentEmotion = 'neutral';
        let frustrationLevel = 0;
        const FRUSTRATION_THRESHOLD = 5;

        // Voice Settings
        let voiceEnabled = true;

        // Emotion Detection Timer
        let emotionDetectionInterval;
        let secondsCounter = 0;
        let detectionCycle = 0;

        // ============================================
        // ENHANCED DUAL CAMERA DETECTION SYSTEM
        // ============================================

class DualCameraDetection {
    constructor() {
        // State management
        this.isEmotionRunning = false;
        this.isEyeTracking = false;
        this.emotionFrameCount = 0;
        this.emotionLastTimestamp = 0;
        this.emotionFPS = 0;
        this.lastInterventionTime = 0;
        this.INTERVENTION_COOLDOWN = 30000; // 30 seconds

        // Elements - Emotion detection
        this.emotionVideo = document.getElementById('emotion-video');
        this.emotionCanvas = document.getElementById('emotion-overlay');
        this.emotionCtx = this.emotionCanvas.getContext('2d');

        this.emotionInterventionData = {
            lastInterventionTime: 0,
            interventionCooldown: 15000, // 15 seconds between interventions
            negativeEmotionCount: 0,
            NEGATIVE_THRESHOLD: 3, // Number of negative detections before intervention
            emotionHistory: []
        };
        
        // Elements - Eye tracking
        this.eyeCanvas = document.getElementById('eye-tracking-canvas');
        this.eyeCtx = this.eyeCanvas.getContext('2d');
        
        // ‚úÖ ADDED: Create separate video elements like model
        this.irisVideo = document.createElement('video'); // For processing only
        this.irisVideo.id = 'eye-processing-video';
        this.irisVideo.autoplay = true;
        this.irisVideo.playsinline = true;
        this.irisVideo.muted = true;
        this.irisVideo.style.display = 'none';
        
        // Display video will be created when eye tracking starts
        this.eyeDisplayVideo = null;

        // Human.js instances
        this.emotionHuman = null;
        this.eyeHuman = null;
        
        // Eye tracking data
        this.irisData = {
            left: { x: 0, y: 0, confidence: 0 },
            right: { x: 0, y: 0, confidence: 0 },
            center: { x: 0, y: 0, confidence: 0 },
            confidence: 0
        };
        
        // Emotion tracking
        this.studentEmotion = 'neutral';
        this.frustrationLevel = 0;
        this.FRUSTRATION_THRESHOLD = 5;
        this.emotionHistory = [];
        this.EMOTION_HISTORY_MAX = 10;

        this.focusData = {
            overallFocus: 'unknown', // 'high', 'medium', 'low', 'unknown'
            focusScore: 0,
            interventionCooldown: 15000, // 15 seconds between interventions
            lastFocusCheck: 0,
            eyeDistanceFromCenter: 0,
            cursorActivity: false,
            lastCursorMove: 0,
            cursorPosition: {x: 0, y: 0},
            checkInterval: null
        };
        
        // Streams
        this.emotionStream = null;
        this.eyeStream = null;
        this.eyeScoreHistory = [];
        this.EYE_SCORE_HISTORY_MAX = 30;
        
        // Initialize
        this.init();
    }
    
    async init() {
        try {
            // Initialize Human.js for emotion detection
            this.emotionHuman = new Human.default({
                modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human/models/',
                backend: 'webgl',
                face: { 
                    enabled: true,
                    detector: { 
                        maxDetected: 1,
                        rotation: true,
                        return: true,
                        modelPath: 'blazeface-back.json'
                    },
                    mesh: { 
                        enabled: true,
                        modelPath: 'facemesh.json'
                    },
                    iris: { enabled: false },
                    emotion: { 
                        enabled: true,
                        modelPath: 'emotion.json'
                    },
                    description: { enabled: false },
                    liveness: { enabled: false },
                    antispoof: { enabled: false }
                },
                body: { enabled: false },
                hand: { enabled: false },
                object: { enabled: false },
                segmentation: { enabled: false },
                cacheSensitivity: 0,
                skipFrames: 0
            });
            
            // Initialize Human.js for eye tracking
            this.eyeHuman = new Human.default({
                modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human/models/',
                backend: 'webgl',
                face: { 
                    enabled: true,
                    detector: { 
                        maxDetected: 1,
                        rotation: true,
                        return: true,
                        modelPath: 'blazeface-back.json'
                    },
                    mesh: { 
                        enabled: true,
                        modelPath: 'facemesh.json'
                    },
                    iris: { 
                        enabled: true,
                        maxDetected: 2,
                        minConfidence: 0.1
                    },
                    emotion: { enabled: false },
                    description: { enabled: false },
                    liveness: { enabled: false },
                    antispoof: { enabled: false }
                },
                body: { enabled: false },
                hand: { enabled: false },
                object: { enabled: false },
                segmentation: { enabled: false },
                cacheSensitivity: 0,
                skipFrames: 0
            });
            
            await Promise.all([
                this.emotionHuman.load(),
                this.eyeHuman.load()
            ]);
            
            console.log('‚úÖ Dual camera detection models loaded');
            
            // ‚úÖ Set up canvas sizes (MATCHES MODEL)
            this.resizeCanvases();
            window.addEventListener('resize', () => this.resizeCanvases());
            
            // Initialize UI
            this.initUI();
            
        } catch (error) {
            console.error('Failed to initialize dual camera detection:', error);
            this.showError('Failed to load detection models. Please refresh the page.');
        }
    }

    // ‚úÖ ADDED: Resize method (MATCHES MODEL)
    resizeCanvases() {
        // Get container dimensions
        const getContainerSize = (selector) => {
            const container = document.querySelector(selector);
            if (!container) return { width: 300, height: 180 };
            
            const rect = container.getBoundingClientRect();
            return {
                width: Math.floor(rect.width),
                height: Math.floor(rect.height)
            };
        };
        
        const emotionSize = getContainerSize('.emotion-screen .video-container');
        const eyeSize = getContainerSize('.eye-screen .video-container');
        
        // Resize emotion canvas
        if (this.emotionCanvas) {
            this.emotionCanvas.width = emotionSize.width;
            this.emotionCanvas.height = emotionSize.height;
        }
        
        // Resize eye canvas
        if (this.eyeCanvas) {
            this.eyeCanvas.width = eyeSize.width;
            this.eyeCanvas.height = eyeSize.height;
        }
        
        // Adjust display video if it exists
        if (this.eyeDisplayVideo && this.eyeDisplayVideo.parentElement) {
            const parent = this.eyeDisplayVideo.parentElement;
            const parentRect = parent.getBoundingClientRect();
            
            this.eyeDisplayVideo.style.width = `${parentRect.width}px`;
            this.eyeDisplayVideo.style.height = `${parentRect.height}px`;
        }
        
        console.log(`üîÑ Canvases resized: Emotion=${emotionSize.width}x${emotionSize.height}, Eye=${eyeSize.width}x${eyeSize.height}`);
    }
    
    initUI() {
        // Update initial status
        this.updateStatusIndicators();
        this.updateCameraBubbles();
    }

    // ‚úÖ ADDED: Create display video (MATCHES MODEL)
    createEyeDisplayVideo() {
        const eyeScreen = document.getElementById('eye-screen');
        if (eyeScreen) {
            const videoContainer = eyeScreen.querySelector('.video-container');
            if (videoContainer) {
                // Remove existing video if present
                const existingVideo = videoContainer.querySelector('#eye-display-video');
                if (existingVideo) {
                    existingVideo.remove();
                }
                
                // Create a new video element for display
                this.eyeDisplayVideo = document.createElement('video');
                this.eyeDisplayVideo.id = 'eye-display-video';
                this.eyeDisplayVideo.className = 'detection-video';
                this.eyeDisplayVideo.autoplay = true;
                this.eyeDisplayVideo.playsinline = true;
                this.eyeDisplayVideo.muted = true;
                this.eyeDisplayVideo.style.width = '100%';
                this.eyeDisplayVideo.style.height = '100%';
                this.eyeDisplayVideo.style.objectFit = 'cover';
                this.eyeDisplayVideo.style.transform = 'scaleX(-1)';
                this.eyeDisplayVideo.style.position = 'absolute';
                this.eyeDisplayVideo.style.top = '0';
                this.eyeDisplayVideo.style.left = '0';
                this.eyeDisplayVideo.style.zIndex = '1';
                
                videoContainer.appendChild(this.eyeDisplayVideo);
                
                // Ensure canvas is on top
                const canvas = videoContainer.querySelector('.eye-canvas');
                if (canvas) {
                    canvas.style.position = 'absolute';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.zIndex = '2';
                    canvas.style.pointerEvents = 'none';
                }
                
                // Resize after video is created
                setTimeout(() => {
                    this.resizeCanvases();
                }, 100);
            }
        }
    }

    async autoStartBothDetectionsForGame() {
        console.log("üéÆ Starting BOTH detection systems for gameplay");
        
        try {
            // Update immediately
            const irisInfo = document.getElementById('iris-info');
            const focusStatus = document.getElementById('focus-status');
            
            if (irisInfo) irisInfo.textContent = 'Starting eye tracking...';
            if (focusStatus) {
                focusStatus.innerHTML = `
                    <div class="status-dot status-unknown"></div>
                    <span>Eye: Initializing...</span>
                `;
            }
            
            // Start detections
            await this.startEmotionDetection();
            await this.startEyeDetection();
            
            // Update again to show active
            if (irisInfo) irisInfo.textContent = 'Eye tracking active. Looking for eyes...';
            if (focusStatus) {
                focusStatus.innerHTML = `
                    <div class="status-dot status-unknown"></div>
                    <span>Eye: Detecting...</span>
                `;
            }
            
            console.log("‚úÖ Both detection systems started for gameplay");
            
        } catch (error) {
            console.error("Failed to start detection systems:", error);
        }
    }
    
    async startEmotionDetection() {
        // If already running, return
        if (this.isEmotionRunning) return;
        
        try {
            // Get camera for emotion detection
            this.emotionStream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 },
                audio: false
            });
            
            // Connect stream to video element
            this.emotionVideo.srcObject = this.emotionStream;
            
            // Wait for video to load
            await new Promise(resolve => {
                this.emotionVideo.onloadedmetadata = resolve;
            });
            
            // Play video
            await this.emotionVideo.play();
            
            this.isEmotionRunning = true;
            this.updateStatusIndicators();
            this.detectEmotionFrame();
            
        } catch (error) {
            console.error('Emotion camera error:', error);
            throw error;
        }
    }
    
    async startEyeDetection() {
        // If already running, return
        if (this.isEyeTracking) return;
        
        try {
            // ‚úÖ CREATE display video element (MATCHES MODEL)
            this.createEyeDisplayVideo();
            
            // Get camera for eye tracking
            this.eyeStream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: 'user',
                    frameRate: { ideal: 30 }
                },
                audio: false
            });
            
            // ‚úÖ CONNECT to BOTH video elements (MATCHES MODEL)
            this.irisVideo.srcObject = this.eyeStream; // For processing
            
            if (this.eyeDisplayVideo) {
                this.eyeDisplayVideo.srcObject = this.eyeStream; // For display
            }
            
            // Wait for videos to be ready
            await Promise.all([
                new Promise(resolve => {
                    this.irisVideo.onloadedmetadata = resolve;
                    if (this.irisVideo.readyState >= 3) resolve();
                }),
                new Promise(resolve => {
                    if (this.eyeDisplayVideo) {
                        this.eyeDisplayVideo.onloadedmetadata = resolve;
                        if (this.eyeDisplayVideo.readyState >= 3) resolve();
                    } else {
                        resolve();
                    }
                })
            ]);
            
            // Start playing videos
            await this.irisVideo.play();
            if (this.eyeDisplayVideo) {
                await this.eyeDisplayVideo.play();
            }
            
            this.isEyeTracking = true;
            this.updateStatusIndicators();
            this.detectEyeFrame();
            
            console.log('‚úÖ Eye tracking started with separate video stream');
            
        } catch (error) {
            console.error('Eye camera error:', error);
            throw error;
        }
    }

    // ‚úÖ ADDED: Eye score calculation
    calculateEyeScore() {
        if (this.irisData.confidence < 0.3) {
            return { 
                score: 0, 
                level: 'unknown',
                distance: 1.0,
                normalizedDistance: 1.0,
                direction: 'unknown',
                confidence: this.irisData.confidence
            };
        }
        
        // Get normalized iris center (0-1 coordinates)
        const irisCenter = this.irisData.center;
        
        // Calculate distance from screen center (0.5, 0.5 in normalized coordinates)
        const distanceX = irisCenter.x - 0.5;
        const distanceY = irisCenter.y - 0.5;
        const rawDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
        
        // Normalize distance to 0-1 scale (max possible distance from center is ~0.707)
        const normalizedDistance = Math.min(1, rawDistance / 0.707);
        
        // Calculate eye score: 100% when perfectly centered, 0% when at edge
        const eyeScore = Math.round(100 * Math.exp(-2 * normalizedDistance));
        
        // Apply confidence penalty
        const confidenceAdjustedScore = Math.round(eyeScore * this.irisData.confidence);
        
        // Determine direction
        let direction = 'CENTER';
        if (Math.abs(distanceX) > 0.1 || Math.abs(distanceY) > 0.1) {
            if (Math.abs(distanceX) > Math.abs(distanceY)) {
                direction = distanceX > 0 ? 'RIGHT' : 'LEFT';
            } else {
                direction = distanceY > 0 ? 'DOWN' : 'UP';
            }
        }
        
        // Determine level based on score
        let level = 'low';
        if (confidenceAdjustedScore >= 80) level = 'high';
        else if (confidenceAdjustedScore >= 50) level = 'medium';
        
        return {
            score: confidenceAdjustedScore,
            level: level,
            distance: rawDistance,
            normalizedDistance: normalizedDistance,
            direction: direction,
            confidence: this.irisData.confidence,
            rawEyeScore: eyeScore
        };
    }

    trackEyeScore(scoreData) {
        this.eyeScoreHistory.push({
            score: scoreData.score,
            level: scoreData.level,
            timestamp: Date.now(),
            distance: scoreData.distance,
            direction: scoreData.direction
        });
        
        // Keep only last N entries
        if (this.eyeScoreHistory.length > this.EYE_SCORE_HISTORY_MAX) {
            this.eyeScoreHistory.shift();
        }
        
        return this.getEyeScoreStats();
    }

    getEyeScoreStats() {
        if (this.eyeScoreHistory.length === 0) {
            return { average: 0, trend: 'stable', recent: [] };
        }
        
        const recentScores = this.eyeScoreHistory.slice(-10);
        const average = Math.round(recentScores.reduce((sum, entry) => sum + entry.score, 0) / recentScores.length);
        
        // Calculate trend
        let trend = 'stable';
        if (recentScores.length >= 3) {
            const firstThreeAvg = Math.round((recentScores[0].score + recentScores[1].score + recentScores[2].score) / 3);
            const lastThreeAvg = Math.round((recentScores[recentScores.length-3].score + 
                                            recentScores[recentScores.length-2].score + 
                                            recentScores[recentScores.length-1].score) / 3);
            
            if (lastThreeAvg > firstThreeAvg + 10) trend = 'improving';
            else if (lastThreeAvg < firstThreeAvg - 10) trend = 'declining';
        }
        
        return {
            average: average,
            trend: trend,
            recent: recentScores,
            totalSamples: this.eyeScoreHistory.length
        };
    }

    updateGameActiveUI() {
        // Update emotion status
        const emotionStatus = document.getElementById('emotion-status');
        if (emotionStatus) {
            emotionStatus.innerHTML = '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)';
            emotionStatus.className = 'screen-status active';
        }
        
        // Update eye status
        const eyeStatus = document.getElementById('eye-status');
        if (eyeStatus) {
            eyeStatus.innerHTML = '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)';
            eyeStatus.className = 'screen-status active';
        }
        
        // Update camera bubbles
        const emotionBubble = document.getElementById('side-emotion-camera');
        const eyeBubble = document.getElementById('side-eye-camera');
        
        if (emotionBubble) {
            emotionBubble.classList.add('active');
            emotionBubble.title = 'Emotion Detection (Active - Game)';
        }
        
        if (eyeBubble) {
            eyeBubble.classList.add('active');
            eyeBubble.title = 'Eye Tracking (Active - Game)';
        }
    }
    
    autoStopBothDetectionsAfterGame() {
        console.log("üõë Stopping BOTH detection systems after game");
        
        // Stop emotion detection
        if (this.isEmotionRunning) {
            this.stopEmotionDetection();
        }
        
        // Stop eye tracking
        if (this.isEyeTracking) {
            this.stopEyeDetection();
        }
        
        // Show info
        this.showInfo("Game monitoring stopped.");
        
        // Reset UI to inactive state
        this.updateInactiveUI();
        
        console.log("‚úÖ Both detection systems stopped after game");
    }
    
    updateInactiveUI() {
        // Update emotion status
        const emotionStatus = document.getElementById('emotion-status');
        if (emotionStatus) {
            emotionStatus.innerHTML = '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
            emotionStatus.className = 'screen-status';
        }
        
        // Update eye status
        const eyeStatus = document.getElementById('eye-status');
        if (eyeStatus) {
            eyeStatus.innerHTML = '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
            eyeStatus.className = 'screen-status';
        }
        
        // Update camera bubbles
        const emotionBubble = document.getElementById('side-emotion-camera');
        const eyeBubble = document.getElementById('side-eye-camera');
        
        if (emotionBubble) {
            emotionBubble.classList.remove('active');
            emotionBubble.title = 'Emotion Detection (Start Game to Activate)';
        }
        
        if (eyeBubble) {
            eyeBubble.classList.remove('active');
            eyeBubble.title = 'Eye Tracking (Start Game to Activate)';
        }
    }
    
    stopEmotionDetection() {
        if (this.emotionStream) {
            this.emotionStream.getTracks().forEach(track => track.stop());
            this.emotionStream = null;
        }
        
        this.emotionVideo.srcObject = null;
        this.isEmotionRunning = false;
        
        // Clear canvas
        if (this.emotionCtx) {
            this.emotionCtx.clearRect(0, 0, this.emotionCanvas.width, this.emotionCanvas.height);
        }
        
        // Reset displays
        document.getElementById('face-count').textContent = '0';
        document.getElementById('dominant-emotion').textContent = '-';
        document.getElementById('emotion-confidence').textContent = '0%';
        document.getElementById('emotion-info').textContent = 'Emotion: Waiting for game to start';
        
        console.log('üõë Emotion detection stopped');
    }
    
    stopEyeDetection() {
        if (this.eyeStream) {
            this.eyeStream.getTracks().forEach(track => track.stop());
            this.eyeStream = null;
        }
        
        // Clear both video sources
        if (this.irisVideo) {
            this.irisVideo.srcObject = null;
        }
        
        if (this.eyeDisplayVideo) {
            this.eyeDisplayVideo.srcObject = null;
            this.eyeDisplayVideo.remove();
            this.eyeDisplayVideo = null;
        }
        
        this.isEyeTracking = false;
        
        // Clear canvas
        if (this.eyeCtx) {
            this.eyeCtx.clearRect(0, 0, this.eyeCanvas.width, this.eyeCanvas.height);
        }
        
        // Reset displays
        const irisConfidenceElement = document.getElementById('eye-iris-confidence');
        const focusDirectionElement = document.getElementById('focus-direction');
        
        if (irisConfidenceElement) irisConfidenceElement.textContent = '0%';
        if (focusDirectionElement) focusDirectionElement.textContent = '-';
        
        console.log('üõë Eye tracking stopped');
    }
    
    updateStatusIndicators() {
        const emotionStatus = document.getElementById('emotion-status');
        const eyeStatus = document.getElementById('eye-status');
        
        if (emotionStatus) {
            emotionStatus.innerHTML = this.isEmotionRunning ? 
                '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)' : 
                '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
            emotionStatus.className = this.isEmotionRunning ? 
                'screen-status active' : 'screen-status';
        }
        
        if (eyeStatus) {
            eyeStatus.innerHTML = this.isEyeTracking ? 
                '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)' : 
                '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
            eyeStatus.className = this.isEyeTracking ? 
                'screen-status active' : 'screen-status';
        }
        
        // Update camera bubbles
        this.updateCameraBubbles();
    }
    
    updateCameraBubbles() {
        const emotionBubble = document.getElementById('side-emotion-camera');
        const eyeBubble = document.getElementById('side-eye-camera');
        const emotionDot = document.getElementById('emotion-status-dot');
        const eyeDot = document.getElementById('eye-status-dot');
        
        if (emotionBubble) {
            if (this.isEmotionRunning) {
                emotionBubble.classList.add('active');
                emotionDot.className = 'camera-status-dot active';
                emotionBubble.title = 'Emotion Detection (Active - Game)';
            } else {
                emotionBubble.classList.remove('active');
                emotionDot.className = 'camera-status-dot inactive';
                emotionBubble.title = 'Emotion Detection (Start Game to Activate)';
            }
        }
        
        if (eyeBubble) {
            if (this.isEyeTracking) {
                eyeBubble.classList.add('active');
                eyeDot.className = 'camera-status-dot active';
                eyeBubble.title = 'Eye Tracking (Active - Game)';
            } else {
                eyeBubble.classList.remove('active');
                eyeDot.className = 'camera-status-dot inactive';
                eyeBubble.title = 'Eye Tracking (Start Game to Activate)';
            }
        }
    }
    
    async detectEmotionFrame() {
        if (!this.isEmotionRunning) return;
        
        try {
            // Update FPS
            this.updateEmotionFPS();
            
            // Run detection
            const result = await this.emotionHuman.detect(this.emotionVideo);
            
            // Clear and draw
            this.emotionCtx.clearRect(0, 0, this.emotionCanvas.width, this.emotionCanvas.height);
            
            // Draw video frame
            this.emotionCtx.drawImage(this.emotionVideo, 0, 0, 
                this.emotionCanvas.width, this.emotionCanvas.height);
            
            // Check for faces
            if (result.face && result.face.length > 0) {
                const face = result.face[0];
                
                // Update face count if element exists
                const faceCountElement = document.getElementById('face-count');
                if (faceCountElement) {
                    faceCountElement.textContent = result.face.length;
                }
                
                // Draw face detection
                this.drawEmotionFace(face);
                
                // TRACK EMOTION DETECTION PERFORMANCE
                const dominantEmotion = this.getDominantEmotion(face);
                if (calculationManager) {
                    calculationManager.trackEmotionDetection(
                        dominantEmotion.name, 
                        dominantEmotion.confidence
                    );
                }
                
                // Update Mickey agent
                this.updateMickeyAgent(face);
                
            } else {
                // No faces found - update elements only if they exist
                const faceCountElement = document.getElementById('face-count');
                const dominantEmotionElement = document.getElementById('dominant-emotion');
                const emotionConfidenceElement = document.getElementById('emotion-confidence');
                const emotionInfoElement = document.getElementById('emotion-info');
                
                if (faceCountElement) faceCountElement.textContent = '0';
                if (dominantEmotionElement) dominantEmotionElement.textContent = '-';
                if (emotionConfidenceElement) emotionConfidenceElement.textContent = '0%';
                if (emotionInfoElement) emotionInfoElement.textContent = 'Emotion: No face';
                
                // Show "no face" message
                this.drawNoFaceMessage();
            }
            
        } catch (error) {
            console.log('Detection error:', error);
        }
        
        // Loop
        if (this.isEmotionRunning) {
            requestAnimationFrame(() => this.detectEmotionFrame());
        }
    }
    
    drawEmotionFace(face) {
        const ctx = this.emotionCtx;
        const canvasWidth = this.emotionCanvas.width;
        const canvasHeight = this.emotionCanvas.height;
        const videoWidth = this.emotionVideo.videoWidth;
        const videoHeight = this.emotionVideo.videoHeight;
        
        // CLEAR FIRST
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // DRAW VIDEO FRAME FIRST
        ctx.drawImage(this.emotionVideo, 0, 0, canvasWidth, canvasHeight);
        
        if (!face.box) return;
        
        // Calculate scaling
        const scaleX = canvasWidth / videoWidth;
        const scaleY = canvasHeight / videoHeight;
        
        const [x, y, width, height] = face.box;
        
        // SCALE THE BOX
        const scaledX = x * scaleX;
        const scaledY = y * scaleY;
        const scaledWidth = width * scaleX;
        const scaledHeight = height * scaleY;
        
        // Get dominant emotion
        const dominantEmotion = this.getDominantEmotion(face);
        const color = this.getEmotionColor(dominantEmotion.name);
        
        // Draw face box
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
        
        // Draw emotion label
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(scaledX + scaledWidth - 120, scaledY - 20, 115, 18);
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(
            `${dominantEmotion.name} ${Math.round(dominantEmotion.confidence * 100)}%`,
            scaledX + scaledWidth - 5,
            scaledY - 5
        );
        ctx.textAlign = 'left';
        
        // Update emotion display stats only if elements exist
        this.updateEmotionDisplay(face);
        
        // Draw landmarks - SCALE THEM TOO
        if (face.mesh && face.mesh.length > 0) {
            ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
            
            // Draw SOME landmarks (not all for performance)
            const step = 10; // Draw every 10th point
            for (let i = 0; i < Math.min(100, face.mesh.length); i += step) {
                const point = face.mesh[i];
                if (point && point.length >= 2) {
                    const px = point[0] * scaleX;
                    const py = point[1] * scaleY;
                    ctx.beginPath();
                    ctx.arc(px, py, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    }
    
    drawNoFaceMessage() {
        const ctx = this.emotionCtx;
        const width = this.emotionCanvas.width;
        const height = this.emotionCanvas.height;
        
        // Draw semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(0, 0, width, height);
        
        // Draw "no face" message
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No face detected', width / 2, height / 2);
        ctx.font = '12px Arial';
        ctx.fillText('Make sure your face is visible', width / 2, height / 2 + 20);
        ctx.textAlign = 'left';
    }

    getDominantEmotion(face) {
        if (!face.emotion || !Array.isArray(face.emotion) || face.emotion.length === 0) {
            return { name: 'neutral', confidence: 0.5 };
        }
        
        const topEmotion = face.emotion[0];
        return {
            name: topEmotion.emotion || 'neutral',
            confidence: topEmotion.score || 0.5
        };
    }
    
    getEmotionColor(emotion) {
        const colors = {
            'angry': '#FF0000',
            'happy': '#00FF00',
            'neutral': '#FFFF00',
            'sad': '#0000FF'
        };
        return colors[emotion] || '#00FF00';
    }

    updateEmotionDisplay(face) {
        const dominantEmotion = this.getDominantEmotion(face);
        const confidence = Math.round(dominantEmotion.confidence * 100);
        
        // Only update elements that exist
        const dominantEmotionElement = document.getElementById('dominant-emotion');
        const emotionConfidenceElement = document.getElementById('emotion-confidence');
        const emotionInfoElement = document.getElementById('emotion-info');
        
        if (dominantEmotionElement) {
            dominantEmotionElement.textContent = dominantEmotion.name;
            dominantEmotionElement.style.color = this.getEmotionColor(dominantEmotion.name);
        }
        
        if (emotionConfidenceElement) {
            emotionConfidenceElement.textContent = `${confidence}%`;
        }
        
        if (emotionInfoElement) {
            emotionInfoElement.textContent = `Emotion: ${dominantEmotion.name} (${confidence}%)`;
        }
    }

    updateEmotionFPS() {
        const now = performance.now();
        this.emotionFrameCount++;
        
        if (now >= this.emotionLastTimestamp + 1000) {
            this.emotionFPS = Math.round((this.emotionFrameCount * 1000) / (now - this.emotionLastTimestamp));
            this.emotionLastTimestamp = now;
            this.emotionFrameCount = 0;
            
            // Only update if element exists
            const fpsElement = document.getElementById('emotion-fps');
            if (fpsElement) {
                fpsElement.textContent = this.emotionFPS;
            }
        }
    }
    
    // ‚úÖ ADDED: Eye info display method
    updateEyeInfoDisplay(irisData) {
        const irisInfoElement = document.getElementById('iris-info');
        const focusStatusElement = document.getElementById('focus-status');
        
        if (!irisInfoElement || !focusStatusElement) return;
        
        if (irisData.confidence > 0.3) {
            const confidence = Math.round(irisData.confidence * 100);
            const eyeScore = this.calculateEyeScore();
            
            // Update iris-info
            irisInfoElement.innerHTML = `
                Eye Score: <strong style="color: ${eyeScore.level === 'high' ? '#4CAF50' : 
                                                eyeScore.level === 'medium' ? '#FFA500' : '#F44336'}">
                    ${eyeScore.score}%
                </strong> | 
                Confidence: ${confidence}%<br>
                Looking: ${eyeScore.direction}
            `;
            
            // Update focus-status
            let statusClass = 'status-unknown';
            let statusText = `Eye: ${eyeScore.score}%`;
            
            switch(eyeScore.level) {
                case 'high':
                    statusClass = 'status-focusing';
                    statusText = `Eye: FOCUSED ${eyeScore.score}% ‚úÖ`;
                    break;
                case 'medium':
                    statusClass = 'status-unknown';
                    statusText = `Eye: OKAY ${eyeScore.score}% ü§î`;
                    break;
                case 'low':
                    statusClass = 'status-distracted';
                    statusText = `Eye: LOW ${eyeScore.score}% ‚ùå`;
                    break;
            }
            
            focusStatusElement.innerHTML = `
                <div class="status-dot ${statusClass}"></div>
                <span>${statusText}</span>
            `;
            
        } else {
            // No good detection
            irisInfoElement.textContent = 'Looking for eyes...';
            focusStatusElement.innerHTML = `
                <div class="status-dot status-unknown"></div>
                <span>Eye: Searching...</span>
            `;
        }
    }

    async detectEyeFrame() {
        if (!this.isEyeTracking || !this.eyeHuman) {
            return;
        }
        
        try {
            if (this.irisVideo.readyState >= 2) {
                // ‚úÖ Use irisVideo for detection (MATCHES MODEL)
                const result = await this.eyeHuman.detect(this.irisVideo);
                
                if (result.face && result.face.length > 0) {
                    const face = result.face[0];
                    const irisData = this.extractIrisData(face);
                    
                    // Update display
                    this.updateEyeInfoDisplay(irisData);
                    
                    // Update iris data
                    this.updateIrisData(irisData.left, irisData.right, irisData.confidence);
                    
                    // Draw visualization (pass face data for mesh drawing)
                    this.drawEyeTracking(irisData, face);
                    
                    // Track performance
                    const isSuccessful = irisData.confidence > 0.3;
                    if (calculationManager) {
                        calculationManager.trackFocusDetection(isSuccessful, irisData.confidence);
                    }
                } else {
                    // No face
                    this.updateEyeInfoDisplay({confidence: 0});
                    this.updateIrisData([0.5, 0.5], [0.5, 0.5], 0);
                    this.drawNoFace();
                }
            }
        } catch (error) {
            console.error('Eye detection error:', error);
        }
        
        // Continue loop
        if (this.isEyeTracking) {
            requestAnimationFrame(() => this.detectEyeFrame());
        }
    }

    // ‚úÖ UPDATED: Iris extraction (MATCHES MODEL)
    extractIrisData(face) {
        let leftIris = [0, 0];
        let rightIris = [0, 0];
        let confidence = 0.1;
        
        if (face.iris && Array.isArray(face.iris) && face.iris.length >= 2) {
            leftIris = face.iris[0];
            rightIris = face.iris[1];
            confidence = face.score || 0.7;
            
            // ‚úÖ NORMALIZE if needed (Human.js iris coords are usually normalized)
            // If coordinates are > 1, they're probably pixels
            if (leftIris[0] > 1 || leftIris[1] > 1) {
                // Get video dimensions
                const videoWidth = this.irisVideo.videoWidth || 640;
                const videoHeight = this.irisVideo.videoHeight || 480;
                
                leftIris = [leftIris[0] / videoWidth, leftIris[1] / videoHeight];
                rightIris = [rightIris[0] / videoWidth, rightIris[1] / videoHeight];
            }
        }
        else if (face.annotations && face.annotations.iris) {
            // Method 2: Iris from annotations
            leftIris = face.annotations.iris.left || [0, 0];
            rightIris = face.annotations.iris.right || [0, 0];
            confidence = face.score || 0.7;
        }
        else if (face.mesh && face.mesh.length >= 478) {
            // Method 3: Fallback to mesh points
            leftIris = face.mesh[468] || [0, 0, 0];
            rightIris = face.mesh[473] || [0, 0, 0];
            confidence = face.score || 0.5;
        }
        
        // Ensure we have proper 2D arrays
        if (Array.isArray(leftIris) && leftIris.length >= 2) {
            leftIris = [leftIris[0], leftIris[1]];
        } else {
            leftIris = [0.5, 0.5];
        }
        
        if (Array.isArray(rightIris) && rightIris.length >= 2) {
            rightIris = [rightIris[0], rightIris[1]];
        } else {
            rightIris = [0.5, 0.5];
        }
        
        return { left: leftIris, right: rightIris, confidence };
    }

    updateIrisData(leftIris, rightIris, confidence) {
        this.irisData.left = { 
            x: leftIris[0], 
            y: leftIris[1], 
            confidence: confidence 
        };
        
        this.irisData.right = { 
            x: rightIris[0], 
            y: rightIris[1], 
            confidence: confidence 
        };
        
        this.irisData.center = {
            x: (leftIris[0] + rightIris[0]) / 2,
            y: (leftIris[1] + rightIris[1]) / 2,
            confidence: confidence
        };
        
        this.irisData.confidence = confidence;
        
        // Update displays
        this.updateIrisDisplay();
        this.calculateFocusMetrics();
    }
    
    updateIrisDisplay() {
        const confidence = Math.round(this.irisData.confidence * 100);
        
        // Calculate eye score data
        const eyeScoreData = this.calculateEyeScore();
        
        // Update main display
        const irisConfidenceElement = document.getElementById('eye-iris-confidence');
        if (irisConfidenceElement) {
            irisConfidenceElement.textContent = `${confidence}%`;
            irisConfidenceElement.style.color = confidence > 70 ? '#4CAF50' : 
                                               confidence > 40 ? '#FFA500' : '#F44336';
        }
        
        // Update eye score display
        const eyeScoreElement = document.getElementById('eye-score');
        if (eyeScoreElement) {
            eyeScoreElement.textContent = `${eyeScoreData.score}%`;
            eyeScoreElement.style.color = eyeScoreData.level === 'high' ? '#4CAF50' : 
                                          eyeScoreData.level === 'medium' ? '#FFA500' : '#F44336';
        }
        
        // Update alignment display
        const alignmentScoreElement = document.getElementById('eye-alignment-score');
        if (alignmentScoreElement) {
            const alignment = Math.round(100 - eyeScoreData.normalizedDistance * 100);
            alignmentScoreElement.textContent = `${alignment}%`;
            alignmentScoreElement.style.color = alignment > 80 ? '#4CAF50' : 
                                                alignment > 60 ? '#FFA500' : '#F44336';
        }
        
        // Update direction display
        const focusDirectionElement = document.getElementById('focus-direction');
        if (focusDirectionElement) {
            focusDirectionElement.textContent = eyeScoreData.direction;
            focusDirectionElement.style.color = eyeScoreData.direction === 'CENTER' ? '#4CAF50' : '#F44336';
        }
        
        // Update small info display
        const irisInfoElement = document.getElementById('iris-info');
        if (irisInfoElement) {
            irisInfoElement.innerHTML = `
                Eye Score: <strong style="color: ${eyeScoreData.level === 'high' ? '#4CAF50' : 
                                               eyeScoreData.level === 'medium' ? '#FFA500' : '#F44336'}">
                    ${eyeScoreData.score}%
                </strong><br>
                Looking: ${eyeScoreData.direction}
            `;
        }
    }

    calculateFocusMetrics() {
        if (this.irisData.confidence < 0.3) {
            this.updateEyeScoreDisplay(0, 'unknown');
            
            // Update displays
            const eyeScoreElement = document.getElementById('eye-score');
            const alignmentScoreElement = document.getElementById('eye-alignment-score');
            const focusDirectionElement = document.getElementById('focus-direction');
            
            if (eyeScoreElement) eyeScoreElement.textContent = '0%';
            if (alignmentScoreElement) alignmentScoreElement.textContent = '0%';
            if (focusDirectionElement) focusDirectionElement.textContent = '-';
            
            return;
        }
        
        // Calculate eye score
        const eyeScoreData = this.calculateEyeScore();
        
        // Update displays
        const eyeScoreElement = document.getElementById('eye-score');
        const alignmentScoreElement = document.getElementById('eye-alignment-score');
        const focusDirectionElement = document.getElementById('focus-direction');
        
        if (eyeScoreElement) eyeScoreElement.textContent = `${eyeScoreData.score}%`;
        if (alignmentScoreElement) alignmentScoreElement.textContent = `${Math.round(100 - eyeScoreData.normalizedDistance * 100)}%`;
        if (focusDirectionElement) focusDirectionElement.textContent = eyeScoreData.direction;
        
        // Update eye score status
        this.updateEyeScoreDisplay(eyeScoreData.score, eyeScoreData.level);
    }

    updateEyeScoreDisplay(score, level = 'unknown') {
        const focusStatus = document.getElementById('focus-status');
        if (!focusStatus) return;
        
        let statusClass = 'status-unknown';
        let statusText = 'Eye Score: -';
        let emoji = 'üëÅÔ∏è';
        
        switch(level) {
            case 'high':
                statusClass = 'status-focusing';
                statusText = `Eye Score: ${score}% üëç`;
                emoji = 'üëÅÔ∏è‚úÖ';
                break;
            case 'medium':
                statusClass = 'status-unknown';
                statusText = `Eye Score: ${score}% ü§î`;
                emoji = 'üëÅÔ∏è‚ö†Ô∏è';
                break;
            case 'low':
                statusClass = 'status-distracted';
                statusText = `Eye Score: ${score}% ‚ùå`;
                emoji = 'üëÅÔ∏è‚ùå';
                break;
            default:
                emoji = 'üëÅÔ∏è‚ùì';
        }
        
        focusStatus.innerHTML = `
            <div class="status-dot ${statusClass}"></div>
            <span>${emoji} ${statusText}</span>
        `;
    }
        
    // ‚úÖ UPDATED: Draw eye tracking with aspect ratio fitting (MATCHES MODEL)
    drawEyeTracking(irisData, face = null) {
        const ctx = this.eyeCtx;
        const width = this.eyeCanvas.width;
        const height = this.eyeCanvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // ‚úÖ MODEL'S APPROACH: Draw the eye display video frame with aspect ratio fitting
        if (this.eyeDisplayVideo && this.eyeDisplayVideo.videoWidth > 0) {
            // Calculate aspect ratio fit (like model)
            const videoWidth = this.eyeDisplayVideo.videoWidth;
            const videoHeight = this.eyeDisplayVideo.videoHeight;
            const videoRatio = videoWidth / videoHeight;
            const canvasRatio = width / height;
            
            let renderWidth, renderHeight, offsetX, offsetY;
            
            if (videoRatio > canvasRatio) {
                // Video is wider than canvas
                renderHeight = height;
                renderWidth = height * videoRatio;
                offsetX = (width - renderWidth) / 2;
                offsetY = 0;
            } else {
                // Video is taller than canvas
                renderWidth = width;
                renderHeight = width / videoRatio;
                offsetX = 0;
                offsetY = (height - renderHeight) / 2;
            }
            
            // Draw video (like model)
            ctx.drawImage(this.eyeDisplayVideo, offsetX, offsetY, renderWidth, renderHeight);
            
            // Calculate scaling factors for coordinate conversion
            const scaleX = renderWidth / videoWidth;
            const scaleY = renderHeight / videoHeight;
            
            // If we have good iris data, draw visualization
            if (irisData.confidence > 0.2) {
                // Use these offsets and scales for correct positioning
                this.drawEnhancedEyeVisualization(irisData, ctx, width, height, offsetX, offsetY, scaleX, scaleY);
            }
            
            // ‚úÖ Draw face mesh if available (like model)
            if (face && face.mesh) {
                this.drawFaceMesh(ctx, face.mesh, offsetX, offsetY, scaleX, scaleY);
            }
        } else {
            // Fallback if display video not available
            this.drawNoFace();
        }
    }

    // ‚úÖ ADDED: Draw face mesh (MATCHES MODEL)
    drawFaceMesh(ctx, mesh, offsetX, offsetY, scaleX, scaleY) {
        if (!mesh || mesh.length === 0) return;
        
        // Draw facial landmarks
        ctx.fillStyle = 'rgba(255, 100, 255, 0.6)';
        mesh.forEach(point => {
            if (point && point.length >= 2) {
                const x = offsetX + point[0] * scaleX;
                const y = offsetY + point[1] * scaleY;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    // ‚úÖ UPDATED: Enhanced eye visualization with proper scaling
drawEnhancedEyeVisualization(irisData, ctx, width, height, offsetX = 0, offsetY = 0, scaleX = 1, scaleY = 1) {
    // ‚úÖ EXACTLY LIKE MODEL
    const leftX = offsetX + (irisData.left[0] || 0) * scaleX;
    const leftY = offsetY + (irisData.left[1] || 0) * scaleY;
    const rightX = offsetX + (irisData.right[0] || 0) * scaleX;
    const rightY = offsetY + (irisData.right[1] || 0) * scaleY;
    
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Calculate eye score
    const eyeScoreData = this.calculateEyeScore();
    const colors = this.getEyeScoreColors(eyeScoreData.score, eyeScoreData.level);
    
    // 1. Draw screen center target
    this.drawScreenCenterTarget(ctx, centerX, centerY, colors.centerTarget);
    
    // 2. Draw arrows from screen center to each eye
    if (irisData.confidence > 0.3) {
        this.drawArrowToEye(ctx, centerX, centerY, leftX, leftY, eyeScoreData, "left");
        this.drawArrowToEye(ctx, centerX, centerY, rightX, rightY, eyeScoreData, "right");
    }
    
    // 3. Draw eye circles (EXACTLY LIKE MODEL)
    if (irisData.confidence > 0.2) {
        ctx.strokeStyle = colors.eyeCircle;
        ctx.lineWidth = 3;
        
        // ‚úÖ USE Math.min(scaleX, scaleY) LIKE MODEL
        const circleRadius = 6 * Math.min(scaleX, scaleY);
        
        ctx.beginPath();
        ctx.arc(leftX, leftY, circleRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(rightX, rightY, circleRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        // 4. Draw crosshairs on pupils
        ctx.strokeStyle = colors.crosshair;
        ctx.lineWidth = 2;
        
        this.drawCrosshair(ctx, leftX, leftY, 4 * Math.min(scaleX, scaleY));
        this.drawCrosshair(ctx, rightX, rightY, 4 * Math.min(scaleX, scaleY));
    }
    
    // 5. Draw score visualization
    this.drawEyeScoreVisualization(ctx, eyeScoreData, width, height);
}

    // ‚úÖ ADDED: Draw arrow to eye
drawArrowToEye(ctx, fromX, fromY, toX, toY, eyeScoreData, eyeSide = "left") {
    const dx = toX - fromX;
    const dy = toY - fromY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // ‚úÖ Only draw if eyes are NOT at center
    if (distance < 5) return; // Eyes are centered
    
    const angle = Math.atan2(dy, dx);
    const headLength = Math.min(12, distance * 0.3);
    
    // Colors from model
    let arrowColor;
    if (eyeSide === "left") {
        arrowColor = '#ff6b8b'; // Pink like model
    } else {
        arrowColor = '#8ac6d1'; // Blue like model
    }
    
    // Draw arrow line (dashed like model)
    ctx.strokeStyle = arrowColor;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 3]);
    
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // Draw arrowhead at EYE position
    ctx.fillStyle = arrowColor;
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(
        toX - headLength * Math.cos(angle - Math.PI/6),
        toY - headLength * Math.sin(angle - Math.PI/6)
    );
    ctx.lineTo(
        toX - headLength * Math.cos(angle + Math.PI/6),
        toY - headLength * Math.sin(angle + Math.PI/6)
    );
    ctx.closePath();
    ctx.fill();
}

    // ‚úÖ ADDED: Draw crosshair
    drawCrosshair(ctx, x, y, size) {
        // Horizontal line
        ctx.beginPath();
        ctx.moveTo(x - size, y);
        ctx.lineTo(x + size, y);
        ctx.stroke();
        
        // Vertical line
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x, y + size);
        ctx.stroke();
        
        // Center dot
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // ‚úÖ ADDED: Get eye score colors
    getEyeScoreColors(score, level) {
        switch(level) {
            case 'high': // 80-100%
                return {
                    eyeCircle: 'rgba(76, 175, 80, 0.8)',    // Bright Green
                    crosshair: '#4CAF50',                  // Green
                    arrow: '#4CAF50',                      // Green
                    centerTarget: '#4CAF50',               // Green
                    scoreText: '#4CAF50'                   // Green
                };
            case 'medium': // 50-79%
                return {
                    eyeCircle: 'rgba(255, 152, 0, 0.8)',   // Bright Orange
                    crosshair: '#FF9800',                  // Orange
                    arrow: '#FF9800',                      // Orange
                    centerTarget: '#FF9800',               // Orange
                    scoreText: '#FF9800'                   // Orange
                };
            case 'low': // 0-49%
            default:
                return {
                    eyeCircle: 'rgba(244, 67, 54, 0.8)',   // Bright Red
                    crosshair: '#F44336',                  // Red
                    arrow: '#F44336',                      // Red
                    centerTarget: '#F44336',               // Red
                    scoreText: '#F44336'                   // Red
                };
        }
    }

    // ‚úÖ ADDED: Draw eye labels
    drawEyeLabels(ctx, leftX, leftY, rightX, rightY, eyeScoreData) {
        // Draw left eye label
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(leftX - 30, leftY - 35, 60, 20);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('L EYE', leftX, leftY - 20);
        
        // Draw right eye label
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(rightX - 30, rightY - 35, 60, 20);
        ctx.fillStyle = 'white';
        ctx.fillText('R EYE', rightX, rightY - 20);
        
        ctx.textAlign = 'left';
    }

    // ‚úÖ ADDED: Draw eye score visualization
    drawEyeScoreVisualization(ctx, eyeScoreData, width, height) {
        const colors = this.getEyeScoreColors(eyeScoreData.score, eyeScoreData.level);
        
        // Draw eye score gauge in top-right corner
        const gaugeX = width - 70;
        const gaugeY = 30;
        const gaugeRadius = 25;
        
        // Background circle
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(gaugeX, gaugeY, gaugeRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Score arc
        ctx.strokeStyle = colors.scoreText;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(gaugeX, gaugeY, gaugeRadius, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * eyeScoreData.score / 100));
        ctx.stroke();
        
        // Score text
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${eyeScoreData.score}`, gaugeX, gaugeY);
        
        // "EYE SCORE" label
        ctx.font = '10px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillText('EYE', gaugeX, gaugeY + 20);
        ctx.fillText('SCORE', gaugeX, gaugeY + 32);
        
        // Reset text alignment
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    }

    // ‚úÖ ADDED: Draw screen center target
    drawScreenCenterTarget(ctx, centerX, centerY, color = '#ff6b8b') {
        // Outer glow effect
        const gradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 40);
        gradient.addColorStop(0, color + '80'); // 50% opacity
        gradient.addColorStop(1, color + '00'); // 0% opacity
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner target circle
        ctx.fillStyle = color + '40'; // 25% transparency
        ctx.beginPath();
        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Crosshair
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        
        // Horizontal line
        ctx.beginPath();
        ctx.moveTo(centerX - 30, centerY);
        ctx.lineTo(centerX + 30, centerY);
        ctx.stroke();
        
        // Vertical line
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - 30);
        ctx.lineTo(centerX, centerY + 30);
        ctx.stroke();
        
        // Center dot (arrow start point)
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // "CENTER" label
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(centerX - 25, centerY + 40, 50, 18);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('CENTER', centerX, centerY + 52);
        ctx.textAlign = 'left';
    }

    drawPositioningGuide(ctx, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Draw faint face positioning oval
        ctx.strokeStyle = 'rgba(255, 107, 139, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        // Face oval guide
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, width/3, height/2.5, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Eye position circles
        ctx.fillStyle = 'rgba(149, 225, 211, 0.2)';
        ctx.beginPath();
        ctx.arc(centerX - width/6, centerY - height/10, 8, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(centerX + width/6, centerY - height/10, 8, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.setLineDash([]);
        
        // Instruction text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Position face in oval', centerX, height - 30);
        ctx.fillText('Align eyes with circles', centerX, height - 15);
    }

    drawNoFace() {
        const ctx = this.eyeCtx;
        const width = this.eyeCanvas.width;
        const height = this.eyeCanvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Draw background
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#0a0a1a');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw screen center target
        this.drawScreenCenterTarget(ctx, width, height, '#ff6b8b');
        
        // Draw "no face" message
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No face detected', width / 2, height / 2);
    }
    
    updateMickeyAgent(face) {
        if (!face) return;
        
        // Get current emotion
        const dominantEmotion = this.getDominantEmotion(face);
        this.studentEmotion = dominantEmotion.name;
        
        // Track emotion for intervention
        this.trackEmotionForIntervention(this.studentEmotion);
    }
    
    trackEmotionForIntervention(emotion) {
        const now = Date.now();
        
        // Add to history
        this.emotionInterventionData.emotionHistory.push({
            emotion: emotion,
            timestamp: now
        });
        
        // Keep only recent history (last 10 seconds)
        this.emotionInterventionData.emotionHistory = this.emotionInterventionData.emotionHistory.filter(
            entry => (now - entry.timestamp) < 10000
        );
        
        // Count negative emotions
        const negativeEmotions = this.emotionInterventionData.emotionHistory.filter(
            entry => ['angry', 'sad', 'confused'].includes(entry.emotion)
        ).length;
        
        this.emotionInterventionData.negativeEmotionCount = negativeEmotions;
        
        // Check if we need to intervene
        if (negativeEmotions >= this.emotionInterventionData.NEGATIVE_THRESHOLD && 
            (now - this.emotionInterventionData.lastInterventionTime) > this.emotionInterventionData.interventionCooldown) {
            
            this.triggerEmotionIntervention(emotion);
        }
    }

    triggerEmotionIntervention(emotion) {
        const now = Date.now();
        this.emotionInterventionData.lastInterventionTime = now;
        
        // Get intervention data for this emotion
        const interventionData = botPhrases.intervention[emotion] || botPhrases.intervention.frustrated;
        
        // Show interactive intervention with immediate buttons
        this.showInteractiveIntervention(interventionData, emotion);
        
        // Reset negative count after intervention
        this.emotionInterventionData.negativeEmotionCount = 0;
        
        console.log(`üé§ Interactive intervention triggered for: ${emotion}`);
    } 

    showInteractiveIntervention(interventionData, emotion) {
        // Show the bot with message AND buttons immediately
        showSpeakingBot(interventionData.message, {
            type: 'intervention',
            autoClose: false,
            showOptions: true,
            options: interventionData.options,
            emotion: emotion
        });
    }

    showSuccess(message) {
        this.updateStatusPanel('success', message);
    }
    
    showError(message) {
        this.updateStatusPanel('error', message);
    }
    
    showInfo(message) {
        this.updateStatusPanel('info', message);
    }
    
    updateStatusPanel(type, message) {
        const statusPanel = document.getElementById('detection-status');
        if (!statusPanel) return;
        
        let icon = 'fa-magic';
        let title = 'ENHANCED EMOTION & EYE TRACKING';
        let color = 'var(--mickey-black)';
        
        switch(type) {
            case 'success':
                icon = 'fa-check-circle';
                color = 'var(--mickey-green)';
                break;
            case 'error':
                icon = 'fa-exclamation-circle';
                color = 'var(--mickey-red)';
                break;
            case 'info':
                icon = 'fa-info-circle';
                color = 'var(--mickey-blue)';
                break;
        }
        
        statusPanel.innerHTML = `
            <div class="status-header">
                <div class="status-icon" style="color: ${color};">
                    <i class="fas ${icon}"></i>
                </div>
                <div class="status-title">
                    ${title}
                </div>
            </div>
            <div class="status-message">
                ${message}
            </div>
        `;
    }
    
    // ‚úÖ ADDED: Debug function
    debugEyeTracking() {
        console.log("üîç Eye Tracking Debug:");
        console.log("- Is eye tracking?", this.isEyeTracking);
        console.log("- Iris video element:", this.irisVideo);
        console.log("- Iris video readyState:", this.irisVideo?.readyState);
        console.log("- Display video element:", this.eyeDisplayVideo);
        console.log("- Iris data:", this.irisData);
        
        // Test calculateEyeScore
        const score = this.calculateEyeScore();
        console.log("- Eye score:", score);
        
        // Check UI elements
        console.log("- iris-info element:", document.getElementById('iris-info'));
        console.log("- focus-status element:", document.getElementById('focus-status'));
    }
}

// Initialize dual camera detection
        let dualCameraDetection = null;

        // ============================================
        // PAGE VISIBILITY API (BUILT INTO BROWSER)
        // ============================================

        class TabFocusTracker {
            constructor() {
                this.isTabActive = true;
                this.tabSwitchCount = 0;
                this.lastTabSwitchTime = Date.now();
                this.totalInactiveTime = 0;
                this.startTime = Date.now();
                this.lastActiveTime = Date.now();
                this.inactiveMinutes = 0;
                
                // Initialize event listeners directly in constructor
                this.init();
                
                // Start monitoring inactivity
                this.startInactivityMonitoring();
            }
            
            init() {
                // Handle page visibility changes
                document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
                
                // Handle page blur/focus for additional tracking
                window.addEventListener('blur', () => {
                    this.isTabActive = false;
                    this.tabSwitchCount++;
                    this.lastTabSwitchTime = Date.now();
                });
                
                window.addEventListener('focus', () => {
                    const inactiveDuration = Date.now() - this.lastTabSwitchTime;
                    this.totalInactiveTime += inactiveDuration;
                    this.isTabActive = true;
                    this.lastActiveTime = Date.now();
                });
            }
            
            startInactivityMonitoring() {
                // Update inactive minutes every minute
                setInterval(() => {
                    if (!this.isTabActive) {
                        const inactiveSeconds = (Date.now() - this.lastActiveTime) / 1000;
                        this.inactiveMinutes = Math.floor(inactiveSeconds / 60);
                    }
                }, 60000); // Check every minute
            }
            
            handleVisibilityChange() {
                if (document.hidden) {
                    // Tab became inactive
                    this.isTabActive = false;
                    this.tabSwitchCount++;
                    this.lastTabSwitchTime = Date.now();
                    
                    console.log('üö® Tab switched away! Focus score will be affected.');
                    
                    // Update calculation manager
                    if (calculationManager) {
                        calculationManager.updateTabTracking(this.tabSwitchCount, this.inactiveMinutes);
                    }
                } else {
                    // Tab became active again
                    const inactiveDuration = Date.now() - this.lastTabSwitchTime;
                    this.totalInactiveTime += inactiveDuration;
                    this.isTabActive = true;
                    this.lastActiveTime = Date.now();
                    
                    console.log(`‚úÖ Tab back after ${Math.round(inactiveDuration/1000)} seconds`);
                    
                    // Update calculation manager
                    if (calculationManager) {
                        calculationManager.updateTabTracking(this.tabSwitchCount, this.inactiveMinutes);
                    }
                }
            }
            
            getFocusReport() {
                const sessionDuration = Date.now() - this.startTime;
                const activeTime = sessionDuration - this.totalInactiveTime;
                const focusPercentage = (activeTime / sessionDuration * 100) || 100;
                
                return {
                    isTabActive: this.isTabActive,
                    tabSwitchCount: this.tabSwitchCount,
                    totalInactiveTime: this.totalInactiveTime,
                    inactiveMinutes: this.inactiveMinutes,
                    focusPercentage: Math.round(focusPercentage),
                    lastActiveTime: this.lastActiveTime,
                    lastSwitchTime: this.lastTabSwitchTime
                };
            }
        }

        // ============================================
        // ENHANCED DUAL CAMERA DETECTION SYSTEM
        // ============================================

        // 3. Initialize the Tab Tracker
        let tabTracker = null;

        function initTabFocusTracking() {
            tabTracker = new TabFocusTracker();
            
            // Add to your existing initialization
            console.log("‚úÖ Tab focus tracking initialized");
            
            // Prevent cheating by opening developer tools (optional)
            preventDevToolsCheating();
        }

        function preventDevToolsCheating() {
            // Detect if developer tools opens (students might try to disable tracking)
            const devToolsOpen = /./;
            devToolsOpen.toString = function() {
                console.warn("‚ö†Ô∏è Developer tools detected!");
                tabTracker.deductPointsForTabSwitch();
                return "‚ö†Ô∏è Focus on learning, not developer tools!";
            };
            
            console.log(devToolsOpen);
        }

        // 4. Update Your Profile Display
        function updateFocusDisplayInProfile() {
            if (!tabTracker) return;
            
            const report = tabTracker.getFocusReport();
            
            const focusHTML = `
                <div style="background: var(--mickey-white); padding: 20px; border-radius: 15px; 
                            border: 4px solid var(--mickey-black); margin-bottom: 20px;">
                    <h3 style="color: var(--mickey-red); margin-top: 0;">
                        <i class="fas fa-desktop"></i> Tab Focus Tracker
                    </h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
                        <div style="background: ${report.isTabActive ? '#95e1d3' : '#ff6b8b'}; 
                                    padding: 15px; border-radius: 10px; border: 3px solid var(--mickey-black); text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold;">
                                ${report.isTabActive ? '‚úÖ ACTIVE' : 'üö® INACTIVE'}
                            </div>
                            <div style="font-size: 0.9rem;">
                                Current Tab Status
                            </div>
                        </div>
                        
                        <div style="background: var(--mickey-yellow); padding: 15px; 
                                    border-radius: 10px; border: 3px solid var(--mickey-black); text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--mickey-red);">
                                ${report.tabSwitchCount}
                            </div>
                            <div style="font-size: 0.9rem;">
                                Tab Switches
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: var(--mickey-blue); color: white; padding: 10px; 
                                border-radius: 10px; margin-top: 10px; text-align: center;">
                        <i class="fas fa-info-circle"></i>
                        <strong>Focus Score:</strong> ${report.focusPercentage}%
                        <br>
                        <small>${report.tabSwitchCount > 0 ? 
                            `Lost ${report.tabSwitchCount * 10} points for switching tabs` : 
                            'Great focus! Keep it up!'}</small>
                    </div>
                </div>
            `;
            
            // Add to profile or create new section
            const profileContent = document.getElementById('profile-content-area') || 
                                document.querySelector('.profile-content');
            if (profileContent) {
                const existingTracker = profileContent.querySelector('.tab-tracker-display');
                if (existingTracker) {
                    existingTracker.innerHTML = focusHTML;
                } else {
                    const trackerDiv = document.createElement('div');
                    trackerDiv.className = 'tab-tracker-display';
                    trackerDiv.innerHTML = focusHTML;
                    profileContent.querySelector('.student-profile').appendChild(trackerDiv);
                }
            }
        }

        function updatePerformanceDisplay() {
            if (!calculationManager) return;
            
            const performanceData = calculationManager.getProfilePerformanceData();
            const trend = calculationManager.getPerformanceTrend();
            
            // Update the cards
            document.getElementById('total-calculations').textContent = performanceData.totalCalculations;
            document.getElementById('calc-speed').textContent = `Avg: ${performanceData.averageCalcTime}ms`;
            
            document.getElementById('focus-accuracy').textContent = `${performanceData.focusAccuracy}%`;
            document.getElementById('focus-status').textContent = `Status: ${performanceData.focusStatus}`;
            
            document.getElementById('emotion-accuracy').textContent = `${performanceData.emotionConfidence}%`;
            document.getElementById('emotion-status').textContent = `Status: ${performanceData.emotionStatus}`;
            
            document.getElementById('system-health').textContent = `${performanceData.systemHealth}%`;
            document.getElementById('last-update').textContent = `Updated: ${performanceData.lastUpdate}`;
            
            // Update progress bars
            const calcSpeedBar = document.getElementById('calc-speed-bar');
            const calcSpeedText = document.getElementById('calc-speed-text');
            const focusAccuracyBar = document.getElementById('focus-accuracy-bar');
            const focusAccuracyText = document.getElementById('focus-accuracy-text');
            const emotionConfidenceBar = document.getElementById('emotion-confidence-bar');
            const emotionConfidenceText = document.getElementById('emotion-confidence-text');
            
            // Calculation speed (inverted - lower is better)
            const calcSpeedPercent = Math.max(0, Math.min(100, 100 - performanceData.averageCalcTime));
            if (calcSpeedBar) {
                calcSpeedBar.style.width = `${calcSpeedPercent}%`;
                calcSpeedBar.style.background = calcSpeedPercent > 70 ? 'linear-gradient(90deg, #4CAF50, #8BC34A)' :
                                            calcSpeedPercent > 40 ? 'linear-gradient(90deg, #FF9800, #FFB74D)' :
                                            'linear-gradient(90deg, #F44336, #EF5350)';
            }
            if (calcSpeedText) {
                calcSpeedText.textContent = `${performanceData.averageCalcTime}ms avg`;
                calcSpeedText.style.color = calcSpeedPercent > 70 ? '#4CAF50' :
                                        calcSpeedPercent > 40 ? '#FF9800' : '#F44336';
            }
            
            // Focus accuracy
            if (focusAccuracyBar) {
                focusAccuracyBar.style.width = `${performanceData.focusAccuracy}%`;
                focusAccuracyBar.style.background = performanceData.focusAccuracy > 70 ? 'linear-gradient(90deg, #2196F3, #03A9F4)' :
                                                performanceData.focusAccuracy > 40 ? 'linear-gradient(90deg, #00BCD4, #0097A7)' :
                                                'linear-gradient(90deg, #757575, #9E9E9E)';
            }
            if (focusAccuracyText) {
                focusAccuracyText.textContent = `${performanceData.focusAccuracy}%`;
                focusAccuracyText.style.color = performanceData.focusAccuracy > 70 ? '#2196F3' :
                                            performanceData.focusAccuracy > 40 ? '#00BCD4' : '#757575';
            }
            
            // Emotion confidence
            if (emotionConfidenceBar) {
                emotionConfidenceBar.style.width = `${performanceData.emotionConfidence}%`;
                emotionConfidenceBar.style.background = performanceData.emotionConfidence > 70 ? 'linear-gradient(90deg, #E91E63, #FF4081)' :
                                                    performanceData.emotionConfidence > 40 ? 'linear-gradient(90deg, #9C27B0, #BA68C8)' :
                                                    'linear-gradient(90deg, #795548, #A1887F)';
            }
            if (emotionConfidenceText) {
                emotionConfidenceText.textContent = `${performanceData.emotionConfidence}%`;
                emotionConfidenceText.style.color = performanceData.emotionConfidence > 70 ? '#E91E63' :
                                                performanceData.emotionConfidence > 40 ? '#9C27B0' : '#795548';
            }
            
            // Add trend indicator
            const trendIndicator = document.getElementById('trend-indicator');
            if (!trendIndicator && document.querySelector('.performance-section')) {
                const perfSection = document.querySelector('.performance-section');
                const trendDiv = document.createElement('div');
                trendDiv.id = 'trend-indicator';
                trendDiv.style.cssText = `
                    margin-top: 15px;
                    padding: 10px;
                    border-radius: 10px;
                    background: ${trend.direction === 'down' ? 'rgba(76, 175, 80, 0.1)' : 
                                trend.direction === 'up' ? 'rgba(244, 67, 54, 0.1)' : 'rgba(33, 150, 243, 0.1)'};
                    border: 2px solid ${trend.direction === 'down' ? '#4CAF50' : 
                                    trend.direction === 'up' ? '#F44336' : '#2196F3'};
                    font-family: 'Comic Neue', cursive;
                    font-size: 0.9rem;
                `;
                trendDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-${trend.direction === 'down' ? 'arrow-down' : 
                                        trend.direction === 'up' ? 'arrow-up' : 'minus'}" 
                        style="color: ${trend.direction === 'down' ? '#4CAF50' : 
                                        trend.direction === 'up' ? '#F44336' : '#2196F3'};"></i>
                        <div>
                            <strong>Performance Trend:</strong> ${trend.trend}
                            <div style="font-size: 0.8rem; opacity: 0.8;">
                                Calculation time ${trend.direction === 'down' ? 'improving' : 
                                                trend.direction === 'up' ? 'increasing' : 'stable'} 
                                (${trend.change > 0 ? '+' : ''}${trend.change}%)
                            </div>
                        </div>
                    </div>
                `;
                perfSection.querySelector('.performance-progress').appendChild(trendDiv);
            } else if (trendIndicator) {
                trendIndicator.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-${trend.direction === 'down' ? 'arrow-down' : 
                                        trend.direction === 'up' ? 'arrow-up' : 'minus'}" 
                        style="color: ${trend.direction === 'down' ? '#4CAF50' : 
                                        trend.direction === 'up' ? '#F44336' : '#2196F3'};"></i>
                        <div>
                            <strong>Performance Trend:</strong> ${trend.trend}
                            <div style="font-size: 0.8rem; opacity: 0.8;">
                                Calculation time ${trend.direction === 'down' ? 'improving' : 
                                                trend.direction === 'up' ? 'increasing' : 'stable'} 
                                (${trend.change > 0 ? '+' : ''}${trend.change}%)
                            </div>
                        </div>
                    </div>
                `;
                trendIndicator.style.background = trend.direction === 'down' ? 'rgba(76, 175, 80, 0.1)' : 
                                                trend.direction === 'up' ? 'rgba(244, 67, 54, 0.1)' : 'rgba(33, 150, 243, 0.1)';
                trendIndicator.style.borderColor = trend.direction === 'down' ? '#4CAF50' : 
                                                trend.direction === 'up' ? '#F44336' : '#2196F3';
            }
        }

        // Function to show detailed performance report
        function showDetailedPerformance() {
            if (!calculationManager) {
                alert("Performance tracking not available yet.");
                return;
            }
            
            const performanceData = calculationManager.getProfilePerformanceData();
            const trend = calculationManager.getPerformanceTrend();
            
            const details = `
                <div style="text-align: left; font-family: 'Comic Neue', cursive; max-width: 500px;">
                    <h3 style="color: var(--mickey-red); text-align: center;">
                        <i class="fas fa-chart-bar"></i> Detailed Performance Report
                    </h3>
                    
                    <div style="background: var(--mickey-white); padding: 15px; border-radius: 10px; 
                        border: 3px solid var(--mickey-black); margin-bottom: 15px;">
                        <h4 style="color: var(--mickey-blue); margin-top: 0;">
                            <i class="fas fa-calculator"></i> Calculation Performance
                        </h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>Total Calculations:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.totalCalculations}</div>
                            
                            <div>Average Time:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.averageCalcTime}ms</div>
                            
                            <div>Fastest:</div>
                            <div style="text-align: right; font-weight: bold; color: #4CAF50;">${performanceData.minCalcTime}ms</div>
                            
                            <div>Slowest:</div>
                            <div style="text-align: right; font-weight: bold; color: #F44336;">${performanceData.maxCalcTime}ms</div>
                            
                            <div>Trend:</div>
                            <div style="text-align: right; font-weight: bold; color: ${trend.direction === 'down' ? '#4CAF50' : '#F44336'}">
                                ${trend.trend} (${trend.change > 0 ? '+' : ''}${trend.change}%)
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: var(--mickey-white); padding: 15px; border-radius: 10px; 
                        border: 3px solid var(--mickey-black); margin-bottom: 15px;">
                        <h4 style="color: var(--mickey-blue); margin-top: 0;">
                            <i class="fas fa-eye"></i> Detection Performance
                        </h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>Focus Detections:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.focusDetections}</div>
                            
                            <div>Focus Accuracy:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.focusAccuracy}%</div>
                            
                            <div>Emotion Detections:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.emotionDetections}</div>
                            
                            <div>Last Emotion:</div>
                            <div style="text-align: right; font-weight: bold; color: var(--mickey-pink);">
                                ${performanceData.lastEmotion}
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: var(--mickey-white); padding: 15px; border-radius: 10px; 
                        border: 3px solid var(--mickey-black);">
                        <h4 style="color: var(--mickey-blue); margin-top: 0;">
                            <i class="fas fa-heartbeat"></i> System Information
                        </h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>System Health:</div>
                            <div style="text-align: right; font-weight: bold; 
                                color: ${performanceData.systemHealth > 70 ? '#4CAF50' : 
                                        performanceData.systemHealth > 40 ? '#FF9800' : '#F44336'}">
                                ${performanceData.systemHealth}%
                            </div>
                            
                            <div>Uptime:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.uptime}</div>
                            
                            <div>Last Update:</div>
                            <div style="text-align: right; font-weight: bold;">${performanceData.lastUpdate}</div>
                            
                            <div>Cache Entries:</div>
                            <div style="text-align: right; font-weight: bold;">
                                ${Object.keys(calculationManager.calculationCache).length}
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="module-btn" onclick="closeModal()" 
                                style="background: var(--mickey-red); color: white; padding: 10px 20px;">
                            <i class="fas fa-times"></i> Close
                        </button>
                    </div>
                </div>
            `;
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'performance-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10010;
                display: flex;
                align-items: center;
                justify-content: center;
                animation: fadeIn 0.3s ease;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: var(--mickey-white);
                border-radius: 25px;
                border: 5px solid var(--mickey-black);
                padding: 30px;
                max-width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                animation: bounceIn 0.5s ease;
            `;
            
            modalContent.innerHTML = details;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }

        // Function to refresh performance data
        function refreshPerformanceData() {
            updatePerformanceDisplay();
            
            // Show refresh animation
            const refreshBtn = event?.target || document.querySelector('[onclick="refreshPerformanceData()"]');
            if (refreshBtn) {
                const originalHTML = refreshBtn.innerHTML;
                refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
                refreshBtn.disabled = true;
                
                setTimeout(() => {
                    refreshBtn.innerHTML = originalHTML;
                    refreshBtn.disabled = false;
                }, 1000);
            }
            
            // Show notification
            showNotification("Performance Dashboard", "Performance data refreshed!", "success");
        }

        // Function to reset performance counters
        function resetPerformanceCounters() {
            if (confirm("Are you sure you want to reset all performance counters? This cannot be undone.")) {
                calculationManager.resetCounters();
                updatePerformanceDisplay();
                showNotification("Performance Dashboard", "All counters have been reset!", "info");
            }
        }

        // Function to close modal
        function closeModal() {
            const modal = document.getElementById('performance-modal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }

        // Start auto-update of performance display
        function startPerformanceMonitoring() {
            // Update every 5 seconds when on profile tab
            setInterval(() => {
                if (document.getElementById('profile-content-area')?.classList.contains('active')) {
                    updatePerformanceDisplay();
                }
            }, 5000);
            
            // Also update immediately when switching to profile tab
            const profileTab = document.getElementById('profile-tab');
            if (profileTab) {
                profileTab.addEventListener('click', () => {
                    setTimeout(updatePerformanceDisplay, 100);
                });
            }
            
            console.log('‚úÖ Performance monitoring started');
        }

        // ============================================
        // INDEPENDENT SPEAKING BOT SYSTEM
        // ============================================

        // Bot speaking queue system
        const botSpeakingQueue = {
            messages: [],
            isSpeaking: false,
            currentUtterance: null,
            currentCallback: null,
            autoClose: true
        };

        // Common bot phrases for different scenarios
        const botPhrases = {
            welcome: [
                "Great to see you again! Let's continue our adventure! I'm excited to help you learn today!"
            ],
            
            intervention: {
                angry: {
                    message: "I notice you're feeling frustrated. How can I help you feel better?",
                    options: [
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                        { text: "Make it easier", icon: "fa-thumbs-up", action: "easier", color: "var(--mickey-green)" },
                        { text: "Skip this", icon: "fa-forward", action: "skip", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                sad: {
                    message: "I see you're feeling a bit down. What would help you feel better?",
                    options: [
                        { text: "Tell me a joke", icon: "fa-grin-squint", action: "joke", color: "var(--mickey-pink)" },
                        { text: "Different activity", icon: "fa-random", action: "different", color: "var(--mickey-green)" },
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                confused: {
                    message: "This seems confusing. How can I help you understand better?",
                    options: [
                        { text: "Explain differently", icon: "fa-comment-alt", action: "explain", color: "var(--mickey-pink)" },
                        { text: "Give me a hint", icon: "fa-lightbulb", action: "hint", color: "var(--mickey-green)" },
                        { text: "Go back to basics", icon: "fa-undo", action: "basics", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                frustrated: {
                    message: "This seems tricky. What would you like to do?",
                    options: [
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                        { text: "Make it easier", icon: "fa-thumbs-up", action: "easier", color: "var(--mickey-green)" },
                        { text: "Give me a hint", icon: "fa-lightbulb", action: "hint", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                },
                distracted: {
                    message: "I notice your attention drifting. What would help you refocus?",
                    options: [
                        { text: "Take a break", icon: "fa-coffee", action: "break", color: "var(--mickey-pink)" },
                        { text: "Do a quick stretch", icon: "fa-running", action: "stretch", color: "var(--mickey-green)" },
                        { text: "Switch activity", icon: "fa-random", action: "different", color: "var(--mickey-blue)" },
                        { text: "I'm okay", icon: "fa-check", action: "continue", color: "var(--mickey-yellow)" }
                    ]
                }
            },
            
            greeting: [
                "Yes! How may I help you?",
                "I'm here! What can I do for you?",
                "Hello! What would you like to know?",
                "How can I assist you today?"
            ],
            
            encouragement: [
                "You're doing amazing! Keep up the great work!",
                "Wow! I'm so impressed with your progress!",
                "You're getting better every time! I'm so proud of you!",
                "That was fantastic! You're a natural at this!"
            ],
            
            correction: [
                "That's okay! Let's try it again together.",
                "Almost there! Try one more time.",
                "Good effort! Now let me show you the right way.",
                "Not quite, but you're getting closer!"
            ],
            
            break: [
                "Time for a quick break! Let's stretch and come back refreshed!",
                "Great work so far! How about a 30-second break?",
                "You've been working hard! Let's take a moment to relax."
            ],
            
            gameComplete: [
                "Congratulations! You completed the game! You're a superstar!",
                "Amazing job! You finished all the activities!",
                "Hooray! You did it! I'm so proud of you!"
            ]
        };

        // Initialize the speaking bot system
        function initSpeakingBot() {
            console.log("Initializing speaking bot system...");
            
            // Continue button
            const continueBtn = document.getElementById('bot-speaker-continue');
            if (continueBtn) {
                continueBtn.addEventListener('click', hideSpeakingBot);
            }
            
            // Escape key to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('speaking-bot-overlay').style.display === 'block') {
                    hideSpeakingBot();
                }
            });
            
            // Click outside to close (only when autoClose is false)
            const overlay = document.getElementById('speaking-bot-overlay');
            if (overlay) {
                overlay.addEventListener('click', function(e) {
                    if (e.target === this && !botSpeakingQueue.autoClose) {
                        hideSpeakingBot();
                    }
                });
            }
            
            // Speak welcome message if just logged in
            const userRole = localStorage.getItem('userRole');
            if (userRole) {
                setTimeout(() => {
                    speakWelcomeMessage();
                }, 1000);
            }
            
            console.log("‚úÖ Speaking bot system initialized!");
        }

        // Handle clicking on the speaking bot bubble
        function handleSpeakingBotClick() {
            // If bot is currently speaking, stop it
            if (botSpeakingQueue.isSpeaking) {
                stopBotSpeaking();
                hideSpeakingBot();
                return;
            }
            
            // If bot was just speaking and closed, show greeting
            if (document.getElementById('speaking-bot-overlay').style.display === 'none') {
                speakBotGreeting();
            }
        }

        // Show the speaking bot overlay
        function showSpeakingBot(message, options = {}) {
            const overlay = document.getElementById('speaking-bot-overlay');
            const container = document.getElementById('speaking-bot-container');
            const statusText = document.getElementById('bot-speaker-status-text');
            const continueBtn = document.getElementById('bot-speaker-continue');
            const sideBubble = document.getElementById('side-speaking-bot');
            
            // Set options
            const settings = {
                autoClose: options.autoClose !== undefined ? options.autoClose : true,
                onComplete: options.onComplete || null,
                type: options.type || 'info',
                duration: options.duration || 3000,
                showOptions: options.showOptions || false,
                botOptions: options.options || [],
                emotion: options.emotion || null
            };
            
            botSpeakingQueue.autoClose = settings.autoClose;
            botSpeakingQueue.currentCallback = settings.onComplete;
            
            // Update side bubble state
            if (sideBubble) {
                sideBubble.classList.add('active');
            }
            
            // Hide message indicator
            hideBotMessageIndicator();
            
            // Show overlay
            overlay.style.display = 'block';
            container.classList.add('speaking');
            
            // Update status text
            if (statusText) {
                statusText.textContent = getStatusText(settings.type);
            }
            
            // Hide continue button initially
            continueBtn.classList.remove('show');
            
            // Show options immediately if specified
            if (settings.showOptions && settings.botOptions.length > 0) {
                this.createInterventionOptions(settings.botOptions, settings.emotion);
            }
            
            // Start speaking
            speakBotMessage(message, settings);
        }

        function createInterventionOptions(options, emotion) {
            const botStatus = document.getElementById('bot-speaker-status');
            if (!botStatus) return;
            
            // Remove any existing options
            const existingOptions = document.getElementById('intervention-options');
            if (existingOptions) {
                existingOptions.remove();
            }
            
            // Create options container
            const optionsContainer = document.createElement('div');
            optionsContainer.id = 'intervention-options';
            optionsContainer.className = 'intervention-options';
            optionsContainer.style.cssText = `
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
                margin-top: 100px;
                width: 100%;
                animation: slideUp 0.3s ease;
            `;
            
            // Create option buttons
            options.forEach((option, index) => {
                const optionBtn = document.createElement('button');
                optionBtn.className = 'intervention-option-btn';
                optionBtn.style.cssText = `
                    padding: 12px 8px;
                    background: ${option.color || 'var(--mickey-white)'};
                    color: var(--mickey-black);
                    border: 3px solid var(--mickey-black);
                    border-radius: 15px;
                    font-family: 'Fredoka One', cursive;
                    cursor: pointer;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    gap: 8px;
                    transition: all 0.3s;
                    font-size: 0.8rem;
                    min-height: 60px;
                `;
                
                optionBtn.innerHTML = `
                    <i class="fas ${option.icon}" style="font-size: 1.2rem;"></i>
                    <span>${option.text}</span>
                `;
                
                // Add hover effects
                optionBtn.addEventListener('mouseenter', () => {
                    optionBtn.style.transform = 'translateY(-3px)';
                    optionBtn.style.boxShadow = '0 5px 0 var(--mickey-black)';
                });
                
                optionBtn.addEventListener('mouseleave', () => {
                    optionBtn.style.transform = 'translateY(0)';
                    optionBtn.style.boxShadow = 'none';
                });
                
                // Add click handler
                optionBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleInterventionChoice(option.action, emotion);
                });
                
                optionsContainer.appendChild(optionBtn);
            });
            
            // Add to bot status container
            botStatus.appendChild(optionsContainer);
        }

        // Global function to handle intervention choices
        function handleInterventionChoice(choice, emotion) {
            console.log(`User chose intervention: ${choice} for emotion: ${emotion}`);
            
            let responseMessage = "";
            let actionFunction = null;
            
            switch(choice) {
                case 'break':
                    responseMessage = "Great idea! Let's take a quick break.";
                    actionFunction = () => startMickeyBreak();
                    break;
                    
                case 'easier':
                    responseMessage = "I'll make this easier for you!";
                    actionFunction = () => makeGameEasier();
                    break;
                    
                case 'skip':
                    responseMessage = "Let's skip this and move to the next one!";
                    actionFunction = () => skipToNext();
                    break;
                    
                case 'continue':
                    responseMessage = "Glad you're okay! Let's continue!";
                    break;
                    
                case 'joke':
                    responseMessage = tellAJoke();
                    break;
                    
                case 'different':
                    responseMessage = "Let's try a different activity!";
                    actionFunction = () => switchToDifferentActivity();
                    break;
                    
                case 'explain':
                    responseMessage = "Let me explain this in a different way...";
                    actionFunction = () => explainDifferently();
                    break;
                    
                case 'hint':
                    responseMessage = "Here's a hint to help you...";
                    actionFunction = () => giveHint();
                    break;
                    
                case 'basics':
                    responseMessage = "Let's go back to the basics and build up!";
                    actionFunction = () => goBackToBasics();
                    break;
                    
                case 'stretch':
                    responseMessage = "Great! Let's do a quick stretch together!";
                    actionFunction = () => doQuickStretch();
                    break;
                    
                default:
                    responseMessage = "Let's continue then!";
            }
            
            // Remove options
            const optionsContainer = document.getElementById('intervention-options');
            if (optionsContainer) {
                optionsContainer.remove();
            }
            
            // Speak the response
            queueBotMessage(responseMessage, {
                type: 'info',
                autoClose: true,
                duration: 2000,
                onComplete: () => {
                    // Execute the action after speaking
                    if (actionFunction) {
                        setTimeout(actionFunction, 500);
                    }
                }
            });
        }

        // Hide the speaking bot
        function hideSpeakingBot() {
            const overlay = document.getElementById('speaking-bot-overlay');
            const container = document.getElementById('speaking-bot-container');
            const continueBtn = document.getElementById('bot-speaker-continue');
            const sideBubble = document.getElementById('side-speaking-bot');
            
            // Stop any ongoing speech
            stopBotSpeaking();
            
            // Remove options if they exist
            const optionsContainer = document.getElementById('intervention-options');
            if (optionsContainer) {
                optionsContainer.remove();
            }
            
            // Update side bubble state
            if (sideBubble) {
                sideBubble.classList.remove('active');
                
                // Show message indicator if there are queued messages
                if (botSpeakingQueue.messages.length > 0) {
                    showBotMessageIndicator();
                }
            }
            
            // Hide elements
            overlay.style.display = 'none';
            container.classList.remove('speaking');
            continueBtn.classList.remove('show');
            
            // Clear queue if autoClose is true
            if (botSpeakingQueue.autoClose) {
                botSpeakingQueue.messages = [];
            }
            
            // Process next in queue
            processSpeakingQueue();
        }

        // Queue a message for the bot to speak
        function queueBotMessage(message, options = {}) {
            botSpeakingQueue.messages.push({
                message: message,
                options: options
            });
            
            // Show message indicator on side bubble
            if (!botSpeakingQueue.isSpeaking) {
                showBotMessageIndicator();
            }
            
            // Start processing if not already speaking
            if (!botSpeakingQueue.isSpeaking) {
                processSpeakingQueue();
            }
        }

        // Process the speaking queue
        function processSpeakingQueue() {
            if (botSpeakingQueue.messages.length === 0 || botSpeakingQueue.isSpeaking) {
                return;
            }
            
            const nextItem = botSpeakingQueue.messages.shift();
            showSpeakingBot(nextItem.message, nextItem.options);
        }

        // Core speaking function
        function speakBotMessage(message, settings) {
            if (!voiceEnabled) {
                // If voice is disabled, just show the bot briefly
                setTimeout(() => {
                    completeSpeaking(settings);
                }, 2000);
                return;
            }
            
            botSpeakingQueue.isSpeaking = true;
            
            // Create speech synthesis utterance
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.rate = 0.9;
            utterance.pitch = 1.2;
            utterance.volume = 1;
            
            // Try to get a friendly voice
            const voices = speechSynthesis.getVoices();
            const friendlyVoice = voices.find(voice => 
                voice.name.includes('Child') || 
                voice.name.includes('Kids') ||
                voice.lang.includes('en')
            );
            
            if (friendlyVoice) {
                utterance.voice = friendlyVoice;
            }
            
            // Event handlers
            utterance.onstart = function() {
                onSpeechStart(settings);
            };
            
            utterance.onend = function() {
                completeSpeaking(settings);
            };
            
            utterance.onerror = function() {
                completeSpeaking(settings);
            };
            
            // Start speaking
            botSpeakingQueue.currentUtterance = utterance;
            speechSynthesis.speak(utterance);
            
            // Animate volume bar
            animateVoiceWaves();
        }

        // Function called when speech starts
        function onSpeechStart(settings) {
            const container = document.getElementById('speaking-bot-container');
            const waves = document.getElementById('speaker-waves');
            
            if (container) container.classList.add('speaking');
            if (waves) waves.style.display = 'block';
        }

        // Function called when speech completes
        function completeSpeaking(settings) {
            const continueBtn = document.getElementById('bot-speaker-continue');
            
            // Update UI
            const container = document.getElementById('speaking-bot-container');
            const waves = document.getElementById('speaker-waves');
            const statusText = document.getElementById('bot-speaker-status-text');
            
            if (container) container.classList.remove('speaking');
            if (waves) waves.style.display = 'none';
            if (statusText) statusText.textContent = "Ready!";
            
            // Show continue button if autoClose is false AND no options are shown
            const hasOptions = document.getElementById('intervention-options');
            if (!botSpeakingQueue.autoClose && continueBtn && !hasOptions) {
                continueBtn.classList.add('show');
            }
            
            // Call callback if provided
            if (botSpeakingQueue.currentCallback) {
                botSpeakingQueue.currentCallback();
                botSpeakingQueue.currentCallback = null;
            }
            
            // Mark as not speaking
            botSpeakingQueue.isSpeaking = false;
            botSpeakingQueue.currentUtterance = null;
            
            // Auto hide if enabled and no options
            if (botSpeakingQueue.autoClose && !hasOptions) {
                setTimeout(() => {
                    if (!botSpeakingQueue.isSpeaking) {
                        hideSpeakingBot();
                    }
                }, 1000);
            }
            
            // Process next in queue
            setTimeout(processSpeakingQueue, 500);
        }

        // Stop current speaking
        function stopBotSpeaking() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            if (botSpeakingQueue.currentUtterance) {
                speechSynthesis.cancel();
                botSpeakingQueue.currentUtterance = null;
            }
            
            botSpeakingQueue.isSpeaking = false;
        }

        // Animate volume bar during speech
        function animateVoiceWaves() {
            const voiceBars = document.querySelectorAll('.voice-wave-bar');
            if (!voiceBars.length) return;
            
            let animationInterval = setInterval(() => {
                if (!botSpeakingQueue.isSpeaking) {
                    clearInterval(animationInterval);
                    resetVoiceWaves();
                    return;
                }
                
                // Animate each bar with random heights
                voiceBars.forEach((bar, index) => {
                    const delay = index * 0.1;
                    const height = 10 + Math.random() * 20;
                    
                    setTimeout(() => {
                        bar.style.height = `${height}px`;
                        bar.style.opacity = 0.5 + Math.random() * 0.5;
                    }, delay * 100);
                });
                
            }, 200);
        }

        // Reset voice waves to initial state
        function resetVoiceWaves() {
            const voiceBars = document.querySelectorAll('.voice-wave-bar');
            voiceBars.forEach(bar => {
                bar.style.height = '10px';
                bar.style.opacity = '0.5';
            });
        }

        // Get appropriate status text based on type
        function getStatusText(type) {
            switch(type) {
                case 'welcome': return "Welcoming you...";
                case 'greeting': return "How can I help?";
                case 'intervention': return "Offering help...";
                case 'encouragement': return "Cheering you on!";
                case 'correction': return "Helping out...";
                case 'break': return "Suggesting a break...";
                case 'complete': return "Celebrating!";
                default: return "Speaking...";
            }
        }

        // Show message indicator on side bubble
        function showBotMessageIndicator() {
            const sideBubble = document.getElementById('side-speaking-bot');
            const indicator = document.getElementById('bot-message-indicator');
            
            if (sideBubble && indicator) {
                sideBubble.classList.add('has-message');
                indicator.style.display = 'block';
            }
        }

        // Hide message indicator
        function hideBotMessageIndicator() {
            const sideBubble = document.getElementById('side-speaking-bot');
            const indicator = document.getElementById('bot-message-indicator');
            
            if (sideBubble && indicator) {
                sideBubble.classList.remove('has-message');
                indicator.style.display = 'none';
            }
        }

        // ============================================
        // HELPER FUNCTIONS TO USE THE SPEAKING BOT
        // ============================================

        // Welcome message (after login)
        function speakWelcomeMessage() {
            const message = botPhrases.welcome[Math.floor(Math.random() * botPhrases.welcome.length)];
            queueBotMessage(message, {
                type: 'welcome',
                autoClose: true,
                onComplete: function() {
                    // Show regular Mickey agent after welcome
                    setTimeout(() => {
                        // You can add back your Mickey agent here if needed
                    }, 500);
                }
            });
        }

        // Greeting message (when clicking the bot)
        function speakBotGreeting() {
            const message = botPhrases.greeting[Math.floor(Math.random() * botPhrases.greeting.length)];
            queueBotMessage(message, {
                type: 'greeting',
                autoClose: false,
                onComplete: function() {
                    // After greeting, the bot stays open for user to respond
                }
            });
        }

        // Intervention message (when frustrated/confused)
        function speakIntervention(emotion = 'frustrated') {
            const messages = botPhrases.intervention[emotion] || botPhrases.intervention.frustrated;
            const message = messages[Math.floor(Math.random() * messages.length)];
            
            queueBotMessage(message, {
                type: 'intervention',
                autoClose: false,
                onComplete: function() {
                    // Keep bot open for user response
                }
            });
        }

        // Encouragement message
        function speakEncouragement() {
            const message = botPhrases.encouragement[Math.floor(Math.random() * botPhrases.encouragement.length)];
            queueBotMessage(message, {
                type: 'encouragement',
                autoClose: true
            });
        }

        // Game completion
        function speakGameComplete() {
            const message = botPhrases.gameComplete[Math.floor(Math.random() * botPhrases.gameComplete.length)];
            queueBotMessage(message, {
                type: 'complete',
                autoClose: true
            });
        }

        // ============================================
        // TRACING ENGINE
        // ============================================

        class LetterTracingEngine {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.points = [];
                this.targetPath = [];
                this.currentLetter = '';
                this.tolerance = 20;
                this.score = 0;
                this.maxScore = 100;
            }
            
            initialize(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                this.setupEventListeners();
                this.setupDrawingStyle();
                
                // Mobile optimization
                if ('ontouchstart' in window) {
                    this.tolerance = 30;
                }
            }
            
            setupDrawingStyle() {
                this.ctx.lineWidth = 8;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#ff6b8b';
                this.ctx.fillStyle = '#ff6b8b';
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.draw.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseout', this.stopDrawing.bind(this));
                
                // Touch events
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.canvas.addEventListener('touchend', this.stopDrawing.bind(this));
                
                // Prevent scrolling on touch
                this.canvas.addEventListener('touchmove', (e) => {
                    if (e.scale !== 1) { e.preventDefault(); }
                }, { passive: false });
            }
            
            startDrawing(e) {
                this.isDrawing = true;
                const pos = this.getMousePos(e);
                [this.lastX, this.lastY] = [pos.x, pos.y];
                this.points.push({x: pos.x, y: pos.y});
                this.playSound('start');
            }
            
            draw(e) {
                if (!this.isDrawing) return;
                
                e.preventDefault();
                const pos = this.getMousePos(e);
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.lastX, this.lastY);
                this.ctx.lineTo(pos.x, pos.y);
                this.ctx.stroke();
                
                this.points.push({x: pos.x, y: pos.y});
                [this.lastX, this.lastY] = [pos.x, pos.y];
            }
            
            stopDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                this.analyzeTrace();
                this.playSound('end');
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let x, y;
                
                if (e.type.includes('touch')) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: x * scaleX,
                    y: y * scaleY
                };
            }
            
            setTargetLetter(letter, strokePath) {
                this.currentLetter = letter;
                this.targetPath = strokePath;
                this.drawGuideLines();
                this.placeStartDot();
            }
            
            drawGuideLines() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                this.ctx.strokeStyle = '#CCCCCC';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.lineCap = 'round';
                
                if (this.targetPath.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.targetPath[0].x, this.targetPath[0].y);
                    
                    for (let i = 1; i < this.targetPath.length; i++) {
                        this.ctx.lineTo(this.targetPath[i].x, this.targetPath[i].y);
                    }
                    
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            placeStartDot() {
                if (this.targetPath.length > 0) {
                    const startDot = document.querySelector('.start-dot');
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const scaleX = canvasRect.width / this.canvas.width;
                    const scaleY = canvasRect.height / this.canvas.height;
                    
                    startDot.style.left = (this.targetPath[0].x * scaleX) + 'px';
                    startDot.style.top = (this.targetPath[0].y * scaleY) + 'px';
                }
            }
            
            analyzeTrace() {
                if (this.points.length < 2 || this.targetPath.length < 2) {
                    this.showFeedback("Try drawing something first!", "needs-improvement");
                    return;
                }
                
                // Use CalculationManager for the accuracy calculation
                const result = calculationManager.calculateTracingAccuracy(
                    this.points,
                    this.targetPath,
                    this.tolerance
                );
                
                this.score = result.accuracy;
                
                document.getElementById('trace-accuracy').textContent = result.accuracy + '%';
                document.getElementById('trace-progress').style.width = result.accuracy + '%';
                
                if (result.accuracy > 80) {
                    this.showFeedback(
                        "Excellent tracing! Perfect letter formation! üéâ",
                        "success"
                    );
                    this.playSound('success');
                    
                    studentScore += result.points; // Use points from calculation
                    document.getElementById('student-points').textContent = studentScore;
                    
                } else if (result.accuracy > 50) {
                    this.showFeedback(
                        "Good effort! Try to stay closer to the guide lines.",
                        "needs-improvement"
                    );
                } else {
                    this.showFeedback(
                        "Let's try again. Start from the green dot and follow the dotted line.",
                        "needs-improvement"
                    );
                }
                
                this.points = [];
            }

            showFeedback(message, type) {
                const feedback = document.getElementById('tracing-feedback');
                feedback.textContent = message;
                feedback.className = `tracing-feedback show ${type}`;
                
                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 3000);
            }
            
            playSound(type) {
                const sounds = {
                    start: 'https://assets.mixkit.co/sfx/preview/mixkit-pencil-writing-2444.mp3',
                    end: 'https://assets.mixkit.co/sfx/preview/mixkit-pencil-scribble-on-paper-2426.mp3',
                    success: 'https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3'
                };
                
                if (sounds[type]) {
                    const audio = new Audio(sounds[type]);
                    audio.volume = 0.3;
                    audio.play();
                }
            }
            
            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGuideLines();
                this.points = [];
                this.score = 0;
                
                document.getElementById('trace-accuracy').textContent = '0%';
                document.getElementById('trace-progress').style.width = '0%';
                
                const feedback = document.getElementById('tracing-feedback');
                feedback.classList.remove('show');
            }
            
            showDemo() {
                this.clearCanvas();
                
                this.ctx.save();
                this.ctx.strokeStyle = '#95e1d3';
                this.ctx.lineWidth = 6;
                this.ctx.lineCap = 'round';
                
                let i = 0;
                const animate = () => {
                    if (i < this.targetPath.length - 1) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.targetPath[i].x, this.targetPath[i].y);
                        this.ctx.lineTo(this.targetPath[i + 1].x, this.targetPath[i + 1].y);
                        this.ctx.stroke();
                        i++;
                        setTimeout(animate, 200);
                    }
                };
                
                animate();
                this.ctx.restore();
            }
        }

        const tracingEngine = new LetterTracingEngine();

        // ============================================
        // SIDE TOGGLE SYSTEM
        // ============================================

        function initSideToggle() {
            const sideToggle = document.getElementById('side-toggle');
            const sideBubbles = document.getElementById('side-bubbles');
            
            if (!sideToggle || !sideBubbles) {
                console.warn("Side toggle elements not found, skipping initialization");
                return;
            }
            
            let sideOpen = false;
            
            sideToggle.addEventListener('click', function(event) {
                event.stopPropagation();
                sideOpen = !sideOpen;
                
                if (sideOpen) {
                    sideBubbles.classList.add('show');
                    sideToggle.innerHTML = '<i class="fas fa-times"></i>';
                    sideToggle.style.background = 'var(--mickey-blue)';
                } else {
                    sideBubbles.classList.remove('show');
                    sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                    sideToggle.style.background = 'var(--mickey-red)';
                }
            });
            
            // Initialize bubble handlers
            initBubbleHandlers();
            
            document.addEventListener('click', function(event) {
                if (!event.target.closest('#side-collapsible') && sideOpen) {
                    sideBubbles.classList.remove('show');
                    sideOpen = false;
                    sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                    sideToggle.style.background = 'var(--mickey-red)';
                }
            });
        }

        function initBubbleHandlers() {
            // Emotion camera bubble - VIEW ONLY, no activation
            const emotionBubble = document.getElementById('side-emotion-camera');
            if (emotionBubble) {
                emotionBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    // Just open camera panel to view status
                    openCameraPanel();
                    
                    // Show info message if not active
                    if (dualCameraDetection && !dualCameraDetection.isEmotionRunning) {
                        showNotification(
                            "Auto-Activation",
                            "Emotion detection activates automatically when you start a game! üéÆ",
                            "info"
                        );
                    }
                    
                    closeSideBubbles();
                });
                
                // Add disabled style
                emotionBubble.style.cursor = 'pointer';
                emotionBubble.title = 'View Emotion Detection Status (Auto-activated with games)';
            }
            
            // Eye camera bubble - VIEW ONLY, no activation
            const eyeBubble = document.getElementById('side-eye-camera');
            if (eyeBubble) {
                eyeBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    // Just open camera panel to view status
                    openCameraPanel();
                    
                    // Show info message if not active
                    if (dualCameraDetection && !dualCameraDetection.isEyeTracking) {
                        showNotification(
                            "Auto-Activation",
                            "Eye tracking activates automatically when you start a game! üëÅÔ∏è",
                            "info"
                        );
                    }
                    
                    closeSideBubbles();
                });
                
                // Add disabled style
                eyeBubble.style.cursor = 'pointer';
                eyeBubble.title = 'View Eye Tracking Status (Auto-activated with games)';
            }
            
            // Speaking bot bubble (unchanged - still functional)
            const speakingBotBubble = document.getElementById('side-speaking-bot');
            if (speakingBotBubble) {
                speakingBotBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    handleSpeakingBotClick();
                    closeSideBubbles();
                });
            }
            
            // Close camera content button
            const closeCameraBtn = document.getElementById('close-camera-content');
            if (closeCameraBtn) {
                closeCameraBtn.addEventListener('click', function(event) {
                    event.stopPropagation();
                    closeCameraPanel();
                });
            }
        }

        function openCameraPanel() {
            document.querySelectorAll('.collapsible-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const cameraContent = document.getElementById('camera-content');
            if (cameraContent) {
                cameraContent.classList.add('active');
            }
        }

        function closeCameraPanel() {
            const cameraContent = document.getElementById('camera-content');
            if (cameraContent) {
                cameraContent.classList.remove('active');
            }
        }

        function closeSideBubbles() {
            const sideBubbles = document.getElementById('side-bubbles');
            if (sideBubbles) {
                sideBubbles.classList.remove('show');
            }
            
            const sideToggle = document.getElementById('side-toggle');
            if (sideToggle) {
                sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                sideToggle.style.background = 'var(--mickey-red)';
            }
        }

        // ============================================
        // WELCOME SCREEN FUNCTIONS
        // ============================================

        function showLoginForm() {
            document.getElementById('welcome-buttons').style.display = 'none';
            document.getElementById('register-form-container').style.display = 'none';
            document.getElementById('login-form-container').style.display = 'block';
            
            const formsContainer = document.getElementById('forms-container');
            formsContainer.scrollTop = 0;
        }

        function showRegisterForm() {
            document.getElementById('welcome-buttons').style.display = 'none';
            document.getElementById('login-form-container').style.display = 'none';
            document.getElementById('register-form-container').style.display = 'block';
            
            const formsContainer = document.getElementById('forms-container');
            formsContainer.scrollTop = 0;
        }

        function submitLogin() {
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;
            
            if (!username || !password) {
                alert("Please enter both username and password!");
                return;
            }
            
            if (username === 'student123' && password === 'student123') {
                localStorage.setItem('userRole', 'student');
                localStorage.setItem('username', username);
                
                // Hide welcome screen, show main interface
                document.getElementById('welcome-screen').style.display = 'none';
                document.body.classList.remove('welcome-active');
                
                // Initialize main system
                initMainSystem('student');
                
                
            } else if (username === 'teacher123' && password === 'teacher123') {
                localStorage.setItem('userRole', 'teacher');
                localStorage.setItem('username', username);
                
                // Hide welcome screen, show main interface
                document.getElementById('welcome-screen').style.display = 'none';
                document.body.classList.remove('welcome-active');
                
                // Initialize main system
                initMainSystem('teacher');
                
                // Speak welcome message
                setTimeout(() => {
                    speakText("Welcome back! Ready for some teaching fun?");
                }, 300);
                
            } else {
                alert("Invalid username or password!\n\nTry:\nStudent: student123 / student123\nTeacher: teacher123 / teacher123");
            }
        }

        function submitRegistration() {
            const name = document.getElementById('register-name').value;
            const username = document.getElementById('register-username').value;
            const password = document.getElementById('register-password').value;
            const role = document.getElementById('register-role').value;
            
            if (!name || !username || !password) {
                alert("Please fill in all required fields!");
                return;
            }
            
            if (password.length < 6) {
                alert("Password must be at least 6 characters!");
                return;
            }
            
            localStorage.setItem('userRole', role);
            localStorage.setItem('username', username);
            localStorage.setItem('userName', name);
            
            // Hide welcome screen, show main interface
            document.getElementById('welcome-screen').style.display = 'none';
            document.body.classList.remove('welcome-active');
            
            // Initialize main system
            initMainSystem(role);
            
            // Speak welcome message
            setTimeout(() => {
                speakText(`Welcome ${name}! Ready to start learning?`);
            }, 300);
        }

        // ============================================
        // MAIN SYSTEM INITIALIZATION
        // ============================================

        function initializeAll() {
            console.log("üé™ Initializing Mickey's Enhanced Learning Hub...");
            
            // Show welcome screen with buttons only
            document.body.classList.add('welcome-active');
            document.getElementById('welcome-screen').style.display = 'flex';
            
            // Setup button click handlers
            document.getElementById('show-login-btn').addEventListener('click', showLoginForm);
            document.getElementById('show-register-btn').addEventListener('click', showRegisterForm);
            
            console.log("‚úÖ System ready - showing buttons only!");
        }

        function initMainSystem(role) {

            calculationManager = new CalculationManager();

            initHeaderNavigation();
            initSideToggle();
            initAccessibilityFunctions();
            initGameFunctions();
            initTabFocusTracking();
            monitorCalculationPerformance();
            startPerformanceMonitoring();

            // Start checking focus
            setInterval(() => {
                if (tabTracker) {
                    updateFocusDisplayInProfile();
                }
            }, 5000);

            // Initialize dual camera detection
            if (typeof Human !== 'undefined') {
                dualCameraDetection = new DualCameraDetection();
            } else {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/human.js';
                script.onload = function() {
                    dualCameraDetection = new DualCameraDetection();
                    console.log('‚úÖ Dual camera detection initialized with Human.js');
                };
                document.head.appendChild(script);
            }
            
            // Initialize speaking bot
            initSpeakingBot();
            
            if (role === 'teacher') {
                switchContent('profile');
                setActiveNavTab('profile-tab');
            } else {
                switchContent('game-center');
                setActiveNavTab('game-tab');
            }
        }

        // ============================================
        // HEADER NAVIGATION
        // ============================================

        function initHeaderNavigation() {
            // Game Center tab
            document.getElementById('game-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('game-center');
                setActiveNavTab('game-tab');
            });
            
            // Profile tab
            document.getElementById('profile-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('profile');
                setActiveNavTab('profile-tab');
                updateProfileDisplay();
            });
            
            // About Us tab
            document.getElementById('about-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('about');
                setActiveNavTab('about-tab');
            });
            
            // Settings tab
            document.getElementById('settings-tab').addEventListener('click', function(e) {
                e.preventDefault();
                switchContent('settings');
                setActiveNavTab('settings-tab');
                updateSettingsDisplay();
            });
        }

        function setActiveNavTab(tabId) {
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const activeTab = document.getElementById(tabId);
            if (activeTab) {
                activeTab.classList.add('active');
            }
        }

        function switchContent(contentType) {
            document.querySelectorAll('.content-area').forEach(area => {
                area.classList.remove('active');
            });
            
            // Hide tracing container if showing
            document.getElementById('tracing-game-container').style.display = 'none';
            
            const targetArea = document.getElementById(`${contentType}-content-area`);
            if (targetArea) {
                targetArea.classList.add('active');
            }
            
            const moduleContent = document.getElementById('module-content');
            if (moduleContent) {
                moduleContent.classList.remove('active');
            }
        }

        // ============================================
        // ACCESSIBILITY FUNCTIONS
        // ============================================

        function initAccessibilityFunctions() {
            // Dyslexia mode (unchanged)
            const settingsDyslexiaBtn = document.getElementById('toggle-dyslexia');
            if (settingsDyslexiaBtn) {
                settingsDyslexiaBtn.addEventListener('click', function() {
                    toggleDyslexiaMode();
                    this.innerHTML = `<i class="fas fa-toggle-${document.body.classList.contains('dyslexia-mode') ? 'on' : 'off'}"></i> Dyslexia Mode ${document.body.classList.contains('dyslexia-mode') ? 'ON' : 'OFF'}`;
                });
            }
        }

        function toggleDyslexiaMode() {
            document.body.classList.toggle('dyslexia-mode');
            showNotification("Dyslexia Mode", 
                document.body.classList.contains('dyslexia-mode') ? 
                "Dyslexia-friendly font enabled! üìö" : 
                "Dyslexia-friendly font disabled.", 
                "info");
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================

        function initGameFunctions() {
            // Close module
            const closeModuleBtn = document.getElementById('close-module');
            if (closeModuleBtn) {
                closeModuleBtn.addEventListener('click', closeModule);
            }
        }

        function startGame(gameName) {
            console.log(`üéÆ Starting game: ${gameName}`);
            
            // Force hide everything else first
            document.querySelectorAll('.content-area').forEach(area => {
                area.style.display = 'none';
                area.classList.remove('active');
            });
            
            // Hide tracing container
            const tracingContainer = document.getElementById('tracing-game-container');
            if (tracingContainer) {
                tracingContainer.style.display = 'none';
            }
            
            currentGame = gameName;
            const game = learningGames[gameName];
            currentActivityIndex = 0;
            frustrationLevel = 0;
            
            if (gameName === 'tracing') {
                startTracingGame();
            } else {
                // Get the module content
                const moduleContent = document.getElementById('module-content');
                const moduleTitle = document.getElementById('module-content-title');
                const moduleBody = document.getElementById('module-content-body');
                
                if (!moduleContent) {
                    console.error('‚ùå Module content element not found!');
                    alert('Game area not found. Please refresh the page.');
                    return;
                }
                
                // Force show the module
                moduleContent.style.display = 'block';
                moduleContent.style.opacity = '1';
                moduleContent.style.visibility = 'visible';
                moduleContent.style.position = 'relative';
                moduleContent.style.zIndex = '1000';
                moduleContent.classList.add('active');
                
                // Hide the main game center
                const gameCenter = document.getElementById('game-center-content-area');
                if (gameCenter) {
                    gameCenter.style.display = 'none';
                    gameCenter.classList.remove('active');
                }
                
                // Set content
                if (moduleTitle) {
                    moduleTitle.textContent = game.title;
                }
                
                if (moduleBody) {
                    moduleBody.innerHTML = generateGameActivity(gameName, 0);
                }
                
                // Scroll to make sure it's visible
                setTimeout(() => {
                    moduleContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }
            
            // ‚úÖ AUTO-START BOTH DETECTION SYSTEMS (EMOTION + EYE TRACKING)
            if (dualCameraDetection) {
                dualCameraDetection.autoStartBothDetectionsForGame();
            }
            
            console.log(`‚úÖ Game "${game.title}" started successfully`);
        } 
            
        function startTracingGame() {       
            const game = learningGames.tracing;
            currentActivityIndex = 0;
            
            // Hide main content, show tracing container
            document.getElementById('game-center-content-area').classList.remove('active');
            document.getElementById('tracing-game-container').style.display = 'block';
            
            loadTracingActivity(0);
            
            // AUTO-START BOTH DETECTION SYSTEMS WHEN TRACING STARTS
            if (dualCameraDetection) {
                dualCameraDetection.autoStartDetectionForGame();
            }
            
            queueBotMessage("Let's trace some letters! I'll monitor your focus and emotions to help you learn!");
        }

        function loadTracingActivity(activityIndex) {
            const game = learningGames.tracing;
            const activity = game.activities[activityIndex];
            
            document.getElementById('target-letter').textContent = activity.letter;
            document.getElementById('tracing-counter').textContent = `Activity ${activityIndex + 1} of ${game.activities.length}`;
            
            // Update navigation buttons
            document.getElementById('prev-tracing').disabled = activityIndex === 0;
            document.getElementById('next-tracing').disabled = activityIndex === game.activities.length - 1;
            
            // Initialize tracing engine
            setTimeout(() => {
                tracingEngine.initialize('tracing-canvas');
                tracingEngine.setTargetLetter(activity.letter, activity.strokeOrder);
            }, 100);
            
            // Setup controls
            document.getElementById('clear-trace').onclick = () => tracingEngine.clearCanvas();
            document.getElementById('check-trace').onclick = () => tracingEngine.analyzeTrace();
            document.getElementById('auto-trace').onclick = () => tracingEngine.showDemo();
            document.getElementById('hint-trace').onclick = () => {
                tracingEngine.showFeedback(activity.hint || "Start from the green dot and follow the path", "needs-improvement");
            };
            
            // Play sound button
            document.getElementById('play-sound-btn').onclick = () => {
                speakText(`The letter ${activity.letter}`);
            };
        }

        function prevTracingActivity() {
            if (currentActivityIndex > 0) {
                currentActivityIndex--;
                loadTracingActivity(currentActivityIndex);
                frustrationLevel = 0;
            }
        }

        function nextTracingActivity() {
            const game = learningGames.tracing;
            if (currentActivityIndex < game.activities.length - 1) {
                currentActivityIndex++;
                loadTracingActivity(currentActivityIndex);
                frustrationLevel = 0;
            } else {
                completeGame('tracing');
            }
        }

        function viewModule(moduleName) {
            const game = learningGames[moduleName];
            document.getElementById('module-content-title').textContent = `${game.title} - Information`;
            document.getElementById('module-content-body').innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 4rem; color: var(--mickey-yellow); margin-bottom: 20px;">
                        <i class="fas fa-info-circle"></i>
                    </div>
                    <h3 style="color: var(--mickey-blue);">${game.description}</h3>
                    <div style="background: var(--mickey-white); padding: 25px; border-radius: 20px; border: 4px solid var(--mickey-black); margin: 30px auto; max-width: 600px;">
                        <h4 style="color: var(--mickey-red);">Enhanced Features:</h4>
                        <ul style="text-align: left; color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.1rem;">
                            <li>‚úÖ <strong>Real-time emotion detection</strong></li>
                            <li>‚úÖ <strong>Eye tracking focus analysis</strong></li>
                            <li>‚úÖ <strong>Dyslexia-friendly design</strong></li>
                            <li>‚úÖ <strong>Proactive Mickey interventions</strong></li>
                        </ul>
                    </div>
                    <div style="margin-top: 30px;">
                        <button class="module-btn start-btn" onclick="startGame('${moduleName}')" 
                                style="padding: 15px 30px; font-size: 1.2rem;">
                            <i class="fas fa-play"></i> Play Game Now!
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('module-content').classList.add('active');
        }

function generateGameActivity(gameName, activityIndex) {
    const game = learningGames[gameName];
    const activity = game.activities[activityIndex];
    
    let contentHTML = '';
    
    if (activity.type === "letter_recognition" || activity.type === "vowel_identification" || 
        activity.type === "consonant_identification" || activity.type === "letter_sequence") {
        
        const questionText = activity.question || "Identify the correct answer:";
        const optionsList = activity.options || ["Option 1", "Option 2", "Option 3", "Option 4"];
        
        contentHTML = `
            <div class="game-container">
                <div class="game-counter">
                    Activity ${activityIndex + 1} of ${game.activities.length}
                </div>
                
                <!-- DYSLEXIA SUPPORT HEADER -->
                <div class="dyslexia-support-header" style="background: #e6f7ff; padding: 15px; border-radius: 15px; border: 3px solid var(--mickey-blue); margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 10px; color: var(--mickey-blue);">
                        <i class="fas fa-lightbulb"></i>
                        <strong>Dyslexia Tips for this activity:</strong>
                    </div>
                    <ul style="margin: 10px 0 0 20px; color: var(--mickey-black); font-family: 'OpenDyslexic', sans-serif; font-size: 0.9em;">
                        ${game.dyslexia_tips.map(tip => `<li>${tip}</li>`).join('')}
                    </ul>
                </div>
                
                <div class="game-question">
                    <i class="fas fa-question-circle" style="color: var(--mickey-red); margin-right: 10px;"></i>
                    ${questionText}
                    
                    ${activity.letter ? `
                        <div style="margin-top: 15px; font-size: 5rem; text-align: center; color: var(--mickey-red);">
                            ${activity.letter}
                        </div>
                    ` : ''}
                </div>
                
                <div class="game-options">
                    ${optionsList.map((option, index) => `
                        <div class="game-option" onclick="checkAnswer(${index}, '${gameName}')">
                            ${option}
                        </div>
                    `).join('')}
                </div>
                
                <div class="game-feedback" id="game-feedback"></div>
                <div class="game-progress">
                    <div class="progress-bar" id="game-progress" 
                        style="width: ${((activityIndex + 1) / game.activities.length) * 100}%"></div>
                    <div class="progress-text">
                        ${activityIndex + 1} of ${game.activities.length} activities completed
                    </div>
                </div>
                <div class="game-navigation">
                    <button class="nav-btn" ${activityIndex === 0 ? 'disabled' : ''} 
                            onclick="previousActivity('${gameName}')">
                        <i class="fas fa-arrow-left"></i> Previous
                    </button>
                    <button class="nav-btn" onclick="nextActivity('${gameName}')" 
                            ${activityIndex === game.activities.length - 1 ? 'disabled' : ''}>
                        Next <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>
        `;
    }
    
    return contentHTML;
}
function checkAnswer(answerIndex, gameName) {
    const game = learningGames[gameName];
    const activity = game.activities[currentActivityIndex];
    const feedback = document.getElementById('game-feedback');
    const options = document.querySelectorAll('.game-option');
    
    options.forEach(opt => {
        opt.classList.remove('correct', 'wrong');
    });
    
    if (answerIndex === activity.correct) {
        // Correct answer
        options[answerIndex].classList.add('correct');
        
        feedback.innerHTML = `
            <div style="display: flex; align-items: center; gap: 15px;">
                <i class="fas fa-check-circle" style="color: var(--mickey-green); font-size: 2rem;"></i>
                <div>
                    <strong style="color: var(--mickey-green); font-family: 'OpenDyslexic', sans-serif;">Oh boy! Correct!</strong>
                    <p style="margin: 5px 0; color: var(--mickey-white); font-family: 'OpenDyslexic', sans-serif;">${activity.explanation}</p>
                    <p style="margin: 5px 0; color: var(--mickey-yellow);">
                        <i class="fas fa-star"></i> +${activity.points} Mickey Points!
                    </p>
                </div>
            </div>
        `;
        
        // Award points
        studentScore += activity.points;
        document.getElementById('student-points').textContent = studentScore;
        
        // Positive emotional feedback
        if (dualCameraDetection) {
            dualCameraDetection.studentEmotion = "happy";
            dualCameraDetection.emotionInterventionData.negativeEmotionCount = 0;
        }
        frustrationLevel = 0;
        
        // Play correct audio
        speakEncouragement();
        
        // Auto-advance
        setTimeout(() => {
            if (currentActivityIndex < game.activities.length - 1) {
                nextActivity(gameName);
            } else {
                completeGame(gameName);
            }
        }, 2500);
        
    } else {
        // Wrong answer
        options[answerIndex].classList.add('wrong');
        options[activity.correct].classList.add('correct');
        
        feedback.innerHTML = `
            <div style="display: flex; align-items: center; gap: 15px;">
                <i class="fas fa-times-circle" style="color: var(--mickey-red); font-size: 2rem;"></i>
                <div>
                    <strong style="color: var(--mickey-red); font-family: 'OpenDyslexic', sans-serif;">Let's try again!</strong>
                    <p style="margin: 5px 0; color: var(--mickey-white); font-family: 'OpenDyslexic', sans-serif;">
                        The correct answer is: ${activity.options[activity.correct]}
                    </p>
                </div>
            </div>
        `;
        
        // Play incorrect audio
        queueBotMessage("That's okay! Let's try again.", { type: 'correction' });
        
        // Negative emotional feedback
        if (dualCameraDetection) {
            dualCameraDetection.studentEmotion = "confused";
            dualCameraDetection.emotionInterventionData.negativeEmotionCount++;
        }
        
        frustrationLevel++;
        
        // Check for intervention (both emotion and frustration)
        if (frustrationLevel >= FRUSTRATION_THRESHOLD) {
            if (dualCameraDetection) {
                dualCameraDetection.triggerEmotionIntervention("frustrated");
            } else {
                // Fallback if detection not available
                queueBotMessage("This seems tricky. Would you like some help?", {
                    type: 'intervention',
                    autoClose: false
                });
            }
            frustrationLevel = 0;
        }
    }
    
    feedback.classList.add('show');
}
        function nextActivity(gameName) {
            if (currentActivityIndex < learningGames[gameName].activities.length - 1) {
                currentActivityIndex++;
                document.getElementById('module-content-body').innerHTML = generateGameActivity(gameName, currentActivityIndex);
                frustrationLevel = 0;
                
                // Ensure eye tracking is still active
                if (dualCameraDetection && !dualCameraDetection.isEyeTracking) {
                    dualCameraDetection.startEyeDetection();
                }
            }
        }

        function previousActivity(gameName) {
            if (currentActivityIndex > 0) {
                currentActivityIndex--;
                document.getElementById('module-content-body').innerHTML = generateGameActivity(gameName, currentActivityIndex);
                frustrationLevel = 0;
                
                // Ensure eye tracking is still active
                if (dualCameraDetection && !dualCameraDetection.isEyeTracking) {
                    dualCameraDetection.startEyeDetection();
                }
            }
        }

function completeGame(gameName) {
    const game = learningGames[gameName];
    game.completed = true;
    
    // Speak game completion message
    speakGameComplete();
    
    const totalPoints = game.activities.reduce((sum, activity) => sum + (activity.points || 0), 0);
    
    // Show completion screen
    setTimeout(() => {
        if (gameName === 'tracing') {
            document.getElementById('tracing-game-container').innerHTML = `
                <div style="text-align: center; padding: 60px 40px;">
                    <div style="font-size: 6rem; color: var(--mickey-yellow); margin-bottom: 30px;">
                        <i class="fas fa-trophy"></i>
                    </div>
                    <h2 style="color: var(--mickey-red);">Tracing Master!</h2>
                    <p style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive; font-size: 1.3rem;">
                        You've mastered letter tracing!
                    </p>
                    <div style="background: var(--mickey-yellow); padding: 25px; border-radius: 20px; 
                                border: 4px solid var(--mickey-black); margin: 30px auto; max-width: 400px;">
                        <h3 style="color: var(--mickey-black); margin: 0 0 15px 0;">
                            <i class="fas fa-star"></i> You earned ${totalPoints} Mickey Points!
                        </h3>
                        <p style="color: var(--mickey-red); font-size: 1.2rem;">
                            Total Score: <strong>${studentScore}</strong> points
                        </p>
                    </div>
                    <button class="module-btn start-btn" onclick="closeTracingGame()" style="padding: 15px 30px;">
                        <i class="fas fa-check"></i> Great Job! Back to Games
                    </button>
                </div>
            `;
        } else {
            document.getElementById('module-content-body').innerHTML = `
                <div style="text-align: center; padding: 60px 40px;">
                    <div style="font-size: 6rem; color: var(--mickey-yellow); margin-bottom: 30px;">
                        <i class="fas fa-trophy"></i>
                    </div>
                    <h2 style="color: var(--mickey-red);">Congratulations!</h2>
                    <p style="color: var(--mickey-blue); font-family: 'Comic Neue', cursive; font-size: 1.3rem;">
                        You've completed ${game.title}!
                    </p>
                    <div style="background: var(--mickey-yellow); padding: 25px; border-radius: 20px; 
                                border: 4px solid var(--mickey-black); margin: 30px auto; max-width: 400px;">
                        <h3 style="color: var(--mickey-black); margin: 0 0 15px 0;">
                            <i class="fas fa-star"></i> You earned ${totalPoints} Mickey Points!
                        </h3>
                        <p style="color: var(--mickey-red); font-size: 1.2rem;">
                            Total Score: <strong>${studentScore}</strong> points
                        </p>
                    </div>
                    <button class="module-btn start-btn" onclick="closeModule()" style="padding: 15px 30px;">
                        <i class="fas fa-check"></i> Great Job! Play Another Game
                    </button>
                </div>
            `;
        }
        
        // ‚úÖ AUTO-STOP BOTH DETECTION SYSTEMS WHEN GAME COMPLETES
        if (dualCameraDetection) {
            dualCameraDetection.autoStopBothDetectionsAfterGame();
        }
        
        // Update progress
        updateProfileDisplay();
    }, 2000);
}

function closeTracingGame() {
    document.getElementById('tracing-game-container').style.display = 'none';
    document.getElementById('game-center-content-area').classList.add('active');
    
    // ‚úÖ AUTO-STOP BOTH DETECTION SYSTEMS
    if (dualCameraDetection) {
        dualCameraDetection.autoStopBothDetectionsAfterGame();
    }
    
    closeModule();
}

function closeModule() {
    frustrationLevel = 0;
    studentEmotion = 'neutral';
    
    // ‚úÖ AUTO-STOP BOTH DETECTION SYSTEMS WHEN LEAVING GAME
    if (dualCameraDetection && currentGame) {
        dualCameraDetection.autoStopBothDetectionsAfterGame();
    }
    
    const moduleContent = document.getElementById('module-content');
    if (moduleContent) {
        moduleContent.style.display = 'none';
        moduleContent.classList.remove('active');
    }
    
    const gameCenter = document.getElementById('game-center-content-area');
    if (gameCenter) {
        gameCenter.style.display = 'block';
        gameCenter.classList.add('active');
    }
    
    // Show other areas
    document.querySelectorAll('.content-area').forEach(area => {
        area.style.display = '';
    });
    
    currentGame = null;
}

// ============================================
        // MICKEY AGENT FUNCTIONS
        // ============================================
        function startMickeyBreak() {
            const breakTimer = document.createElement('div');
            breakTimer.id = 'break-timer';
            breakTimer.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 400px;
                background: var(--mickey-white);
                border-radius: 25px;
                border: 5px solid var(--mickey-black);
                box-shadow: 0 15px 0 var(--mickey-black), 0 25px 50px rgba(0,0,0,0.3);
                z-index: 10001;
                overflow: hidden;
                animation: interventionPop 0.5s;
            `;
            
            breakTimer.innerHTML = `
                <div style="background: linear-gradient(145deg, var(--mickey-pink), var(--mickey-red)); padding: 25px; text-align: center; color: var(--mickey-white);">
                    <h2 style="margin: 0; color: var(--mickey-white);">
                        <i class="fas fa-clock"></i> Break Time!
                    </h2>
                    <p style="margin: 10px 0 0 0; color: var(--mickey-yellow); font-family: 'Comic Neue', cursive;">
                        Take a deep breath and relax
                    </p>
                </div>
                <div style="padding: 30px; text-align: center;">
                    <div class="timer-display" id="timer-display" style="font-size: 4rem; color: var(--mickey-red); margin: 20px 0; font-family: 'Fredoka One', cursive; text-align: center;">00:30</div>
                    <h3 style="color: var(--mickey-blue); margin-bottom: 10px;">
                        Mickey says: "Take a break!"
                    </h3>
                    <p style="color: var(--mickey-black); font-family: 'Comic Neue', cursive; font-size: 1.1rem;">
                        Stretch, take deep breaths, and come back refreshed!
                    </p>
                    
                    <div id="breathing-animation" style="background: var(--mickey-yellow); padding: 20px; border-radius: 15px; border: 3px solid var(--mickey-black); margin: 20px 0; text-align: center; font-size: 1.2rem; color: var(--mickey-red);">
                        Breathe IN... (4 seconds)
                    </div>
                    
                    <button class="module-btn start-btn" onclick="endMickeyBreak()" style="margin-top: 20px;">
                        <i class="fas fa-play"></i> End Break Early
                    </button>
                </div>
            `;
            
            document.body.appendChild(breakTimer);
            
            breakTimerActive = true;
            breakTimeLeft = 30;
            updateBreakTimer();
            
            breakInterval = setInterval(() => {
                breakTimeLeft--;
                updateBreakTimer();
                
                if (breakTimeLeft <= 0) {
                    endMickeyBreak();
                }
            }, 1000);
            
            startBreathingAnimation();
            
            speakText("Time for a quick break! Let's stretch and come back refreshed!");
        }

        function updateBreakTimer() {
            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                const minutes = Math.floor(breakTimeLeft / 60);
                const seconds = breakTimeLeft % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function startBreathingAnimation() {
            const breathingText = document.getElementById('breathing-animation');
            if (!breathingText) return;
            
            let phase = 'in';
            let count = 4;
            
            clearInterval(breathingInterval);
            
            breathingInterval = setInterval(() => {
                if (count === 0) {
                    phase = phase === 'in' ? 'hold' : phase === 'hold' ? 'out' : 'in';
                    count = phase === 'in' ? 4 : phase === 'hold' ? 4 : 6;
                }
                
                let text = '';
                let emoji = '';
                
                switch(phase) {
                    case 'in':
                        text = `Breathe IN... (${count} seconds)`;
                        emoji = '‚¨ÜÔ∏è';
                        break;
                    case 'hold':
                        text = `Hold... (${count} seconds)`;
                        emoji = '‚è∏Ô∏è';
                        break;
                    case 'out':
                        text = `Breathe OUT... (${count} seconds)`;
                        emoji = '‚¨áÔ∏è';
                        break;
                }
                
                breathingText.innerHTML = `${emoji} ${text}`;
                count--;
                
                if (!breakTimerActive) {
                    clearInterval(breathingInterval);
                }
            }, 1000);
        }

        function endMickeyBreak() {
            breakTimerActive = false;
            clearInterval(breakInterval);
            clearInterval(breathingInterval);
            
            const breakTimer = document.getElementById('break-timer');
            if (breakTimer) {
                document.body.removeChild(breakTimer);
            }
            
            speakText("Break time's over! Ready to continue? You're doing great!");
        }

        function makeGameEasier() {
            isEasyMode = true;
            speakText("I'll make the questions easier for you!");
            
            if (currentGame) {
                if (currentGame === 'tracing') {
                    tracingEngine.tolerance = 30;
                    speakText("I've made the tracing more forgiving!");
                } else {
                    document.getElementById('module-content-body').innerHTML = generateGameActivity(currentGame, currentActivityIndex);
                }
            }
        }

        function skipToNext() {
            if (currentGame && currentActivityIndex < learningGames[currentGame].activities.length - 1) {
                currentActivityIndex++;
                
                if (currentGame === 'tracing') {
                    loadTracingActivity(currentActivityIndex);
                } else {
                    document.getElementById('module-content-body').innerHTML = generateGameActivity(currentGame, currentActivityIndex);
                }
                
                frustrationLevel = 0;
                speakText("Let's skip to the next activity!");
            }
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function speakText(text) {
            if ('speechSynthesis' in window && voiceEnabled) {
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1.2;
                utterance.volume = 1;
                
                const voices = speechSynthesis.getVoices();
                const childVoice = voices.find(voice => 
                    voice.name.includes('Child') || 
                    voice.name.includes('Kids') ||
                    voice.lang.includes('en')
                );
                
                if (childVoice) {
                    utterance.voice = childVoice;
                }
                
                speechSynthesis.speak(utterance);
            }
        }

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                right: 30px;
                background: var(--mickey-white);
                color: var(--mickey-black);
                padding: 15px 20px;
                border-radius: 15px;
                border: 3px solid var(--mickey-black);
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                z-index: 10000;
                font-family: 'Comic Neue', cursive;
                max-width: 300px;
                animation: slideInRight 0.3s ease;
            `;
            
            notification.innerHTML = `
                <strong style="color: var(--mickey-red); display: block; margin-bottom: 5px;">${title}</strong>
                <div>${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 5000);
        }

        function updateProfileDisplay() {
            document.getElementById('student-points').textContent = studentScore;
            
            const completedGames = Object.values(learningGames).filter(g => g.completed).length;
            const totalGames = Object.keys(learningGames).length;
            const progressPercent = (completedGames / totalGames) * 100;
            
            document.getElementById('overall-progress').style.width = `${progressPercent}%`;
            document.querySelector('.progress-text').textContent = `${Math.round(progressPercent)}% Complete`;
            
            document.getElementById('games-completed').textContent = `${completedGames}/${totalGames}`;
            
            // Get focus data
            let focusLevel = '75%';
            if (dualCameraDetection) {
                const focusReport = dualCameraDetection.getFocusReport();
                focusLevel = `${focusReport.score}%`;
                
                // Update focus trend if element exists
                updateFocusTrend(focusReport);
            }
            
            document.getElementById('focus-level').textContent = focusLevel;
        }

        function updateFocusTrend(focusReport) {
            const trendElement = document.getElementById('focus-trend-display');
            if (!trendElement) return;
            
            let focusText = '';
            switch(focusReport.level) {
                case 'high':
                    focusText = `<span style="color: #4CAF50">‚óè HIGH Focus (${focusReport.score}%)</span>`;
                    break;
                case 'medium':
                    focusText = `<span style="color: #FFA500">‚óè MEDIUM Focus (${focusReport.score}%)</span>`;
                    break;
                case 'low':
                    focusText = `<span style="color: #f44336">‚óè LOW Focus (${focusReport.score}%)</span>`;
                    break;
                default:
                    focusText = `<span style="color: #999">‚óè Focus: Calculating...</span>`;
            }
            
            trendElement.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="font-size: 2.5rem; color: var(--mickey-blue);">
                        <i class="fas fa-brain"></i>
                    </div>
                    <div>
                        <h5 style="color: var(--mickey-blue); margin: 0 0 5px 0;">Current Focus Level</h5>
                        <div style="color: var(--mickey-black); font-family: 'Comic Neue', cursive;">
                            ${focusText}
                            <div style="font-size: 0.9em; margin-top: 5px; color: var(--mickey-blue);">
                                <i class="fas fa-eye"></i> Eye tracking: ${(focusReport.eyeDistance * 100).toFixed(1)}% from center
                                <br>
                                <i class="fas fa-mouse-pointer"></i> Cursor: ${focusReport.cursorActive ? 'Active' : 'Inactive'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateSettingsDisplay() {
            const isDetectionActive = dualCameraDetection ? 
                (dualCameraDetection.isEmotionRunning || dualCameraDetection.isEyeTracking) : false;
            
            const detectionStatus = document.getElementById('detection-status-text');
            if (detectionStatus) {
                if (dualCameraDetection && dualCameraDetection.isEyeTracking && currentGame) {
                    detectionStatus.textContent = 'AUTO-ACTIVE (In Game)';
                    detectionStatus.style.color = '#95e1d3';
                } else if (isDetectionActive) {
                    detectionStatus.textContent = 'ACTIVE';
                    detectionStatus.style.color = '#95e1d3';
                } else {
                    detectionStatus.textContent = 'INACTIVE';
                    detectionStatus.style.color = '#ff6b8b';
                }
            }
            
            const settingsBtn = document.getElementById('settings-start-camera');
            if (settingsBtn) {
                if (dualCameraDetection && dualCameraDetection.isEmotionRunning) {
                    settingsBtn.innerHTML = '<i class="fas fa-stop-circle"></i> Stop Emotion Detection';
                    settingsBtn.onclick = function() {
                        if (dualCameraDetection) {
                            dualCameraDetection.stopEmotionDetection();
                            // Note: Eye tracking stops automatically when game ends
                        }
                    };
                } else {
                    settingsBtn.innerHTML = '<i class="fas fa-camera"></i> Start Emotion Detection';
                    settingsBtn.onclick = function() {
                        if (dualCameraDetection) {
                            dualCameraDetection.startEmotionDetection();
                        }
                    };
                }
                
                // Add tooltip about eye tracking being auto-only
                settingsBtn.title = "Emotion detection can be manually started. Eye tracking activates automatically with games.";
            }
        }

        function monitorCalculationPerformance() {
 
        // Check performance every 60 seconds
        setInterval(() => {
            const report = calculationManager.getPerformanceReport();
            
            console.log('üìä Calculation Performance Report:', report);
            
            // If calculations are taking too long, log a warning
            if (report.averageTime > 10) { // More than 10ms average
                console.warn('‚ö†Ô∏è Slow calculations detected. Average time:', report.averageTime, 'ms');
                
                // You could trigger optimizations here
                if (report.calculations > 1000) {
                    console.log('üîÑ Clearing calculation cache...');
                    calculationManager.calculationCache = {};
                }
            }
            
            // Update performance display if you have one
            const perfElement = document.getElementById('performance-display');
                if (perfElement) {
                    perfElement.innerHTML = `
                        <div style="font-size: 0.8rem; color: #666;">
                            Calculations: ${report.calculations} | 
                            Avg Time: ${report.averageTime.toFixed(2)}ms
                        </div>
                    `;
                }
            }, 60000); // Every 60 seconds
        }
        function debugGameStart(gameName) {
            console.log('=== DEBUG GAME START ===');
            console.log('Game name:', gameName);
            console.log('Learning games available:', Object.keys(learningGames));
            console.log('Module content element:', document.getElementById('module-content'));
            console.log('Current game state:', currentGame);
            console.log('Dual camera detection:', dualCameraDetection ? 'Loaded' : 'Not loaded');
            console.log('=======================');
        }
        // ============================================
        // INITIALIZE ON LOAD
        // ============================================

        window.addEventListener('load', function() {
            initializeAll();
        });

        // ============================================
        // GLOBAL FUNCTION EXPORTS
        // ============================================

        window.startGame = startGame;
        window.viewModule = viewModule;
        window.checkAnswer = checkAnswer;
        window.nextActivity = nextActivity;
        window.previousActivity = previousActivity;
        window.closeModule = closeModule;
        window.prevTracingActivity = prevTracingActivity;
        window.nextTracingActivity = nextTracingActivity;
        window.startMickeyBreak = startMickeyBreak;
        window.endMickeyBreak = endMickeyBreak;
        window.toggleDyslexiaMode = toggleDyslexiaMode;
        window.dualCameraDetection = dualCameraDetection;
        window.openCameraPanel = openCameraPanel;
        window.closeCameraPanel = closeCameraPanel;

        window.tellAJoke = function() {
            const jokes = [
                "Why did the math book look sad? Because it had too many problems!",
                "What do you call a bear with no teeth? A gummy bear!",
                "Why did the student eat his homework? Because the teacher said it was a piece of cake!",
                "What do you call a dinosaur that is sleeping? A dino-snore!",
                "Why did the computer go to the doctor? Because it had a virus!",
                "What do you get when you cross a snowman and a vampire? Frostbite!",
                "Why don't scientists trust atoms? Because they make up everything!",
                "What do you call a fish with no eyes? Fsh!"
            ];
            
            return jokes[Math.floor(Math.random() * jokes.length)];
        };

        window.switchToDifferentActivity = function() {
            if (currentGame) {
                // Close current game
                closeModule();
                
                // Suggest a different game
                const availableGames = Object.keys(learningGames).filter(game => game !== currentGame);
                if (availableGames.length > 0) {
                    const randomGame = availableGames[Math.floor(Math.random() * availableGames.length)];
                    
                    setTimeout(() => {
                        queueBotMessage(`How about we try ${learningGames[randomGame].title} instead?`, {
                            type: 'suggestion',
                            autoClose: true
                        });
                        
                        setTimeout(() => {
                            startGame(randomGame);
                        }, 1500);
                    }, 500);
                }
            }
        };

        window.explainDifferently = function() {
            if (currentGame && learningGames[currentGame].activities[currentActivityIndex]) {
                const activity = learningGames[currentGame].activities[currentActivityIndex];
                
                let explanation = "";
                if (activity.type === "letter_recognition") {
                    explanation = "Think of this letter like a picture. Look at its shape and try to draw it in the air with your finger!";
                } else if (activity.type === "vowel_identification") {
                    explanation = "Remember, vowels are A, E, I, O, U (and sometimes Y). They're like the 'voice' letters!";
                } else if (activity.type === "word_spelling") {
                    explanation = "Try sounding out each letter slowly. C says 'kuh', A says 'ah', T says 'tuh'... put them together!";
                } else {
                    explanation = "Let's break this down step by step. First, look at the whole picture, then focus on each part.";
                }
                
                queueBotMessage(explanation, {
                    type: 'explanation',
                    autoClose: true
                });
            }
        };

        window.giveHint = function() {
            if (currentGame && learningGames[currentGame].activities[currentActivityIndex]) {
                const activity = learningGames[currentGame].activities[currentActivityIndex];
                
                let hint = "";
                if (activity.type === "letter_recognition" && activity.tactile_feature) {
                    hint = `Hint: This letter feels ${activity.tactile_feature}. Try tracing it with your finger!`;
                } else if (activity.type === "vowel_identification") {
                    hint = "Hint: Only one of these is a vowel. Remember A, E, I, O, U!";
                } else if (activity.type === "word_spelling") {
                    hint = `Hint: The word "${activity.word}" starts with "${activity.word[0]}" and ends with "${activity.word[activity.word.length-1]}".`;
                } else {
                    hint = "Hint: Take your time and look carefully at each option. You can do this!";
                }
                
                queueBotMessage(hint, {
                    type: 'hint',
                    autoClose: true
                });
            }
        };

        window.goBackToBasics = function() {
            if (currentGame && currentActivityIndex > 0) {
                currentActivityIndex = 0;
                
                if (currentGame === 'tracing') {
                    loadTracingActivity(0);
                } else {
                    document.getElementById('module-content-body').innerHTML = generateGameActivity(currentGame, 0);
                }
                
                queueBotMessage("Let's start from the beginning and take it step by step!", {
                    type: 'info',
                    autoClose: true
                });
            }
        };

        window.doQuickStretch = function() {
            // Create a quick stretch animation
            const stretchOverlay = document.createElement('div');
            stretchOverlay.id = 'stretch-overlay';
            stretchOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(149, 225, 211, 0.95);
                z-index: 10010;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                animation: fadeIn 0.3s ease;
            `;
            
            stretchOverlay.innerHTML = `
                <div style="text-align: center; color: var(--mickey-black);">
                    <div style="font-size: 4rem; margin-bottom: 20px;">
                        <i class="fas fa-running"></i>
                    </div>
                    <h2 style="color: var(--mickey-red); margin-bottom: 10px;">Quick Stretch Break!</h2>
                    <p style="font-family: 'Comic Neue', cursive; font-size: 1.2rem; margin-bottom: 30px;">
                        Follow along with Mickey!
                    </p>
                    <div id="stretch-animation" style="font-size: 3rem; margin-bottom: 30px;">
                        <div style="animation: stretchUpDown 1s infinite alternate;">
                            <i class="fas fa-arrow-up"></i>
                        </div>
                    </div>
                    <button class="module-btn start-btn" onclick="endStretchBreak()" style="padding: 15px 30px;">
                        <i class="fas fa-check"></i> Done Stretching!
                    </button>
                </div>
            `;
            
            document.body.appendChild(stretchOverlay);
            
            // Add stretch animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes stretchUpDown {
                    0% { transform: translateY(0) scale(1); }
                    100% { transform: translateY(-20px) scale(1.2); }
                }
            `;
            document.head.appendChild(style);
            
            // Speak stretch instructions
            queueBotMessage("Let's stretch! Reach up high, then bend down and touch your toes. Ready? 1... 2... 3...", {
                type: 'instruction',
                autoClose: true
            });
        };

        window.endStretchBreak = function() {
            const stretchOverlay = document.getElementById('stretch-overlay');
            if (stretchOverlay) {
                stretchOverlay.remove();
            }
            
            queueBotMessage("Great stretching! You're ready to focus again!", {
                type: 'encouragement',
                autoClose: true
            });
        };
        
        // Global prevention of manual detection activation
        document.addEventListener('DOMContentLoaded', function() {
            // Intercept ANY attempts to manually start detection
            const originalStartEmotion = dualCameraDetection?.startEmotionDetection;
            const originalStartEye = dualCameraDetection?.startEyeDetection;
            
            if (dualCameraDetection) {
                // Override start methods to prevent manual calls
                dualCameraDetection.startEmotionDetection = function() {
                    if (!currentGame) {
                        showNotification(
                            "Auto-Activation Only",
                            "Start a game to activate emotion detection! üéÆ",
                            "info"
                        );
                        return Promise.reject("Manual activation prevented");
                    }
                    return originalStartEmotion.call(this);
                };
                
                dualCameraDetection.startEyeDetection = function() {
                    if (!currentGame) {
                        showNotification(
                            "Auto-Activation Only",
                            "Start a game to activate eye tracking! üëÅÔ∏è",
                            "info"
                        );
                        return Promise.reject("Manual activation prevented");
                    }
                    return originalStartEye.call(this);
                };
            }
            
            // Prevent any button clicks that might try to start detection
            document.addEventListener('click', function(e) {
                const target = e.target;
                
                // Check for any detection-related text
                const detectionKeywords = [
                    'start detection', 'emotion', 'eye tracking', 'camera', 
                    'start both', 'detection', 'monitoring', 'tracking'
                ];
                
                const buttonText = target.textContent?.toLowerCase() || '';
                const isDetectionButton = detectionKeywords.some(keyword => 
                    buttonText.includes(keyword)
                );
                
                if (isDetectionButton && !currentGame) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    return false;
                }
            }, true);
        });
    </script>
</body>
</html>